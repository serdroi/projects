unit zoomingRN;
{
All comments - cyrillic encoding: Windows-1251

Модуль "Операции с мультиразрядными действительными числами типа ZReal".
(ZReal - "Zooming Real" - dynamic scalable multiprecision real numbers Type)

Версия: "1.0 Original for Delphi [Byte]". (Разработано под Delphi 7.0)

Все авторские права на настоящий модуль принадлежат Николаю Викторовичу Бочарову.
Copyright © 2005 Nikolai Victorovich Botcharov

Лицензионное соглашение.
Функционально полная версия исходного кода программного модуля "Операции с
мультиразрядными действительными числами типа ZReal" предоставляется на следующем
условии: допускается свободное применение, модификация (при обязательном изменении
номера версии) и распространение кода, в том числе и в коммерческих целях,
с обязательным размещением указанного выше копирайта в доступной для конечного
пользователя документации. При этом следует учесть, что под модификацией кода
следует понимать как добавление новых функций или процедур, так и модернизацию
существующих. Модифицированные функции и процедуры, помеченные в данном модуле
копирайтом, включая вызываемые ими процедуры и функции разрешается распространять
только при обеспечении обладателя копирайта их исходными кодами.
Под распространением следует понимать предоставление третьему лицу кода программы,
включающего настоящий или модифицированный модуль с исходными кодами, в виде
объектных файлов, или в виде исполнимого кода.
Добавленные процедуры и функции, а также модифицированные из непомеченных
копирайтом можно распространять при условии обеспечения обладателя копирайта
информацией общего характера (название и решаемая задача) без обязательного
предоставления ему исчерпывающих сведений о всех внесённых изменениях.
Обладатель копирайта на настоящий модуль не гарантирует безупречной его работы,
однако обязуется принимать деятельное участие в исправлении обнаруженных ошибок
в процессе эксплуатации данного модуля. Для последующих версий настоящего модуля
возможно изменение условия предоставления исходного кода.
Настоящий модуль имеет официальный номер версии вида: "№.№ Ключевое словосочетание".
Если вы хотите самостоятельно усовершенствовать модуль, то вы обязаны поменять
номер версии для своего модуля, заменив в нём ключевое словосочетание, и известив
об этом автора модуля версии "1.0 Original for Delphi [Byte]" Николая Викторовича
Бочарова, с которым можно связаться через Web-страницу http://dks.invitation.ru .
Если название версии модуля окажется свободным, то оно будет зарезервировано.
С момента получения Николаем Викторовичем Бочаровым кода новой версии модуля,
его номер будет официально зарегистрирован, а код модуля – выложен в свободном
доступе в Интернет. Официальная регистрация новой версии модуля необязательна,
однако не следует пренебрегать предварительным резервированием нумерации версии,
чтобы в дальнейшем не возникало путаницы при обеспечении технической поддержки
пользователей текущей и последующих версий модуля для работы с мультиразрядными
числами.
Техническая поддержка предполагается только для официально зарегистрированных
версий настоящего модуля.
________________________________________________________________________________
Назначение модуля по работе с мультиразрядными действительными числами
динамически изменяемой точности типа ZReal:

Предоставление программистам инструмента локального повышения точности вычислений
при решении научных и инженерных задач.

________________________________________________________________________________
Отличительные особенности формата числа ZReal
(в дальнейшем - "масштабируемое" действительное число):
- Динамически изменяемая длина мантиссы действительного числа;
- Динамически регулируемое правило округления при обрезании длинных чисел;
- Увеличенный до Int64 диапазон возможных значений экспоненты действительного числа.

________________________________________________________________________________
Комментарий разработчика:
- Настоящий модуль представляет собой полностью авторскую разработку Николая
Викторовича Бочарова. С автором можно связаться через Web-страницу http://dks.invitation.ru
- Настоящий модуль несёт прежде всего учебный характер по алгоритмическому
программированию элементарной математики, хотя он может быть использован и для
реальных практических приложений
- Использование настоящего модуля в коммерческих целях допустимо с обязательным
упоминанием названия и версии использованного модуля, а также имени автора его
разработчика.
- С помощью настоящего модуля можно проводить вычисления элементарных функций
с гарантинтированной точностью при любой длине числа для арифметических операций
и с гарантинтированной точностью до 1000 знаков для тригонометрических и
логарифмических функций. (Для возможности проведения вычислений с большей
разрядностью потребуется перерасчёт используемых соответствующими функциями
констант.)
- Увеличение скорости мультиразрядных вычислений, является приоритетной задачей
для последующих версий настоящего модуля, поэтому автором будут приветствоваться
работы с оптимизированными алгоритмами нижеприведённого кода по быстродействию.
- Испытать модуть в работе можно с помощью бесплатной программы
"Тестер электронных дикторов" начиная с версии 2.2.0
(http://native-speech.invitation.ru)


В долгосрочных планах:
1. Переписать модуль на Fortran, C++, а базовые функции - на Assembler.
2. Разработать алгоритмы арифметических операций с основаниями (типа Byte):
  2, 16 (- демонстрационные примеры),
  256 (- по максимальной ёмкости разрядного основания 8-bit).
3. Провести исследование на изменение скорости вычислений арифметических операций
над числами с различной разрядностью счисления.
4. Разработать формат "масштабируемого" действительного числа с ёмкостью основания
в типах Integer[32-bit], Int64[64-bit] и Int128[128-bit] (последнее, для 64-битных
процессоров). Исследовать скорость вычислений и оптимальность использования памяти
при различных типах основания "масштабируемых" действительных чисел.
5. Проработать мультиплатформенную совместимость библиотеки операций с
"масштабируемыми" действительными числами типа "Zooming Real" (ZReal).
6. Реализовать функцию генерации случайного числа.
7. Реализовать функцию вычисления Арктангенса на интервале от минус Пи до плюс Пи
8. Реализовать функцию определения НОД.

!!! !!! !!! !!! !!! !!! !!! !!! !!! !!! !!! !!! !!! !!! !!! !!! !!! !!! !!! !!!
!!! !!! !!! !!! !!! !!! !!! !!! !!! !!! !!! !!! !!! !!! !!! !!! !!! !!! !!! !!!
!!! !!! !!! !!! !!! !!! !!! !!! !!! !!! !!! !!! !!! !!! !!! !!! !!! !!! !!! !!!
Автор настоящего модуля "Операции с мультиразрядными действительными числами
типа ZReal" приглашает молодых людей, желающих заняться вышеперечисленными
исследованиями. С автором проекта можно связаться через Web-сайт:
http://dks.invitation.ru
!!! !!! !!! !!! !!! !!! !!! !!! !!! !!! !!! !!! !!! !!! !!! !!! !!! !!! !!! !!!
!!! !!! !!! !!! !!! !!! !!! !!! !!! !!! !!! !!! !!! !!! !!! !!! !!! !!! !!! !!!
!!! !!! !!! !!! !!! !!! !!! !!! !!! !!! !!! !!! !!! !!! !!! !!! !!! !!! !!! !!!

________________________________________________________________________________
Описание формата "мультиразрядного действительного числа типа ZReal"
("Zooming Real" - ZReal - dynamic scalable multiprecision real numbers Type)

Визуально формат масштабируемого действительного числа представляет собой:
1) мультиразрядное целочисленное основание;
2) буквенный индекс присутствия в числе множителя 10;
3) целочисленный показатель степени при множителе 10 (тип показателя Int64).

Под масштабированностью следует понимать динамически изменяемую длину мантиссы
целочисленного основания действительных чисел в процессе решения одной
вычислительной задачи в отличии от стандартной длины в типовых форматах
представления действительных чисел, используемых в современных компиляторах.
Так, например, арифметические операции в настоящем модуле выполняются над
входящими числами без потери значности, а на выходе выдаются числа,
представляющие собой округлённое значение урезанного до требуемой длины точности
значения арифметической операции. Это условие справедливо, если решение не
окажется "абсолютным нулём" или бесконечностью.

Внутренний формат представления "масштабируемого" действительного числа см. ниже:
"ZReal = Record".

________________________________________________________________________________
Общее содержание модуля
"Операции с мультиразрядными действительными числами типа ZReal":

В модуле прописаны стандартные арифметические операции с "масштабируемыми"
действительными числами с десятичным основанием, такие, как:
- сложение;
- вычитание;
- умножение;
- деление.
Из дополнительных функций генерации констант и Верификации "масштабируемых"
действительных чисел реализованы такие функции, как:
- генерация плюс/минус единицы;
- генерация плюс/минус бесконечного числа;
- генерация бесконечно малого числа Эпсилон (около "абсолютного нуля");
- получение младшей единицы числа  (единицы первого разряда "масштабируемого" действительного числа)
- получение старшей единицы числа  (единицы последнего разряда "масштабируемого" действительного числа)
- генерация числа Pi и кратных ему чисел;
- генерация числа e;
- унарная операция минус;
- преобразование целого или действительного числа двойной точности в
"масштабируемое" действительное число и обратно;
- верификация бесконечно большого или бесконечно малого числа;
- сравнение "масштабируемых" действительных чисел;
- и другое.
Тригонометрические функции:
- АркТангенс;
- АрккоТангенс;
- АркСинус;
- АркКосинус;
- Тангенс;
Гиперболические функции:
- гиперболический Синус
- гиперболический Косинус
- гиперболический Тангенс
- гиперболический Котангенс
- АркТангенс гиперболический;
- АрккоТангенс гиперболический;
- АркСинус гиперболический
- АркКосинус гиперболический
Другие элементарные функции:
- квадратный корень из числа
- возведение числа в целочисленную степень
- факториал
- возведение числа e в действительную степень
- натуральный логарифм
- возведение действительного числа в действительную степень
- и другое.

Кроме этого приведены функции перевода числа в строку и обратно.
В случае, если в "масштабируемом" числе показатель экспоненты при десятичном
множителе окажется равным нулю, то функция преобразования числа в строку
выдаст запись в формате целого числа, то есть без показателя экспоненты.
Функция преобразования строки в число автоматически понимает формат целого и
общепринятый формат действительного числа.

________________________________________________________________________________
Замечания.

1) По умолчанию, значность "масштабируемого" числа ограничивается 32 знаками,
но этот параметр можно менять статически, перед компиляцией программы, или
динамически, в процессе выполнения пользовательского приложения.
Динамическое управление значностью числа может быть использовано не только для
повышения точности вычислений, но и для вывода результатов вычислений на печать.

2) Тип "масштабируемых" действитеных чисел в настоящий момент позволяет
работать только лишь в десятичной системе счисления. В будущем предполагается
расширить возможности внутренней системы счисления, то есть разрешить менять
"основание числа", в связи с чем возможны существенные изменения в правилах
использования будущих библиотек обработки "масштабируемых" действитеных чисел.
Следите за описаниями. Если у кого-то возникнут предложения по дополнению
настоящего модуля арифметическими и иными функциями в других системах счисления,
то обращайтесь к Николаю Викторовичу Бочарову (http://dks.invitation.ru).

3) Количество знаков MaxZNCount в основании динамического числа не должно превышать
значения MaxInt (тестирования настоящего модуля проводилось только с числами до
1000 знаков)

4) Нумерация элементов динамического массива всегда начинается с 0 и не может
быть изменена программно. (смотри справку Delphi, тему Dynamic arrays)

5) Число в формате "масштабируемого" действительного числа через пользовательский
интерфейс можно передать только как строковую переменную с помощью функции
StrToZR(const S: String): ZReal.

6) При вводе данных запись вида "023z-1002" обозначает тоже самое, что и
"23z-1002". Нули перед "масштабируемым" действительным числом ничего не значат и
удаляются функцией TrimLeftZR. Однако, если в процессе работы программы появятся
числа вида "023z-1002", то некоторые функции могут их интерпретировать, как ноль.

7) Помимо сообщений об исключительных ситуациях выполнения операций
над действительными "масштабируемыми" числами тип ошибки также можно
идентифицировать по значению результата функции.
- Если результат имеет значение "00", то это значит, что "обнаружен
недопустимый символ в основании действительного числа или недопустимый символ
вместо символа показателя экспоненты"
- Если результат имеет значение "000", то это значит, что "обнаружен
недопустимый символ в показателе степени действительного числа"
- Если результат имеет значение "0000", то это значит, что "Показатель степени
больше максимального целого числа Int64 = 9223372036854775807"
- Если результат имеет значение "00000", то это значит, что была предпринята
попытка деления на ноль
- Если результат имеет значение "000000", то это значит, что произведение чисел
критически уходит в плюс бесконечность (то есть сумма степеней больше High(Int64))
- Если результат имеет значение "0000000", то это значит, что произведение чисел
критически уходит в минус бесконечность (то есть сумма степеней меньше Low(Int64))
- Если результат имеет значение "00000000", то это значит, что какой-либо функции
возвращено недопустимое значение аргумента

8) Внимание. Переменные -
       RoundZN    -  Byte      -   округляемое число до единицы следующего разряда (0 - обрезание числа)
       MaxZNCount -  Cardinal  -   длина мантиссы "масштабируемого" действительного числа
       InfZNCount -  Cardinal  -   длина мантиссы бесконечно большого "масштабируемого" действительного числа
 - беззнаковые. Проверка на совместимость типов данных ложится на программистов.

9) Приведённые в комментариях настоящего модуля примеры следует рассматривать,
как возможную задачу для проверки работоспособности рассматриваемой в комментарии
функции. Значения новых вычислений могут расходиться с приведёнными в тексте в
виду того, что модуль претерпевал изменения со времени проведения контрольных
расчётов, которые проводились на момент написания функции. Примеры являются
неотъемлемой частью первого выпуска модуля. В дальнейшем все примеры
предполагается удалить.
________________________________________________________________________________
Copyright © 2005 Nikolai Victorovich Botcharov
}

interface

type
    TZN =  array of Byte	;  // динамический массив цифр (В Delphi, по умолчанию, он имеет ограниченную длину в 64К)
// Тесты проводились над длинными числами с длиной массива не более 1000 знаков.

// описание типа "масштабируемого действитеного числа"
    ZReal =  Record  //   packed Record - на длинных числах приводит к заметному замедлению работы функций, например, порядка 0,1 сек для функции вычисления натурального логарифма с точностью до 1000 знаков
                  R :Byte; {arithmetic range: binary(=2), decimal(=10), hexadecimal(=16), and others}// в настоящем модуле реализована только десятичная арифметика
                  E :Int64; {number exponent (index of power)}
                  U :Char; {Unary}
                  I :TZN; {Number - array of digits}
                  end;


type
    TDynArrZR =  array of ZReal	;   // объявление типа динамического массива мультиразрядных действительных чисел

var
    ShowErrorZR: boolean = false;
    ErrorZR: boolean = false;
    MessageZR: string = '';
// ShowErrorZR - надо ли показывать окна с сообщениями об ошибках
// Если ShowErrorZR = false, то ErrorZR показывает, были ли ошибки (в операциях
// конвертирования форматов чисел, деления на ноль, умножение с вылетом
// в бесконечность), а MessageZR содержит последнее сообщение об ошибке

// MaxZNCount текущий максимальный размер мантиссы  масштабируемого числа
// не считая унарного знака и показателя степени  (number exponent)
    MaxZNCount: Cardinal = 32;   // не должно быть нулём (проверка этого
// условия должна осуществляться во всех процедурах, использующих этот параметр)

// InfZNCount длина числа
// при максимальном (High(Int64)) значении показателя степени, при котором
// число можно считать бесконечностью
    InfZNCount: Cardinal = 1000;
// внутри этого модуля InfZNCount не должно быть меньше MaxZNCount (проверка
// этого условия должна осуществляться во всех процедурах, использующих параметр
// MaxZNCount)
// Число InfZNCount используется для организации логики выполнения арифметических
// операций около "бесконечно больших" чисел и для определения условий, когда
// сумма двух действительных чисел будет "равна" одному из них.
//
// Таким образом, внутри текущего модуля InfZNCount дотягивается до MaxZNCount.
// Но программисту предоставлена возможность в управлении значениями для этих
// параметров на любом этапе алгоритма его программы.
//
// Учтите, если планируются вычисления тригонометрических или логарифмических
// функций с большей значностью, чем 1000 знаков, то следует пересчитать до
// соответствующей значности константу Пи и другие зависящие от неё константы,
// а также натуральный логарифм 2 и натуральный логарифм 10.
//
// Обратите внимание, что в машинном представлении "бесконечно большое"  число
// будет выглядеть как и обычное, типа ZReal, но вместо символа унарного знака
// используется символ I для положительных чисел, и символ i для отрицательных чисел.
// В печатном представлении "бесконечно большое"  число
// всегда будет отображаться, как "Inf" или "-Inf"
// Смысл идентификации "бесконечно больших" чисел в том, чтобы запретить
// применять к ним операции сложения (по модулю) и умножения.
// Внимание! На операции умножения бесконечных чисел результат обнуляется.
// В большинстве задач маловероятно достижение бесконечного значения типа ZReal.
// Однако в некоторых случаях может потребоваться контроль на приближение
// числовых результатов к бесконечности. Для такой проверки могут быть
// использованы предлагаемые в данном модуле функции EnabledLengthNE и
// IsInRangeNE. С помощью этих функций осуществляется проверка на вхождение
// длины показателя степени в определённый пользователем диапазон. В первом случае
// проверяется длина числового значения показателя степени, а в другом -
// абсолютное значение показателя степени.

// ZeroZNExp - значение экспоненты при целочисленном основании, равном 1, при
// котором число считается ближайшим к нулю
    ZeroZNExp:Int64 = low(Int64);  //      -MaxInt
// Если ZeroZNExp больше low(Int64), то
// Числа меньше 1*10^ZeroZNExp  всегда будут нулём.
// Такие числа называются "абсолютным нулём".

// Обратите внимание.
// В данном модуле применена постоянная предельная верхняя граница
// и динамическая нижняя граница. При этом нижняя граница никогда не окажется
// больше верхней границы вычислительной области. Минимально возможная разница
// между границ расчётной области равна восьми единицам.

// RoundZN - число округления действительного "масштабируемого" числа в большую
// сторону (по модулю) при его укорачивании до длины MaxZNCount
    RoundZN:Byte = 5;
// Внимание. Особый случай.
// Если  RoundZN=0, то число всегда округляется в сторону нуля,
// т.е. осуществляется простое обрезание числа до MaxZNCount символов
//
// Если RoundZN=5, то округление осуществляется
// ТОЛЬКО для (MaxZNCount+1) цифры масштабиуемого действительного числа по правилу:
// если N[MaxZNCount+1] > 4, то N[MaxZNCount] = N[MaxZNCount]+1
// иначе N[MaxZNCount] не меняется,
// где N - цифра "масштабируемого" действительного числа.

    RealTypeShow:Boolean = False; // Вывод результатов на печать в Real-подобном формате
// Примечание. Переменная RealTypeShow была введена только по завершению разработки
// настоящего модуля, поэтому возможны ошибки в его работе при RealTypeShow=True

const
// Версия модуля zoomingRN
  VersionZR='1.0 Original for Delphi [Byte]';

    setNumsZR = ['0'..'9'] ; // опорный числовой массив
    setUnarZR = ['+', '-'] ; // опорный унарно-знаковый массив
    setCharZR = ['z', 'Z'] ; // опорный символьный массив для обозначения типа "масштабируемых" действительных чисел
    setCharIR = ['i', 'I'] ; // контрольный символьный массив обозначений бесконечно больших чисел
    setCharPo = ['.', ','] ; // опорный символьный массив разрядных разделителей в действительном числе
    setCharER = ['e', 'E', 'е', 'Е'] ; // контрольный символьный массив обозначения типа действительных чисел

// Зарезервированные значения для основания обрабатываемых чисел:
  decimal=10; // значение по умолчанию
{
  binary=2;   // назначается, если предполагаются операции в двоичном представлении
  hexadecimal=16; // назначается, если предполагаются операции в шестнадцатиричном представлении
}

  MaxZNCountDefault=32; // размер мантиссы "масштабируемого" действительного числа (по умолчанию)

//______________________________________________________________________________

// ***************************************************************
// Операции с мультиразрядными действительными числами типа ZReal:
// ———————————————————————————————————————————————————-———————————
// - Генерация;
// - Верификация;
// - Арифметические операции;
// - Тригонометрические и гиперболические функции;
// - Дополнительные элементарные функции.
// ***************************************************************
//____________________________________________________________________________
//
// Генерация мультиразрядного действительного числа типа ZReal (56 functions)
//____________________________________________________________________________
{
В ближайших планах:

- генерация случайлого числа в интервале
}

// задание нулевого значения "масштабируемого" действительного числа
function DefaultZR: ZReal;

// задание плюс единичного значения "масштабируемого" действительного числа
function OneZR: ZReal;

// задание значения "масштабируемого" действительного числа, равного +2
function TwoZR: ZReal;

// задание значения "масштабируемого" действительного числа, равного +3
function ThreeZR: ZReal;

// задание значения "масштабируемого" действительного числа, равного +10
function TenZR: ZReal;

// задание минус единичного значения "масштабируемого" действительного числа
function minusOneZR: ZReal;

function MinExtendedZR: ZReal; {=  3.4e-4932 - значение взято из модуля Math for Delphi}

function MaxExtendedZR: ZReal; {=  1.1e+4932 - значение взято из модуля Math for Delphi}

// Бесконечно малое "масштабируемое" действительное  число
function EpsilonZR: ZReal;
// Эта функция внутри настоящего модуля не используется

// Бесконечно большое "масштабируемое" действительное  число
function InfiniteZR(Un: Char): ZReal;

// Случайное "масштабируемое" действительное  число
function RandomZR: ZReal;
// Эта функция внутри настоящего модуля не используется

// Инвертирование знака "масштабируемого" действительного числа
function InvertUnaryZR(const ZR: ZReal): ZReal;

// Абсолютное значение "масштабируемого" действительного числа
function AbsZR(const ZR: ZReal): ZReal;

// удаление начальных нулей в числе
function TrimLeftZR(var Arr:TZN): Boolean; // true - были удалены нули ; false -  нулей не найдено

// освобождение цифрового массива числа от конечных нулей
function TrimRightZR(var ZR:ZReal): Shortint; // +1 - были удалены нули ; 0 -  нулей не найдено ; -1 - операция не может быть выполнена (число возле Плюс бесконечности)

// освобождение числа от концевых нулей (особенно полезно применять перед отображением числа на экран)
function RefreshZR(var ZR:ZReal): ZReal;

// Перевод целого числа в действительное "масштабируемое"
function IntToZR(Const Int:Int64): ZReal;

// Перевод действительного "масштабируемого" числа в целое Int64
function ZRToInt(var ZR:ZReal): Int64;   //Const аналог функции Round (или Trunc) для действительных чисел (см. var: truncate)

// Перевод действительного "масштабируемого" числа в длинное целое
function ZRToLongInt(Const ZR: ZReal; Typ: ShortInt = 0): ZReal;
// typ - назначаемое правило округления
// -1 - без округления (обрезание)
// 0 - правило округления по умолчанию (зависит от значения RoundZN)
// 1 - округление в большую сторону

// Перевод действительного числа в действительное масштабируемое
function RealToZR(Const Ext	:Extended	): ZReal;

// Перевод действительного "масштабируемого" числа в действительное
function ZRToReal(var ZR:ZReal): Extended; // Const

// Создание строки со значением "масштабируемого" действительного числа
function ZRToStr(var ZR: ZReal): String; // const

// Создание "масштабируемого" действительного числа числа из строки
function StrToZR(const S: String): ZReal;

// Округление "масштабируемого" действительного числа
function TruncateZR(Rnd: Byte; const ZR: ZReal): ZReal;
// Единственная функция, которой разрешено укорачивание числового массива до размера  MaxZNCount
// Rnd  - число, округляемое в большую сторону (по модулю), и определяемое переменной RoundZN

// младшая единица числа  (единица первого разряда "масштабируемого" действительного числа)
function LowDeciZR(const ZR: ZReal): ZReal;

// старшая единица числа  (единица последнего разряда "масштабируемого" действительного числа)
function HighDeciZR(const ZR: ZReal;  out IsNearInf: Boolean): ZReal;
// (если экспонента старшего разряда числа больше High(Int64), то IsNearInf=True,
// а результат представляет собой единицу с максимальной степенью экспоненты,
// в данном модуле это число High(Int64). Знак числа в результате сохраняется.)

// Константа PI  (Число из 1000 знаков)
function Pi_ZR: ZReal;

// Константа e  (Число из 1000 знаков)
function e_ZR: ZReal;

// Константа 2*PI  (Число из 1000 знаков)
function PiMult2_ZR: ZReal;

// Константа PI/2  (Число из 1000 знаков)
function PiDiv2_ZR: ZReal;
// Константа используется для вычисления АркТангенса

// Константа PI/4  (Число из 1000 знаков)
function PiDiv4_ZR: ZReal;

// Константа PI/6  (Число из 1000 знаков)
function PiDiv6_ZR: ZReal;
// Константа используется для вычисления АркТангенса

// Константа PI/8  (Число из 1000 знаков)
function PiDiv8_ZR: ZReal;

// Константа PI/12  (Число из 1000 знаков)
function PiDiv12_ZR: ZReal;
// Константа используется для вычисления АркТангенса

// Константа PI/24  (Число из 1000 знаков)
function PiDiv24_ZR: ZReal;
// Константа используется для вычисления АркТангенса

// Константа PI/50  (Число из 1000 знаков)
function PiDiv50_ZR: ZReal;
// Константа используется для вычисления АркТангенса

// Константа PI/100  (Число из 1000 знаков)
function PiDiv100_ZR: ZReal;
// Константа используется для вычисления АркТангенса

// Константа PI/192  (Число из 1000 знаков)
function PiDiv192_ZR: ZReal;
// Константа используется для вычисления АркТангенса

// Константа PI/384  (Число из 1000 знаков)
function PiDiv384_ZR: ZReal;
// Константа используется для вычисления АркТангенса

// Константа PI/1536  (Число из 1000 знаков)
function PiDiv1536_ZR: ZReal;
// Константа используется для вычисления АркТангенса

// Константа PI/3072  (Число из 1000 знаков)
function PiDiv3072_ZR: ZReal;
// Константа используется для вычисления АркТангенса

// Константа PI/12288  (Число из 1000 знаков)
function PiDiv12288_ZR: ZReal;
// Константа используется для вычисления АркТангенса

// Константа PI/24576  (Число из 1000 знаков)
function PiDiv24576_ZR: ZReal;
// Константа используется для вычисления АркТангенса

// Константа PI/196608  (Число из 1000 знаков)
function PiDiv196608_ZR: ZReal;
// Константа используется для вычисления АркТангенса

// Константа PI/393216  (Число из 1000 знаков)
function PiDiv393216_ZR: ZReal;
// Константа используется для вычисления АркТангенса

// Константа sqrt(2)  (Число из 1000 знаков)
function Sqrt2_ZR: ZReal;

// Константа sqrt(3)  (Число из 1000 знаков)
function Sqrt3_ZR: ZReal;

// Константа 1/tg(pi/12) = 1/(2-sqrt(3))  (Число из 1000 знаков)
function OdTgPId12_ZR: ZReal;
// Константа используется для вычисления АркТангенса

// Константа 1/tg(pi/50)    (Число из 1000 знаков)
function OdTgPId50_ZR: ZReal;
// Константа используется для вычисления АркТангенса

// Константа 1/tg(pi/192)    (Число из 1000 знаков)
function OdTgPId192_ZR: ZReal;
// Константа используется для вычисления АркТангенса

// Константа 1/tg(pi/1536)   (Число из 1000 знаков)
function OdTgPId1536_ZR: ZReal;
// Константа используется для вычисления АркТангенса

// Константа 1/tg(pi/12288)   (Число из 1000 знаков)
function OdTgPId12288_ZR: ZReal;
// Константа используется для вычисления АркТангенса

// Константа 1/tg(pi/196608)   (Число из 1000 знаков)
function OdTgPId196608_ZR: ZReal;
// Константа используется для вычисления АркТангенса

// Константа - натуральный Логарифм двух  (Число из 1000 знаков)
function LnE2_ZR: ZReal;

// Константа - натуральный Логарифм трёх  (Число из 1000 знаков)
function LnE3_ZR: ZReal;

// Константа - натуральный Логарифм десяти  (Число из 1000 знаков)
function LnE10_ZR: ZReal;

//____________________________________________________________________________
//
// Верификация мультиразрядного действительного числа типа ZReal (16 functions)
//____________________________________________________________________________

// Проверка "масштабируемого" действительного числа на удовлетворение условию абсолютного нуля
// с сохранением текущей разряднности числа
function IsZero(const ZR: ZReal): Boolean;
// текущая проверка может быть использована для ускорения арифметических операций

// Проверка "масштабируемого" действительного числа на удовлетворение условию абсолютного нуля
// без сохранения текущей разряднности числа, т.е. с обнулением аргумента
function IsZeroZR(var ZR: ZReal): Boolean;

// Проверка "масштабируемого" действительного числа на присутствие признака бесконечно большого числа
function IsInfinite(const ZR: ZReal): Boolean;

// Проверка "масштабируемого" действительного числа на удовлетворение условию бесконечно большого числа
function IsInfiniteZR(var ZR: ZReal): Boolean;

// Сравнение чисел
function ComparisonZR(const ZR1, ZR2: ZReal): Shortint	;
{
сравнение чисел:
-1 - первое число меньше второго;
0 - числа равны;
+1 - первое число больше второго;
бесконечно большие числа отличаются, только если у них разные знаки)
}

// больше  заданного числа
function MoreThanZR(const WhatZR: ZReal; const ThanZR: ZReal): Boolean;

// меньше  заданного числа
function LessThanZR(const WhatZR: ZReal; const ThanZR: ZReal): Boolean	;

// равно заданному числу
function EqvToZR(const WhatZR: ZReal; const ToZR: ZReal): Boolean	;

// знак числа ( - result: +1 or 0 or -1)
function GetUnaryZR(const ZR: ZReal): Shortint;

// Проверка на вхождение длины показателя степени в допустимый пользователем диапазон (меньше или равно Len)
function EnabledLengthNE(const ZR: ZReal; Len: Integer): Boolean;
// для локальной проверки "симметричного" ухода числа в бесконечность или в ноль
// относительно нулевой степени для экспоненты
// Эта функция внутри настоящего модуля не используется

// Проверка на вхождение показателя степени в допустимый пользователем целочисленный диапазон (меньше или равно Abs(Range))
function IsInRangeNE(const ZR: ZReal; Range: Int64): Boolean;
// для локальной проверки "симметричного" ухода числа в бесконечность или в ноль
// относительно нулевой степени для экспоненты
// Эта функция внутри настоящего модуля не используется

// Длина записи "масштабируемого" действительного числа
function LengthZR(var ZR:ZReal): Cardinal; // const
// число символов в "масштабируемом" действительном числе
// Эта функция внутри настоящего модуля не используется

// Поиск порядкового номера минимального числа из одномерного динамического массива "масштабируемых" действительных чисел
function MinfromArrZR(const Arr: array of ZReal): Integer;
// Эта функция внутри настоящего модуля не используется

// Поиск порядкового номера максимального числа из одномерного динамического массива  "масштабируемых" действительных чисел
function MaxfromArrZR(const Arr: array of ZReal): Integer;
// Эта функция внутри настоящего модуля не используется

// Поиск порядковых номеров минимального и максимального числа из одномерного
// динамического массива  "масштабируемых" действительных чисел
// с описанием типа массива в качестве результата функции
{
Возможные значения результата функций
-3 - пустой числовой массив
-2 - числовой массив из одного элемента
-1 - убывающий числовой массив
 0 - массив одинаковых элементов
 1 - возрастающий числовой массив
 2 - числовой массив, представляющий собой явно выраженную нелинейную последовательность чисел
}
// приоритетная выборка минимума и максимума  по возрастающему числовому массиву
function MinMaxfromArrZR(const Arr: array of ZReal; out IndMin, IndMax: Integer): ShortInt;

// приоритетная выборка максимума и минимума  по убывающему числовому массиву
function MaxMinfromArrZR(const Arr: array of ZReal; out IndMax, IndMin: Integer): ShortInt;

//____________________________________________________________________________
//
// Арифметические операции с мультиразрядными действительными числами типа ZReal (4 base functions)
// (в функциях реализованы элементарные алгоритмы выполнения арифметических операций)
//____________________________________________________________________________
{
В ближайших планах:

- реализация оптимальных алгоритмов выполнения арифметических операций
}

// Суммирование "масштабируемых" действительных  чисел
function SumZR(const ZR1, ZR2: ZReal): ZReal;

// Разность "масштабируемых" действительных  чисел  - (ZR1 минус ZR2)
function SubZR(const ZR1, ZR2: ZReal): ZReal;

// Произведение "масштабируемых" действительных  чисел
function MultZR(const ZR1, ZR2: ZReal): ZReal;

// Деления "масштабируемых" действительных  чисел   - (ZR1 разделить на ZR2)
function DivZR(const ZR1, ZR2: ZReal): ZReal;

//____________________________________________________________________________
//
// Тригонометрические, гиперболические и другие элементарные функции
// с мультиразрядными действительными числами типа ZReal  (35 functions, 1 procedure)
//____________________________________________________________________________
{
В ближайших планах:

- определение НОД
- обратные тригонометрические и гиперболические функции
function SecantZR(const ZR: ZReal): ZReal;          // 1 / cos(X)
function CosecantZR(const ZR: ZReal): ZReal;        // 1 / sin(X)
function ArcSecZR(const ZR: ZReal): ZReal;          // IN: ZR <> 0
function ArcCscZR(const ZR: ZReal): ZReal;          // IN: ZR <> 0
function SecHZR(const ZR: ZReal): ZReal;
function CscHZR(const ZR: ZReal): ZReal;
function ArcSecHZR(const ZR: ZReal): ZReal;         // IN: ZR <> 0
function ArcCscHZR(const ZR: ZReal): ZReal;         // IN: ZR <> 0
- Сохранение в файле(дозапись)/Считывание из файла(начиная с записи под номером):
для одномерного динамического массива
для двумерного динамического массива
}

// функция 1/X
function OneDivZR(const ZR: ZReal): ZReal;

// процент от числа
function PercentZR(const Percent: ZReal; const ZR: ZReal): ZReal;

// Возведение числа в целочисленную степень
function IntPowZR(const ZR: ZReal; Power: Int64): ZReal;

// Арктангенс
function ArctanZR(const ZR: ZReal ): ZReal;

// Арккотангенс
function ArccotanZR(const ZR: ZReal ): ZReal;

// АркСинус
function ArcsinZR(const ZR: ZReal ): ZReal;

// АркКосинус
function ArccosZR(const ZR: ZReal ): ZReal;

// Квадрат числа
function SqrZR(const ZR: ZReal ): ZReal;

// Квадратный корень из числа
function SqrtZR(const ZR: ZReal ): ZReal;

// Тангенс
function TanZR(const ZR: ZReal): ZReal;

// градусы в радианы
function DegToRadZR(const ZR: ZReal): ZReal;

// радианы в градусы
function RadToDegZR(const ZR: ZReal): ZReal;

// гипотенуза: Sqrt(ZR1*ZR1 + ZR2*ZR2)
function HypotZR(const ZR1, ZR2: ZReal): ZReal;

// катет: Sqrt(ZRhyp*ZRhyp - ZRcat*ZRcat)
function CathetZR(const ZRhyp, ZRcat: ZReal): ZReal;

// сумма нескольких ПОЛОЖИТЕЛЬНЫХ чисел ZReal (компактная форма записи)
function SumArrZR(const Arr: array of ZReal): ZReal;

// произведение нескольких чисел ZReal (компактная форма записи)
function MultArrZR(const Arr: array of ZReal): ZReal;

// возведение числа в натуральную дробную степень
function FracRootZR(const ZR: ZReal; const Num, Den: Int64): ZReal;
// корень Den-степени из числа в степени Num (Integer64 NUMerator & DENominator of fraction)
// где Num - любое, а Den>1
// Если число Den нечетно, то можем взять корень из отрицательного числа!

// Факториал
function FactorZR(const NF: Int64): ZReal;

// возведение числа e в действительную степень
function ePowZR(const ZR: ZReal): ZReal;

// натуральный Логарифм
function LnZR(const ZR: ZReal): ZReal;

// Арктангенс гиперболический  (ареатангенс)
function AtanhZR(const ZR: ZReal ): ZReal;

// Арккотангенс гиперболический  (ареакотангенс)
function AcothZR(const ZR: ZReal ): ZReal;

// Арксинус гиперболический  (ареасинус)
function AsinhZR(const ZR: ZReal ): ZReal;

// Арккосинус гиперболический  (ареакосинус)
function AcoshZR(const ZR: ZReal ): ZReal;

// гиперболический Косинус
function CoshZR(const ZR: ZReal ): ZReal;

// гиперболический Синус
function SinhZR(const ZR: ZReal ): ZReal;

// гиперболический Тангенс
function TanhZR(const ZR: ZReal ): ZReal;

// гиперболический Котангенс
function CothZR(const ZR: ZReal ): ZReal;

// возведение числа в действительную степень
function PowerZR(const ZR: ZReal; Power: ZReal): ZReal;

// Логарифм по основанию 2
function Log2ZR(const ZR: ZReal): ZReal;

// Логарифм по основанию 10
function Log10ZR(const ZR: ZReal): ZReal;

// Логарифм по основанию N
function LogNZR(const Base, ZR: ZReal): ZReal;

// Котангенс
function CotanZR(const ZR: ZReal ): ZReal;

// Косинус
function CosZR(const ZR: ZReal ): ZReal;

// Синус
function SinZR(const ZR: ZReal ): ZReal;

// Синус и Косинус (одновременное вычисление)
procedure SinCosZR(const Theta: ZReal; out Sin, Cos: ZReal);

//______________________________________________________________________________

implementation

uses
     Windows, // Для обозначений флагов кнопок Windows.MessageBox
     SysUtils; // Для функций Abort , Trim , AnsiLowerCase , IntToStr и др.


//_____________________________________________________________________________
//_____________________________________________________________________________
// функции, позаимствованные из модуля Math
// Замечание: Функции модуля Math использованы только для отладки алгоритмов
// вычисления элементарных функций в формате числа Double


// типы переменных из модуля Math
type
  TMathValueSign = -1..1;
const
  MathNegativeValue = Low(TMathValueSign);
  MathZeroValue = 0;
  MathPositiveValue = High(TMathValueSign);


function MathRandomRange(const AFrom, ATo: Integer): Integer;
begin
  if AFrom > ATo then
    Result := Random(AFrom - ATo) + ATo
  else
      Result := Random(ATo - AFrom) + AFrom;
end;


function MathSign(const AValue: Double): TMathValueSign;
begin
  if ((PInt64(@AValue)^ and $7FFFFFFFFFFFFFFF) = $0000000000000000) then
    Result := MathZeroValue
  else if ((PInt64(@AValue)^ and $8000000000000000) = $8000000000000000) then
    Result := MathNegativeValue
  else
    Result := MathPositiveValue;
end;


function MathIsInfinite(const AValue: Double): Boolean;
begin
  Result := ((PInt64(@AValue)^ and $7FF0000000000000) = $7FF0000000000000) and
            ((PInt64(@AValue)^ and $000FFFFFFFFFFFFF) = $0000000000000000);
end;


function MathIntPower(const Base: Extended; const Exponent: Integer): Extended;
asm
        mov     ecx, eax
        cdq
        fld1                      { Result := 1 }
        xor     eax, edx
        sub     eax, edx          { eax := Abs(Exponent) }
        jz      @@3
        fld     Base
        jmp     @@2
@@1:    fmul    ST, ST            { X := Base * Base }
@@2:    shr     eax,1
        jnc     @@1
        fmul    ST(1),ST          { Result := Result * X }
        jnz     @@1
        fstp    st                { pop X from FPU stack }
        cmp     ecx, 0
        jge     @@3
        fld1
        fdivrp                    { Result := 1 / Result }
@@3:
        fwait
end;


{ Extract exponent and mantissa from X }
procedure MathFrexp(const X: Extended; var Mantissa: Extended; var Exponent: Integer);
{ Mantissa ptr in EAX, Exponent ptr in EDX }
asm
        FLD     X
        PUSH    EAX
        MOV     dword ptr [edx], 0    { if X = 0, return 0 }

        FTST
        FSTSW   AX
        FWAIT
        SAHF
        JZ      @@Done

        FXTRACT                 // ST(1) = exponent, (pushed) ST = fraction
        FXCH

// The FXTRACT instruction normalizes the fraction 1 bit higher than
// wanted for the definition of frexp() so we need to tweak the result
// by scaling the fraction down and incrementing the exponent.

        FISTP   dword ptr [edx]
        FLD1
        FCHS
        FXCH
        FSCALE                  // scale fraction
        INC     dword ptr [edx] // exponent biased to match
        FSTP ST(1)              // discard -1, leave fraction as TOS

@@Done:
        POP     EAX
        FSTP    tbyte ptr [eax]
        FWAIT
end;


function MathLdexp(const X: Extended; const P: Integer): Extended;
  { Result := X * (2^P) }
asm
        PUSH    EAX
        FILD    dword ptr [ESP]
        FLD     X
        FSCALE
        POP     EAX
        FSTP    ST(1)
        FWAIT
end;

// функции, позаимствованные из модуля Math
//_____________________________________________________________________________
//_____________________________________________________________________________
// локальные процедуры и функции

function IsIn9_10(const ZR: ZReal): Boolean;
// функция определяет условие, что число ZR начинается с цифр '9' или '10'
var len:Integer;
begin
// Внимание, в числе должно быть два и более знаков
  Result:=False;
  len:=Length(ZR.I);
  if len=0 then Exit;
  if len=1 then
  begin
    if ZR.I[0]=9 then Result:=True;
    Exit;
  end;
// с особыми случаями закончили

   if ZR.I[High(ZR.I)]=9 then begin Result:=True; Exit; end;
   if (ZR.I[High(ZR.I)]=1) and (ZR.I[High(ZR.I)-1]=0) then Result:=True;
end;


function IsIn999_1000(const ZR: ZReal): Boolean;
// функция определяет условие, что число ZR начинается с цифрового ряда '999' или '1000'
var len,k:Integer;
begin
// Внимание, в числе должно быть три и более знаков
  Result:=False;
  len:=Length(ZR.I);
  if len<3 then Exit;
  if len=3 then
  begin
    if (ZR.I[0]=ZR.I[2]) and (ZR.I[0]=ZR.I[1]) and (ZR.I[0]=9) then Result:=True;
    Exit;
  end;
// с особыми случаями закончили
  k:=High(ZR.I);
  if (ZR.I[k-2]=9) and (ZR.I[k-1]=9) and (ZR.I[k]=9) then
  begin Result:=True; Exit; end;
  if (ZR.I[k]=1) and (ZR.I[k-1]=0) and (ZR.I[k-2]=0) and (ZR.I[k-3]=0) then Result:=True;
end;


function IsIn99999_100000(const ZR: ZReal): Boolean;
// функция определяет условие, что число ZR начинается с цифрового ряда '99999' или '100000'
var len,k,i:Integer;
begin
// Внимание, в числе должно быть пять и более знаков
  Result:=False;
  len:=Length(ZR.I);
  if len<4 then Exit;
  if len=4 then
  begin
    for i:=0 to len-1 do
    if (ZR.I[i]<>9) then Exit;
    Result:=True;
    Exit;
  end;
// с особыми случаями закончили

  k:=High(ZR.I);
  if ZR.I[k]=9 then
  begin
    for i:=1 to 4 do
    begin
      if ZR.I[k-i]<>9 then Exit;
    end;
    Result:=True;
    Exit;
  end;

  if ZR.I[k]=1 then
  begin
    for i:=1 to 5 do
    begin
      if ZR.I[k-i]<>0 then Exit;
    end;
    Result:=True;
    Exit;
  end;

end;


// задание нулевого значения "масштабируемого" действительного числа
// для идентификации типа ошибки работы модуля
// (на тот случай, если будет отключена обработка исключительных ситуаций
//  ShowErrorZR=False)
procedure defaultZZReal(CheckNumb:Byte; var Real0 : ZReal);
var i:Byte;
begin
   if CheckNumb=0 then CheckNumb:=1; //Защита "от дурака". Входящий CheckNumb должен быть не меньше двух
   Real0.E:=0;
   Real0.U:='+';
   Real0.R:=decimal;
   SetLength(Real0.I, CheckNumb);  // создаём CheckNumb-мерный массив
   for i:=0 to CheckNumb-1 do  Real0.I[i]:=0;   // обнуляем массив (он может быть ненулевым)
end;


// оповещение пользователя об исключительных ситуациях в текущем модуле
procedure Messages(S:string);
begin
  if ShowErrorZR then
  begin
    Windows.MessageBox(GetActiveWindow, PAnsiChar(S), 'Ошибка', MB_OK + MB_ICONSTOP);
    SetActiveWindow(GetActiveWindow);  // решение проблемы проваливания окон с информационным сообщением
    Abort;
  end
  else
  begin
    ErrorZR := true;
    MessageZR := S;
  end;
end;


// процедура удаления элемента из середины динамического массива
procedure DelArrElem(var A: TDynArrZR; Index: Integer);
var
  n: Integer;
  i: Integer;
begin
   n:= High(A);
   if Index<n then
// сдвигаем массив
   begin
     for i:=Index to n-1 do
     begin
       A[i]:=A[i+1];
     end;
// назначаем новую длину массива
     SetLength(A, n-1 );
   end;
end;


// сжатие области определения тригонометрических функций
function squeezeArea(const ZR: ZReal): ZReal;
var
  ZR0: ZReal;
  BakMaxZNCount:Cardinal;
  exp: Int64;
  bool: Boolean;
begin
{
// нижеследующие условия уже проверены в вызывающий данную процедуру функциях
  if MaxZNCount=0 then MaxZNCount:=1;
  if InfZNCount<MaxZNCount then InfZNCount:=MaxZNCount;
}
    Result:=ZR;

    BakMaxZNCount:=MaxZNCount;
    exp:=HighDeciZR(ZR,bool).E;
    if exp>1000 then exp:=1000; // Внимание! 1000 - гарантированная в данном модуле максимальная точность вычислений
    if exp>0
    then MaxZNCount:=MaxZNCount+exp+2  // повышение точности вычислений для больших значений аргумента в тригонометрических функциях
    else MaxZNCount:=MaxZNCount+2;

// сокращение области определения тригонометрической функции
    while MoreThanZR(AbsZR(Result),Pi_ZR) do
    begin
      ZR0:=DivZR(Result,PiMult2_ZR);
      ZR0:=ZRToLongInt(ZR0);
      ZR0:=MultZR(PiMult2_ZR,ZR0);
      Result:=SubZR(Result,ZR0);
{
Настоящий цикл имеет непосредственную зависимость от величины MaxZNCount.
При exp много больше MaxZNCount  Result всегда будет нулевым.
Кстати, в калькуляторе Windows при exp>1000 решение всегда равно -1
}
    end;
    MaxZNCount:=BakMaxZNCount;
end;


// Cos при аргументе [0; Pi/4]  (без проверки значения аргумента)
function _CosZR(const ZR: ZReal): ZReal;
// разложение функции в ряд :
// sin(x) = x - x^2/2! + x^4/4! - ...
var
  ZR0,ZR1,ZR2,ZR3,ZR4: ZReal;
  BakMaxZNCount: Cardinal;
  bool: Boolean;
  i,j: Integer;
  iExp: Integer;
begin
    BakMaxZNCount:=MaxZNCount;

    MaxZNCount:=MaxZNCount+3;
// подготовка констант
    ZR0:=OneZR;                  // первый член разложения
    ZR4:=SqrZR(ZR);
    ZR1:=ZR0;

// вычисление разложения
// пока старший разряд очередного члена этого ряда больше нижнего разряда
// суммы предыдущих членов нашего разложения.
// для настоящего алгоритма важно, что Аргумент=[0;0,78539816339744830961566084581988], то есть всегда меньше единицы

    j:=HighDeciZR(ZR0,bool).E; // Степень старшего разряда очередного члена ряда
    iExp:=j-MaxZNCount+2; // Степень младшего разряда суммы членов ряда   (в нашем алгоритме она всегда меньше нуля)
    i:=0; //  знаменатель первого члена разложения
    ZR2:=OneZR;
    while (j>iExp) do
    begin
      MaxZNCount:=j-iExp+2; // оптимизированная длина числа очередного члена разложения
// +2 - для повышения точности вычислений
      ZR1:=MultZR(ZR4,InvertUnaryZR(ZR1)); // числитель очередного члена ряда
      Inc(i);
      ZR2:=MultZR(ZR2,IntToZR(i));
      Inc(i);
      ZR2:=MultZR(ZR2,IntToZR(i)); // факториал в знаменателе очередного члена ряда
      ZR3:=DivZR(ZR1,ZR2);
      j:=HighDeciZR(ZR3,bool).E;   // Степень старшего разряда очередного члена ряда
      MaxZNCount:=BakMaxZNCount+2; // восстановливаем точность вычислений перед суммированием членов ряда
      ZR0:=SumZR(ZR0,ZR3);
    end;

    Result:=ZR0;
    MaxZNCount:=BakMaxZNCount;
end;


// Sin при аргументе [0; Pi/4]  (без проверки значения аргумента)
function _SinZR(const ZR: ZReal): ZReal;
// разложение функции в ряд :
// sin(x) = x - x^3/3! + x^5/5! - ...
var
  ZR0,ZR1,ZR2,ZR3,ZR4: ZReal;
  BakMaxZNCount: Cardinal;
  bool: Boolean;
  i,j: Integer;
  iExp: Integer;
begin
    BakMaxZNCount:=MaxZNCount;

    MaxZNCount:=MaxZNCount+3;
// подготовка констант
    ZR0:=ZR;                  // первый член разложения
    ZR4:=SqrZR(ZR0);
    ZR1:=ZR0;

// вычисление разложения
// пока старший разряд очередного члена этого ряда больше нижнего разряда
// суммы предыдущих членов нашего разложения.
// для настоящего алгоритма важно, что Аргумент=[0;0,78539816339744830961566084581988], то есть всегда меньше единицы

    j:=HighDeciZR(ZR0,bool).E; // Степень старшего разряда очередного члена ряда
    iExp:=j-MaxZNCount+2; // Степень младшего разряда суммы членов ряда   (в нашем алгоритме она всегда меньше нуля)
    i:=1; //  знаменатель первого члена разложения
    ZR2:=OneZR;
    while (j>iExp) do
    begin
      MaxZNCount:=j-iExp+2; // оптимизированная длина числа очередного члена разложения
// +2 - для повышения точности вычислений
      ZR1:=MultZR(ZR4,InvertUnaryZR(ZR1));  // числитель очередного члена ряда
      Inc(i);
      ZR2:=MultZR(ZR2,IntToZR(i));
      Inc(i);
      ZR2:=MultZR(ZR2,IntToZR(i)); // факториал в знаменателе очередного члена ряда
      ZR3:=DivZR(ZR1,ZR2);
      j:=HighDeciZR(ZR3,bool).E;   // Степень старшего разряда очередного члена ряда
      MaxZNCount:=BakMaxZNCount+2; // восстановливаем точность вычислений перед суммированием членов ряда
      ZR0:=SumZR(ZR0,ZR3);
    end;

    Result:=ZR0;
    MaxZNCount:=BakMaxZNCount;
end;


// Sin или Cos при аргументе [0; Pi/4]
procedure Func(Const arg: ZReal; out F: ZReal; Const Ind: ShortInt);
begin
    case ind of
    -1: F:=_CosZR(arg);
     1: F:=_SinZR(arg);
    end; // case
end;

// Sin или Cos при аргументе [0; Pi/2]
procedure Si_Co(Const arg: ZReal; out F: ZReal; Const Ind: ShortInt);
// по Ind определяем, F синус или косинус
// Ind =  1 , F - синус
// Ind = -1 , F - косинус
begin
    if ComparisonZR(arg,PiDiv4_ZR)<=0
    then Func(arg, F, Ind)
    else Func(SubZR(PiDiv2_ZR,arg), F, (Ind*(-1)));
end;

// локальные процедуры и функции
//_____________________________________________________________________________
//_____________________________________________________________________________
//_____________________________________________________________________________
// глобальные функции


// удаление начальных нулей в числе
function TrimLeftZR(var Arr:TZN): Boolean;
// true - были удалены нули ; false -  нулей не найдено
var
  i:Integer; // цикловая переменная
  lenN: Integer; // длина массива
  nzero:Integer; // количество незначащих (конечных) нулей в массиве
begin
  Result:=False;
  lenN:=Length(Arr);
  nzero:=0;
  for i:=lenN-1 downto 0 do
  begin
    if Arr[i] = 0 then  Inc(nzero)
    else Break; // прерывание цикла
  end;
  if nzero > 0 then
  begin
// вылавливаем предельный случай, когда вместо числа массив нулей
    if lenN=nzero then Dec(nzero);
// теперь можно нормально завершать
    SetLength(Arr, lenN-nzero);
    if lenN>1 then Result:=True;
  end;
end;


// освобождение цифрового массива числа от конечных нулей
function TrimRightZR(var ZR:ZReal): Shortint;
// +1 - были удалены нули ; 0 -  нулей не найдено ;
// -1 - операция не может быть выполнена (число возле Плюс бесконечности)
var
  i:Integer; // цикловая переменная
  lenN: Integer; // длина массива
  nzero:Integer; // количество незначащих (конечных) нулей в массиве
begin
  Result:=0;
  lenN:=Length(ZR.I);
  nzero:=0;
// подсчёт нулей
  for i:=0 to lenN-1  do
  begin
    if ZR.I[i] = 0 then  Inc(nzero)
    else Break; // прерывание цикла
  end;

  if nzero=lenN then begin Result:=1; ZR:=DefaultZR; Exit; end;   // вырожденный случай

  if nzero > 0 then
  begin
// проверка возможности завершения функции
    if ZR.E>0 then
    if (High(Int64)-ZR.E)<nzero then begin Result:=-1; Exit; end;
// сдвиг и обрезаниеи массива
    for i:=0 to lenN-nzero-1 do
    begin
      ZR.I[i] := ZR.I[i+nzero]; //
    end;
    SetLength(ZR.I, lenN-nzero);
    ZR.E:=ZR.E+nzero;
    Result:=1;
  end;
end;


// длина записи "масштабированного" действительного числа
function LengthZR(var ZR:ZReal): Cardinal;   //  const
var
  rExp:Int64;
  isInf:Boolean;
begin
  Result:=0;
  if ZR.U='-' then Inc(Result);

  if RealTypeShow then
  begin
    rExp:=HighDeciZR(ZR,isInf).E;
    if not isInf then
    begin
      Result:=Length(ZRToStr(ZR)); // поскольку в формате с плавающей запятой производится обрезание нулей, то проще длину числа вычислить через длину его строкового обозначения
      Exit;
    end;
  end;

  if ZR.E<>0 then
  begin
    Result:=Result+Length(IntToStr(ZR.E))+1;
    if ZR.E>0 then Result:=Result+1;
  end;
  Result:=Result+Length(ZR.I);
end;


// удаление концевых нулей в числе
function RefreshZR(var ZR:ZReal): ZReal;
begin
  TrimLeftZR(ZR.I);
  TrimRightZR(ZR);
  Result:=ZR;
end;


// задание нулевого значения "масштабируемого" действительного числа
function DefaultZR: ZReal;
begin
   Result.R:=decimal;
   Result.E:=0;
   Result.U:='+';
   SetLength(Result.I, 1);  // создаём одномерный массив
   Result.I[0]:=0;
end;


// задание значения "масштабируемого" действительного числа, равного +2
function TwoZR: ZReal;
begin
   Result.R:=decimal;
   Result.E:=0;
   Result.U:='+';
   SetLength(Result.I, 1);  // создаём одномерный массив
   Result.I[0]:=2;
end;



// задание значения "масштабируемого" действительного числа, равного +3
function ThreeZR: ZReal;
begin
   Result.R:=decimal;
   Result.E:=0;
   Result.U:='+';
   SetLength(Result.I, 1);  // создаём одномерный массив
   Result.I[0]:=3;
end;


// задание плюс единичного значения "масштабируемого" действительного числа
function OneZR: ZReal;
begin
   Result.R:=decimal;
   Result.E:=0;
   Result.U:='+';
   SetLength(Result.I, 1);  // создаём одномерный массив
   Result.I[0]:=1;
end;


// задание значения "масштабируемого" действительного числа, равного +10
function TenZR: ZReal;
begin
   Result.R:=decimal;
   Result.E:=0;
   Result.U:='+';
   SetLength(Result.I, 2);  // создаём двумерный массив
   Result.I[0]:=0;
   Result.I[1]:=1;
end;

// задание значения "масштабируемого" действительного числа минус единица
function minusOneZR: ZReal;
begin
   Result.R:=decimal;
   Result.E:=0;
   Result.U:='-';
   SetLength(Result.I, 1);  // создаём одномерный массив
   Result.I[0]:=1;
end;

// инвертирование знака "масштабируемого" действительного числа)
function InvertUnaryZR(const ZR: ZReal): ZReal;
begin
Result.E:=ZR.E;
Result.R:=ZR.R;
Result.I:=ZR.I;
if ZR.U='+' then begin Result.U:='-'; Exit; end;
if ZR.U='-' then begin Result.U:='+'; Exit; end;
if ZR.U='I' then begin Result.U:='i'; Exit; end;
if ZR.U='i' then begin Result.U:='I'; Exit; end;
end;


// Абсолютное значение "масштабируемого" действительного числа
function AbsZR(const ZR: ZReal): ZReal;
begin
Result:=ZR;
if Result.U='-' then begin Result.U:='+'; Exit; end;
if Result.U='i' then begin Result.U:='I'; Exit; end;
end;


// бесконечно большое "масштабируемое" действительное  число
function InfiniteZR(Un: Char): ZReal;
var
  i:Integer;
  zArr:TZN;
begin
   Result.E:=High(Int64);
   if (Un = '+') or (Un = 'I') then Result.U:='I';
   if (Un = '-') or (Un = 'i') then Result.U:='i';
   if not (Result.U in setCharIR) then Result.U:='I';
   Result.R:=decimal;
   if MaxZNCount>InfZNCount then InfZNCount:=MaxZNCount; // контрольная проверка, чтобы не было недоразумений
   if InfZNCount=0 then InfZNCount:=1;
   SetLength(zArr, InfZNCount);  // создаём одномерный массив
   for i:=0 to InfZNCount-1 do
   zArr[i]:=9;
   Result.I:=zArr;
end;


// бесконечно малое "масштабируемое" действительное  число
function EpsilonZR: ZReal;
var
  zArr:TZN;
begin
   Result.E:=ZeroZNExp;
   Result.U:='+';
   Result.R:=decimal;
   SetLength(zArr, 1);  // создаём одномерный массив
   zArr[0]:=1;
   Result.I:=zArr;
end;


// проверка "масштабируемого" действительного числа на присутствие признака бесконечно большого числа
function IsInfinite(const ZR: ZReal): Boolean;
begin
  if (ZR.U in setCharIR) then Result:=True else Result:=False;
end;

// проверка "масштабируемого" действительного числа на удовлетворение условию бесконечно большого числа
function IsInfiniteZR(var ZR: ZReal): Boolean;
var
  j: Cardinal;
  k1,k2,m:Int64; //
begin
// контрольное условие
   if MaxZNCount=0 then MaxZNCount:=1;
   if InfZNCount<MaxZNCount then InfZNCount:=MaxZNCount;

//  снимаем признаки бесконечного числа, если они установлены
if ZR.U='I' then ZR.U:='+';
if ZR.U='i' then ZR.U:='-';

//  при отрицательной и небольшой положительной степени не беспокоимся
if ZR.E<(High(Int64)-High(Cardinal)) then begin Result:=False; Exit; end;

//
k1:=InfZNCount-Length(ZR.I);
k2:=High(Int64)-ZR.E;   // ZR.E не должно быть меньше нуля, иначе напоримся на исключительную ситуацию
m:=k1+k2; // в одну операцию вышестоящие выражения загонять опасно,
// можно вылететь за пределы допустимой области целого числа

if m>0 then begin Result:=False; Exit; end;
if m<0 then
begin
  Result:=True;
  if (ZR.U='+')
  then ZR.U:='I'
  else ZR.U:='i';
  Exit;
end;
// if m=0
for j:=0 to High(ZR.I)  do
begin
if ZR.I[j]<>9 then begin Result:=False; Exit; end;
end;
Result:=True;
if ZR.U='+' then ZR.U:='I' else ZR.U:='i';
end;


// Сравнение чисел
function ComparisonZR(const ZR1, ZR2: ZReal): Shortint	;
// Copyright © 2005 Nikolai Victorovich Botcharov
{
сравнение чисел:
-1 - первое число меньше второго;
0 - числа равны;
+1 - первое число больше второго;
бесконечно большие числа отличаются, только если у них разные знаки)
}
var
  j,k: Cardinal;
  l1,l2,k1,k2,m:Int64; //
begin
//
If (ZR1.U in setCharIR) or (ZR2.U in setCharIR) then
begin
  If (ZR1.U='I') and (ZR2.U='I') then  begin Result:=0; Exit; end;
  If (ZR1.U='i') and (ZR2.U='i') then  begin Result:=0; Exit; end;
  If (ZR1.U='I') and (not (ZR2.U='I')) then  begin Result:=1; Exit; end;
  If (ZR1.U='i') and (not (ZR2.U='i')) then  begin Result:=-1; Exit; end;
  If (not (ZR1.U='I')) and (ZR2.U='I') then  begin Result:=-1; Exit; end;
  If (not (ZR1.U='i')) and (ZR2.U='i') then  begin Result:=1; Exit; end;
end;
// вышеперечисленные условия должны перекрывать все возможные варианты соотношений, связанные с бесконечными числами

// сначало обрабатываем нулевые числа, без этой обработки нижеследующий алгоритм неправильно обработает нули
//
// Обратите внимание, что в значащих числах не должно быть нулей в начале числа.
// Это условие должно обеспечиваться всеми остальными функциями и процедурами.
{
//  (9 марта 2005 г.) условия с нулями переписаны  и перемещены над проверкой знаковых условий
if (ZR1.I[High(ZR1.I)]=0) and (ZR2.I[High(ZR2.I)]=0) then begin Result:=0; Exit; end;
if (ZR1.I[High(ZR1.I)]=0) and (ZR2.I[High(ZR2.I)]<>0) then begin Result:=-1; Exit; end;
if (ZR1.I[High(ZR1.I)]<>0) and (ZR2.I[High(ZR2.I)]=0) then begin Result:=1; Exit; end;
}
//  (21 марта 2005 г.) обработка случая пустого числового массива здесь
// не предусмотрена, хотя в неправильно написанных алгоритмах часто возникает
// ситуация, когда:
{
if Length(ZR1.I)=0 then ...
if Length(ZR2.I)=0 then ...
}
//  (9 марта 2005 г.) условия с нулями переписаны  и перемещены над проверкой знаковых условий
if (ZR1.I[High(ZR1.I)]=0) then
begin
  if (ZR2.I[High(ZR2.I)]=0) then begin Result:=0; Exit; end;
  if (ZR2.U='+') then begin Result:=-1; Exit; end                                   //  (ZR2.U='I') or ... условие уже должно быть учтено ранее
  else begin Result:=1; Exit; end; // if (ZR2.U='i') or (ZR2.U='-') then
end;
if (ZR2.I[High(ZR2.I)]=0) then
begin
  if (ZR1.U='+') then begin Result:=1; Exit; end                                   //  (ZR1.U='I') or ... условие уже должно быть учтено ранее
  else begin Result:=-1; Exit; end; // if (ZR1.U='i') or (ZR1.U='-') then
end;
{ Выбросить и забыть: (9 марта 2005 г.)
// отрицательные числа не обрабатываем, потому что при нуле в числе всегда должен
// быть "плюс", а мы на текущий момент рассматриваем  случаи с одинаковыми унарными
// знаками у сравниваемых чисел
}

// если числа не бесконечные, то имеем два явных предельных случая
If (ZR1.U='+') and (ZR2.U='-') then  begin Result:=1; Exit; end;
If (ZR1.U='-') and (ZR2.U='+') then  begin Result:=-1; Exit; end;
//

// и остальные неявные случаи с одинаковыми унарными знаками у числа
l1:=Length(ZR1.I);
l2:=Length(ZR2.I);

m:=0; // инициируем переменную только лишь по рекомендации компилятора
{
Этапы отладки:
первый тест - контроль
-90613280722117605502596821383342557177790561305112596072731571888347748233727790316461381731998916688248817182799508357980853Z+363001168
-84301510448194105961506370387649377262704773173752863065007175870714030Z-3938005
Первое число меньше второго  (неверно)

второй тест - контроль
0
5835914942964184571400841436405240424548931490976328059033Z-939147921
Второе число меньше первого   (неверно)

третий тест - контроль
2407968056307267201234036432355196202511020954898255337816933314068766307177108252623379Z+1056511285
3994571995190109602687814330424424206522100Z+1998271150
Второе число меньше первого  (неверно)
//
Ошибки алгоритма на тестовых задачах исправлены.
}
// с разными унарными знаками у экспоненты
// первый случай
if (ZR1.E>0) and (ZR2.E<0) then
begin
  k1 := (ZR2.E+l2);
  if k1<=0 then     // случай с непересекающимися экспонентами
  begin
    if ZR1.U='+' then
    begin
      Result:=1; Exit;
    end
    else
    begin
      Result:=-1; Exit;
    end;
  end
  else
  begin   // пытаемся получить что-то типа соотношения (ZR1.E+l1) - (ZR2.E+l2)
    k2:=ZR1.E-k1;
    if k2>MaxInt then  // случай с достаточно большим первым числом
    begin
      if ZR1.U='+' then
      begin
        Result:=1; Exit;
      end
      else
      begin
        Result:=-1; Exit;
      end;
    end
    else        // теперь мы смело можем плюсовать к ZR1.E, не боясь выйти за верхний предел Int64
    begin
      m:=l1+k2; //  вот мы и пришли к нашему соотношению
    end;
  end;
end;
// с разными унарными знаками у экспоненты
// второй случай
if (ZR1.E<0) and (ZR2.E>0) then
begin
  k1 := (ZR1.E+l1);
  if k1<=0 then     // случай с непересекающимися экспонентами
  begin
    if ZR1.U='+' then
    begin
      Result:=-1; Exit;
    end
    else
    begin
      Result:=1; Exit;
    end;
  end
  else
  begin   // пытаемся получить что-то типа соотношения (ZR1.E+l1) - (ZR2.E+l2)
    k2:=k1-ZR2.E;
    if k2<(-MaxInt) then  // случай с достаточно большим вторым числом
    begin
      if ZR1.U='+' then
      begin
        Result:=-1; Exit;
      end
      else
      begin
        Result:=1; Exit;
      end;
    end
    else        // теперь мы смело можем вычитать из ZR1.E, не боясь выйти за нижний предел Int64
    begin
      m:=k2-l2; //  вот мы и пришли к нашему соотношению ...
    end;
  end;
end;

// теперь выводим выражения для m, пытаясь получить всё то-же соотношение (ZR1.E+l1) - (ZR2.E+l2)
// итак, имеем ...

// с одинаковыми унарными знаками у экспоненты
if (ZR1.E>=0) and (ZR2.E>=0) then
begin
  k2:=ZR1.E-ZR2.E;

  k1:=MaxInt;
  if k2>2*k1 then
  begin
    if ZR1.U='+' then
    begin
      Result:=1; Exit;
    end
    else
    begin
      Result:=-1; Exit;
    end;
  end;
  k1:=MaxInt;
  if k2<(-2*k1) then
  begin
    if ZR1.U='+' then
    begin
      Result:=-1; Exit;
    end
    else
    begin
      Result:=1; Exit;
    end;
  end;

  k1:=l1-l2;
  m:=k1+k2;
end;
// m:=k1+k2; - загонять вышеприведённые выражения для k1 и k2 в одну операцию опасно,
// можно вылететь за пределы допустимой области целого числа
// Наша задача, предотвратить вылет из функции до возникновения исключительной ситуации. Поэтому алгоритм такой длинный.


if (ZR1.E<=0) and (ZR2.E<=0) then
begin
  k2:=ZR1.E-ZR2.E;
  
  k1:=MaxInt;
  if k2>2*k1 then
  begin
    if ZR1.U='+' then
    begin
      Result:=1; Exit;
    end
    else
    begin
      Result:=-1; Exit;
    end;
  end;
  k1:=MaxInt;
  if k2<(-2*k1) then
  begin
    if ZR1.U='+' then
    begin
      Result:=-1; Exit;
    end
    else
    begin
      Result:=1; Exit;
    end;
  end;

  k1:=ZR1.E+l1;
  k2:=ZR2.E+l2;
  m:=k1-k2;
end;

if m>0 then   // сравнение по показателю степени
begin
  if ZR1.U='+' then
  begin
    Result:=1; Exit;
  end
  else
  begin
    Result:=-1; Exit;
  end;
end;
if m<0 then      // сравнение по показателю степени
begin
  if ZR1.U='+' then
  begin
    Result:=-1; Exit;
  end
  else
  begin
    Result:=1; Exit;
  end;
end;
{
тест - контроль
90613280722117605502596821383342557177790561305112596072731571888347748233727790316461381731998916688248817182799508357980853Z+363001168
>
84301510448194105961506370387649377262704773173752863065007175870714030Z+3938005

-90613280722117605502596821383342557177790561305112596072731571888347748233727790316461381731998916688248817182799508357980853Z+363001168
<
-84301510448194105961506370387649377262704773173752863065007175870714030Z+3938005
}

// if m=0
if l1=l2 then
begin
  for j:=High(ZR1.I) downto 0  do
  begin
    if ZR1.I[j]=ZR2.I[j] then continue
    else
    begin
      if ZR1.I[j]>ZR2.I[j] then
      begin
        if ZR1.U='+' then
        begin
          Result:=1; Exit;
        end
        else
        begin
          Result:=-1; Exit;
        end;
      end
      else
      begin
        if ZR1.U='+' then
        begin
          Result:=-1; Exit;
        end
        else
        begin
          Result:=1; Exit;
        end;
      end;;
    end;
  end;

  Result:=0; Exit;
end;

if l1>l2 then
begin
  k:=High(ZR1.I)-High(ZR2.I);
  for j:=High(ZR1.I) downto k  do
  begin
    if ZR1.I[j]=ZR2.I[j-k] then continue
    else
    begin
      if ZR1.I[j]>ZR2.I[j-k] then
      begin
        if ZR1.U='+' then
        begin
          Result:=1; Exit;
        end
        else
        begin
          Result:=-1; Exit;
        end;
      end
      else    // ZR1.I[j]<ZR2.I[j-k]
      begin
        if ZR1.U='+' then
        begin
          Result:=-1; Exit;
        end
        else
        begin
          Result:=1; Exit;
        end;
      end;;
    end;
  end;

  for j:=k-1 downto 0  do
  if ZR1.I[j]>0 then
  begin
    if ZR1.U='+' then
    begin
      Result:=1; Exit;
    end
    else
    begin
      Result:=-1; Exit;
    end;
  end;

// числа всё-таки равны
  Result:=0; Exit;

end
else  // l1<l2
begin
  k:=High(ZR2.I)-High(ZR1.I);
  for j:=High(ZR2.I) downto k  do
  begin
    if ZR1.I[j-k]=ZR2.I[j] then continue
    else
    begin
      if ZR1.I[j-k]>ZR2.I[j] then
      begin
        if ZR1.U='+' then
        begin
          Result:=1; Exit;
        end
        else
        begin
          Result:=-1; Exit;
        end;
      end
      else   // ZR1.I[j-k]<ZR2.I[j]
      begin
        if ZR1.U='+' then
        begin
          Result:=-1; Exit;
        end
        else
        begin
          Result:=1; Exit;
        end;
      end;;
    end;
  end;

  for j:=k-1 downto 0  do
  if ZR2.I[j]>0 then
  begin
    if ZR1.U='+' then
    begin
      Result:=-1; Exit;
    end
    else
    begin
      Result:=1; Exit;
    end;
  end;
  
// числа всё-таки равны
  Result:=0; Exit;

end;
//
end;


// Проверка масштабируемого действительного числа на удовлетворение условию абсолютного нуля
// с сохранением текущей разряднности числа
function IsZero(const ZR: ZReal): Boolean;
// ищем число меньше Epsilon
begin
// начало: добавление от 12 марта
  if Length(ZR.I)=0 then begin Result:=True; Exit; end;// здесь не разбираемся, что это не число
  if (Length(ZR.I)=1) and (ZR.I[0]=0) then begin Result:=True; Exit; end;// это условие необходимо для ловли отрицательных степеней при нуле
// конец: добавление от 12 марта

  if (ZR.E < ZeroZNExp) then
  begin
{$R+}  // включение проверки вычислений в области допустимого диапазона
try
    if (ZR.E+Length(ZR.I)-1)< ZeroZNExp
    then begin Result:=True; Exit; end
    else
    begin
      if (ZR.E+Length(ZR.I)-1)> ZeroZNExp
      then begin Result:=False; Exit; end
      else
      begin
        if ZR.I[High(ZR.I)]<1
        then begin Result:=True; Exit; end
        else
        begin Result:=False; Exit; end;
      end;
    end;
except
  Result:=False;  // хотя, это может быть и не так. требуется более детальная проработка возможных ситуаций
end;
{$R-}
  end
  else
  Result:=False;
end;


// Проверка масштабируемого действительного числа на удовлетворение условию абсолютного нуля
// без сохранения текущей разряднности числа, т.е. с обнулением аргумента
function IsZeroZR(var ZR: ZReal): Boolean;
// переделать
begin
  if IsZero(ZR) then
  begin
    ZR:=DefaultZR;
    Result:=True;
  end
  else
  begin
    Result:=False;
  end;
end;


// Проверка на вхождение длины показателя степени в допустимый пользователем диапазон (меньше или равно Len)
function EnabledLengthNE(const ZR: ZReal; Len: Integer): Boolean;
begin
    if (Length(IntToStr(Abs(ZR.E))))>Len then
      Result:=False
    else
      Result:=True;
end;


// Проверка на вхождение показателя степени в допустимый пользователем целочисленный диапазон (меньше или равно Abs(Range))
function IsInRangeNE(const ZR: ZReal; Range: Int64): Boolean;
var
  exp:Int64;
begin
    exp:=Abs(ZR.E);      // -9223372036854775808..9223372036854775807
    if exp>Range then
      Result:=False
    else
      Result:=True ;
end;

// Округление масштабируемого действительного числа
function TruncateZR(Rnd: Byte; const ZR: ZReal): ZReal;
// Единственная функция, которой разрешено укорачивание числового массива до размера  MaxZNCount
// Rnd  - число, округляемое в большую сторону (по модулю), и определяемое переменной RoundZN
//
// функция не зависит от системы счисления  (от величины основания)
var
    i:Cardinal; // цикловые переменные
    N:Cardinal; // число урезанных цифр
    K:Cardinal; // переменная, для контроля длины числа
    deci:ShortInt;
begin
  Result:=ZR;
  K := Length(ZR.I);
  if (K <= MaxZNCount) then  Exit;   // длина числа не превышает допустимый размер
//
    N:=K-MaxZNCount;
    if Result.E > (High(Int64)-N) then    // не позволяем обрезать число, если значение степени при этом перейдёт предельно допустимое значение целого числа
    begin
      Exit;
    end
    else
    begin
// обрезаем ненулевой остаток  и переписываем его в новый массив
      SetLength(Result.I, MaxZNCount); // переназначаем длину числа
      for i:=0 to (MaxZNCount-1) do
      begin
        Result.I[i]:=ZR.I[i+N];  // сдвиг массива
      end;
      Result.E:=Result.E + N;
// получили результат без округления

// если требуется только отсечь правую часть числа, то
      if Rnd=0 then Exit; // выхол
// иначе
      if ZR.I[N-1]>=Rnd then
      begin
// добавим функцию округления
        for i:=0 to (MaxZNCount-1) do
        begin
          deci:=Result.I[i]+1;
          if deci=Result.R then
          begin
            Result.I[i]:=0;
            Continue;            // оставили перебегающую разрядную единицу в виде deci=Result.R
          end
          else
          begin
            Result.I[i]:=deci;
            deci:=0;
            Break;
          end;
        end;
        if deci=Result.R then   // у нас осталась неизрасходованная разрядная единица
        begin // удлинение нашего числа на одну цифру
          SetLength(Result.I, MaxZNCount+1); // переназначаем длину числа
          Result.I[MaxZNCount]:=1;
        end;
      end;
//
    end;

// Здесь может потребоваться двойной проход по алгоритму функции.
  if Length(Result.I)>MaxZNCount then
// Но на самом деле - это не проблема, достаточно только сдвинуть и укоротить
// результитующий массив масштабируемого числа
  begin
    if Result.E<High(Int64) then // условие, допускающее повторное обрезание
    begin
      for i:=0 to (MaxZNCount-1) do
      begin
        Result.I[i]:=Result.I[i+1];  // сдвиг массива
      end;
      SetLength(Result.I, MaxZNCount);
      Result.E:=Result.E+1; // снова меняем степень
    end;
  end;
end;


// Создание масштабируемого действительного числа из строки с целым, действительным или масштабируемым действительным числом
function StrToZR(const S: String): ZReal;
// Copyright © 2005 Nikolai Victorovich Botcharov
var i, N:Cardinal; // цикловые переменные
    sTmp,    // обрабатываемая строка без концевых пробелов и спец. символов
    sIntP,   // строка мантиссы числа
    sExpN    // строка показателя степени
          :String ;
    bExp: Boolean ; // признак считывания из числовой строки экспоненты
    jExp: Shortint ; // коэффициент, определяющий унарный знак при  показателе степени
    ch: Char; // обрабатываемый символ из числовой строки
//
    iInt: Cardinal; // контрольное число для функции выборки начальных нулей
    iNext: Cardinal; // шаг, с которого срабатывает переключатель функции выборки начальных нулей в прочитанном числе
    iPoint: Integer; // длина дробной части действительного числа
//
    zArr:TZN;  // массив целочисленного основания масштабируемого действительного числа
begin
// контрольное условие
   if MaxZNCount=0 then MaxZNCount:=1;
//

  sIntP:='';  // целая часть считываемого числа
  sExpN:='';  // показатель степени
  bExp:=False;
  jExp:=1;
//
ErrorZR := false;
//
sTmp := Trim(S); // обрезание концевых пробелов
// из-за этого удобства мы наращиваем накладные расходы
N := Length(sTmp);
//
  Result.R:=decimal; // ситуация с этим параметром пока не проработана
  Result.U:='+';
  Result.E:=0; // значение показателя степени по умолчанию
// Здесь необходимо назначение числа экспоненты, потому что оно может быть
// и не указано, то есть пользователь может задать целочисленное значение
//
// 1. проверка данных
//
  if N=0 then  // защита от пустой строки
  begin
    Messages('Функция StrToZR :' + #13'Строка не является числом:'+ #13+S);
    Result:=DefaultZR;  // создание нулевого масштабируемого числа
    exit;
  end;
//
// считывание бесконечно больших и бесконечно малых чисел
  sTmp:=AnsiLowerCase(sTmp); // перевод строки с числом в нижний регистр
// из-за этого удобства мы наращиваем накладные расходы
  if (sTmp='inf') or (sTmp='+inf') then begin Result:=InfiniteZR('I'); Exit;  end;
  if sTmp='-inf' then begin Result:=InfiniteZR('i'); Exit; end;
  if (sTmp='eps') or (sTmp='+eps') then begin Result:=EpsilonZR; Exit; end;
  if sTmp='-eps' then begin Result:=InvertUnaryZR(EpsilonZR); Exit; end;
//
  iPoint:=-1;
  for i:=1 to N do
  begin
    ch:=sTmp[i];
    if not bExp then  // считываем не показатель степени
    begin
      if (ch in setNumsZR) then    // цифра
      begin
        sIntP:=sIntP + ch;
        if iPoint>-1 then Inc(iPoint);
        continue;
      end;
      if (ch in setCharPo) then    // десятичная точка (запятая)
      begin
        if iPoint<0 then begin iPoint:=0; continue; end
        else
        begin
          Messages('Функция StrToZR :' + #13'Строка не является числом:'+ #13+S);
          defaultZZReal(2,Result);  // создание нулевого масштабируемого числа
          exit;
        end;
      end;
      if (ch in setUnarZR) then  // унарный знак  на первом мете
      begin
        if  i=1  then
        begin
          Result.U:=ch ;
          continue;
        end
        else   // унарный знак  не на первом мете
        begin
          Messages('Функция StrToZR :' + #13'Строка не является числом:'+ #13+S);
          defaultZZReal(2,Result);  // создание нулевого масштабируемого числа
          exit;
        end;
      end;
      if (ch in setCharZR) then   // символ экспоненты
      begin
        if iPoint>-1 then
        begin
          Messages('Функция StrToZR :' + #13'Строка не является числом:'+ #13+S);
          defaultZZReal(2,Result);  // создание нулевого масштабируемого числа
          exit;
        end;
        bExp:=True;
        continue;
      end;
      if (ch in setCharER) then   // символ экспоненты
      begin
        bExp:=True;
        continue;
      end;
// проверили на допустимые символы иначе вызываем исключение
      Messages('Функция StrToZR :' + #13'Строка не является числом:'+ #13+S);
      defaultZZReal(2,Result);  // создание нулевого масштабируемого числа
      exit;
    end
    else   // считываем показатель степени
    begin
      if (ch in setNumsZR) then  // цифра
      begin
        sExpN:=sExpN + ch;
        continue;
      end;
      if (ch in setUnarZR) then
      begin
        if (ch='-') then jExp:=-1;  // унарный знак
        continue;
      end;
// проверили на допустимые символы иначе вызываем исключение
      Messages('Функция StrToZR :' + #13'Строка не является числом:'+ #13+S);
      defaultZZReal(3,Result);  // создание нулевого масштабируемого числа
      exit;
    end;
  end;
//
// 2. преобразование строки в числовое выражение
// (прошлись по всем символам, теперь формируем запись числа в Результат)
//
// определяем значение экспоненты
  if Length(sExpN)>Length(IntToStr(High(Int64))) then
        begin
          Messages('Функция StrToZR :' + #13'Показатель степени больше максимального целого числа:'+ #13+sExpN);
          defaultZZReal(4,Result);  // создание нулевого масштабируемого числа
          exit;
        end;
// заполняем значение экспоненты
try
  if sExpN<>'' then
    Result.E:= StrToInt64(sExpN)*jExp;
  if iPoint>-1 then Result.E := Result.E - iPoint;  // эта операция не должна вызвать исключительную ситуацию
except
// в отладке это исключение приводит к зависанию Delphi
          Messages('Функция StrToZR :' + #13'Показатель степени больше максимального целого числа:'+ #13+sExpN);
          defaultZZReal(4,Result);  // создание нулевого масштабируемого числа
          exit;
end;

//
// целочисленное основание масштабируемого действительного числа
  N := Length(sIntP);
// 07.03.05 заплатка
// если целочисленное основание не определено, то считаем, что число есть Ноль
  if N=0 then
  begin
    Result:=DefaultZR;
    Exit;
  end;
// удаление начальных нулей из числа
    iNext:=0;
    for i:=1 to N-1 do     // цикл вплоть до предпоследнего числа  (если N=1, то в цикл не попадаем)
    begin
      iInt:=StrToInt(sIntP[i]);
      if (iInt<>0) then
// одинарный переключатель на первый не ноль в числе
      begin
        iNext:=i;
        SetLength(zArr, N-i+1);  // определяем размерность массива
        Break; //
      end;
    end;
// если ещё не добрались до значащей цифры, то оставляем последнюю цифру в новом числе
    if iNext=0 then
    begin
      iNext:=N;
      SetLength(zArr, 1);
      iInt:=StrToInt(sIntP[iNext]);
      if iInt=0 then
      begin
        Result:=DefaultZR;  // создание нулевого масштабируемого числа
        exit;
      end
// редакция 11 february 2005
//      else
//      begin
//        zArr[0]:=iInt;      // имеем число из одной цифры
//      end
    end;
//
{
редакция 11 february 2005 - нижеприведённый код выполняется функцией TruncateZR
    K := Length(zArr);
// с учётом предельной размерности
  if (K <= MaxZNCount) then    // длина числа не превышает допустимый
//  размер динамического массива масштабируемого действительного числа
  begin

// весь ненулевой остаток переписываем в массив
    for i:=iNext to N do
    begin
      iInt:=StrToInt(sIntP[i]);
      zArr[N-i]:=iInt;      // Внимание!
      // заполнение массива производится в обратном порядке
    end;
  end
  else   // длина числа превышает допустимый размер динамического массива
//  масштабируемого действительного числа
  begin
//
    if Result.E > (High(Int64)-(K - MaxZNCount)) then    // не позволяем обрезать число, если значение степени при этом перейдёт предельно допустимое значение целого числа
    begin
// весь ненулевой остаток переписываем в массив
      for i:=iNext to N do
      begin
        iInt:=StrToInt(sIntP[i]);
        zArr[N-i]:=iInt;      // Внимание!
      // заполнение массива производится в обратном порядке
      end;
    end
    else
    begin
// обрезаем ненулевой остаток  и переписываем его в новый массив
      SetLength(zArr, MaxZNCount); // переназначаем длину числа
      for i:=iNext to (iNext+MaxZNCount-1) do
      begin
        iInt:=StrToInt(sIntP[i]);
        zArr[N-(K - MaxZNCount)-i]:=iInt;      // Внимание!
      // заполнение массива производится в обратном порядке
      end;
//  получаем результат без округления
// в будущем здесь можно будет добавить функцию округления  (алгоритм огругления
// потребует функцию суммирования, что на длинных числах может привести
// к существенному увеличению общего времени математических вычислений)
//
// сейчас осталось исправить значение степени считанного числа
      if Result.E>0 then  Result.E:=Result.E - MaxZNCount + K
      else  Result.E:=Result.E + K - MaxZNCount;
    end;
//
  end;
}
// весь ненулевой остаток переписываем в массив
    for i:=iNext to N do
    begin
      iInt:=StrToInt(sIntP[i]);
      zArr[N-i]:=iInt;      // Внимание!
      // заполнение массива производится в обратном порядке
    end;
  Result.I:=zArr; // массив числа сформирован
//
  Result:=TruncateZR(RoundZN, Result); // округление числа  до  MaxZNCount
// делаем проверку, является число бесконечно большим или абсолютным нулём
  if IsInfiniteZR(Result) then Exit;
  IsZeroZR(Result);
//
end;


// случайное "масштабируемое" действительное  число
function RandomZR: ZReal;
// результат работы настоящей функции не является в полном смысле случайным числом с нормальным распределением
// "случайное" число имеет область ограничея со степенью |MaxInt|
var
  lenN:Integer;  // длина целочисленного основания масштабируемого действительного числа
  zArr:TZN;  // массив целочисленного основания масштабируемого действительного числа
  i:Integer;
//
begin
// контрольное условие
   if MaxZNCount=0 then MaxZNCount:=1;
//
Randomize;
  Result.R:=decimal; // ситуация с этим параметром пока не проработана
try
    Result.E:=MathRandomRange(0,High(Integer));// степень в положительной области
    i:=MathRandomRange(0,2);  // унарный знак
    if  i=0     then Result.E:=-Result.E-1; // степень в отрицательной области
except
    Result.E:=1234567;
end;
    i:=MathRandomRange(0,2);
    if  i=0 then Result.U:='-' else Result.U:='+';     // унарный знак
{$R+}  // включение проверки вычислений в области допустимого диапазона
try
    lenN:=MathRandomRange(1,MaxZNCount+1);                   // длина целочисленного основания
except
    lenN:=MaxZNCountDefault;                   // длина целочисленного основания
end;
{$R-}
    SetLength(zArr, lenN);
    for i:=0 to lenN-1 do
    begin
      zArr[i]:=MathRandomRange(0,10);      // Внимание!
      // первое число входит в допустимый диапазон, а второе - не входит
    end;
    Result.I:=zArr;                                    // число
// удаление  в числе  левых нулей
    TrimLeftZR(Result.I);
//
end;


// Создание строки со значением масштабируемого действительного  числа
function ZRToStr(var ZR : ZReal): String; // Здесь нельзя передать переменную ZR, как const, потому что здесь используется функция TrimRightZR, обрабатывающая зависимую переменную(, иначе происходит порча исходных данных)
// Copyright © 2005 Nikolai Victorovich Botcharov
var i, N, M:Cardinal; // цикловые переменные
    Exp:Int64;
    sTmp :String;   // обрабатываемая строка без концевых пробелов и спец. символов
    ZR0:ZReal; // укороченный ZR
    rExp:Int64;
    isInf:Boolean;
    rmVar:ShortInt;
begin
// контрольное условие
   if MaxZNCount=0 then MaxZNCount:=1;
//
// проверка числа на информационную строку об ошибке
  N:=Length(ZR.I);
  if N=0 then begin Result:='NN'; Exit; end;// добавление от 12 марта 2005 года - 'нет числа'
  if (N=2) and (ZR.I[1]=0)
  then  begin Result:='00'; Exit; end;
  if (N=3) and (ZR.I[2]=0)
  then  begin Result:='000'; Exit; end;
  if (N=4) and (ZR.I[3]=0)
  then  begin Result:='0000'; Exit; end;
  if (N=5) and (ZR.I[4]=0)
  then  begin Result:='00000'; Exit; end;
  if (N=6) and (ZR.I[5]=0)
  then  begin Result:='000000'; Exit; end;
  if (N=7) and (ZR.I[6]=0)
  then  begin Result:='0000000'; Exit; end;
  if (N=8) and (ZR.I[7]=0)
  then  begin Result:='00000000'; Exit; end;
{
  if (N=9) and (ZR.I[8]=0)
  then  begin Result:='000000000'; Exit; end;
}
//
// проверка числа на бесконечно большое значение
  if (ZR.U='I') then begin Result:='Inf'; Exit; end;
  if (ZR.U='i') then begin Result:='-Inf'; Exit; end;
// проверка числа на абсолютный ноль
  if IsZero(ZR)  then begin Result:='0'; Exit; end;

  sTmp:=''; // создаём временную строку

  if ZR.U='-' then sTmp:='-';

  M:=MaxZNCount;

  if M>=N then
    ZR0:=ZR
  else
  begin
    ZR0:=TruncateZR(RoundZN, ZR); // попытка обрезания масштабируемого числа до MaxZNCount значащих цифр
    N:=Length(ZR0.I); // поскольку предыдущая операция не всегда выполнима, то мы, переопределяя N, не можем записать N:=M
  end;

  if RealTypeShow then  // печатать результат в формате Real (с плавающей запятой после первого знака)
  begin
    rmVar:=TrimRightZR(ZR0);  // освобождение числового массива от правых нулей
    if rmVar>0 then
    begin
      N:=Length(ZR0.I); // обязательное переопределение длины массива
      ZR:=ZR0; // обязательное обновление исходной переменной (во избежание порчи данных) 
    end;
    rExp:=HighDeciZR(ZR0,isInf).E;
    if not isInf then   // предостерегаемся от невозможности напечатать число в Real-подобном формате
    begin
// формируем строку-число
      if N>1 then
      for i:= N-1 downto 0 do         //  т.к. нумерация ZR0.I идёт от нуля
      begin
        if i=N-2 then sTmp:=sTmp+DecimalSeparator+IntToStr(ZR0.I[i]) // вставляем плавающую запятую. Важно, DecimalSeparator может иметь значения ',' или '.'
        else sTmp:=sTmp+IntToStr(ZR0.I[i]);
      end
      else sTmp:=sTmp+IntToStr(ZR0.I[0]);
// печать степенного показателя
      if rExp<>0 then   // пропускаем нулевой степенной показатель
        if rExp>0 then
          sTmp:=sTmp+'E+'+IntToStr(rExp)
        else
          sTmp:=sTmp+'E'+IntToStr(rExp);  // минус в числе

      Result:=sTmp; // результат конвертирования числа в строку
      Exit;
    end;
  end;

// только теперь можно разобраться с экспонентой
    Exp:=ZR0.E ;  // целое число типа Int64;

// формируем строку-число
    for i:= N-1 downto 0 do         //  т.к. нумерация ZR0.I идёт от нуля
    begin
      sTmp:=sTmp+IntToStr(ZR0.I[i]);
    end;

// печать степенного показателя
    if Exp<>0 then
    begin
// наше число действительное
      if Exp>0 then
        sTmp:=sTmp+'Z+'+IntToStr(Exp)
      else
        sTmp:=sTmp+'Z'+IntToStr(Exp);  // минус в числе
    end;

  Result:=sTmp;
end;


// Суммирование действительных масштабируемых чисел
function SumZR(const ZR1, ZR2: ZReal): ZReal;
// Copyright © 2005 Nikolai Victorovich Botcharov
// обратите внимание, последовательность цифр в мультиразрядных числах хранится в обратном порядке
// используемые операции с "масштабируемыми" действительными числами: сравнение
var
  eqv:ShortInt;
  zArr:TZN;  // массив целочисленного основания масштабируемого действительного числа
  i:Integer; // цикловая переменная
  lenN:Integer;  // длина целочисленного основания масштабируемого действительного числа
  expDif:Int64; // разность значений числовых экспонент
  expDif02:Int64; // дополнительная разность
  k:ShortInt; // сумма цифр в одном разряде при сложении двух чисел
  deci: ShortInt; // значение второго разряда числа k.
  ZR01, ZR02 : ZReal;
  minusLCount:Int64; // minusLCount = -InfZNCount
  un:Char; // к алгоритму сложения отрицательных чисел
begin
// нижеследующий алгоритм построен на условии, что значение экспоненты первого числа больше значения экспоненты второго числа
  if ZR1.E>=ZR2.E then begin ZR01:=ZR1; ZR02:=ZR2; end
  else begin ZR02:=ZR1; ZR01:=ZR2; end ;
// суммирование бесконечностей
If IsInfinite(ZR1) or IsInfinite(ZR2) then
begin
// ловим операцию вычитания
  If (ZR1.U = '-') and (ZR2.U = 'i') then  begin  Result:=ZR2; Exit; end;
  If (ZR1.U = 'i') and (ZR2.U = '-') then  begin  Result:=ZR1; Exit; end;
  if (ZR1.U = 'I') and (ZR2.U = 'i') then  begin  Result:=DefaultZR; Exit; end;
  if (ZR1.U = 'i') and (ZR2.U = 'I') then  begin  Result:=DefaultZR; Exit; end;
  if (ZR1.U = 'i') and (ZR2.U = 'i') then  begin  Result:=ZR1; Exit; end;
{
  If (ZR1.U = 'I') and (ZR2.U = '-') then  ZR1.U:='+';
  If (ZR1.U = '-') and (ZR2.U = 'I') then  ZR2.U:='+';
// эти варианты будут автоматически учтены чуть ниже
}
// остальные случаи
  if (ZR1.U = 'I') and (ZR2.U = 'I') then  begin  Result:=ZR1; Exit; end;
  if (ZR1.U = 'I') and (ZR2.U = '+') then  begin  Result:=ZR1; Exit; end;
  if (ZR1.U = '+') and (ZR2.U = 'I') then  begin  Result:=ZR2; Exit; end;
{
  if (ZR1.U='I') then ZR1.U:='+';
  if (ZR1.U='i') then ZR1.U:='-';
  if (ZR2.U='I') then ZR2.U:='+';
  if (ZR2.U='i') then ZR2.U:='-';
// эти условия невозможно удовлетворить в описанном выше виде, потому что
ZR1 и ZR2 - константы
}
  if (ZR01.U='I') then ZR01.U:='+';
  if (ZR01.U='i') then ZR01.U:='-';
  if (ZR02.U='I') then ZR02.U:='+';
  if (ZR02.U='i') then ZR02.U:='-';
end;
//
// контрольное условие
   if MaxZNCount=0 then MaxZNCount:=1;
   if InfZNCount<MaxZNCount then InfZNCount:=MaxZNCount;

//
// одно из чисел отрицательное
  if (ZR01.U='-')and(ZR02.U='+') then
  begin
    ZR01.U:='+';
    Result:=SubZR(ZR02, ZR01);
    Exit;
  end;
  if (ZR01.U='+')and(ZR02.U='-') then
  begin
    ZR02.U:='+';
    Result:=SubZR(ZR01, ZR02);
    Exit;
  end;

minusLCount:=InfZNCount;
minusLCount:=-minusLCount;
// одно из чисел "меньше единицы"
  if (ZR01.E>=0) and (ZR02.E<0)
  then
  begin
    if ZR01.E>(InfZNCount+Length(ZR02.I)) then begin Result:=ZR01; IsInfiniteZR(Result); Exit; end;
    if (ZR02.E+Length(ZR02.I))<minusLCount then begin Result:=ZR01; IsInfiniteZR(Result); Exit; end;
  end;
{
// исходя из алгоритма функции на нижеследующий шаг мы никак не должны попасть
// алгоритм функции построен на условии, что значение экспоненты первого числа больше значения экспоненты второго числа
  if (ZR01.E<0) and (ZR02.E>0)
  then
  begin
    if ZR02.E>(InfZNCount+Length(ZR01.I)) then begin Result:=ZR02; IsInfiniteZR(Result); Exit; end;
    if (ZR01.E+Length(ZR01.I))<minusLCount then begin Result:=ZR02; IsInfiniteZR(Result); Exit; end;
  end;
}
// оба числа "меньше единицы"   - (?) 9 марта - неправильное описание к нижеследующему условию
  if (ZR01.E<0) and (ZR02.E<0)
  then
  begin
    if ZR01.E>=ZR02.E then
    if ZR01.E-ZR02.E>(InfZNCount+Length(ZR02.I)) then begin Result:=ZR01; IsInfiniteZR(Result); Exit; end;
{
    else
// исходя из алгоритма функции на нижеследующий шаг мы никак не должны попасть
// алгоритм функции построен на условии, что значение экспоненты первого числа больше значения экспоненты второго числа
    if ZR02.E-ZR01.E>InfZNCount then begin Result:=ZR02; Exit; end;
}    
  end;
// остальные случаи
//
  un:=ZR1.U; // для учёта случая сложения двух отрицательных чисел
  ZR01:=AbsZR(ZR1);
  ZR02:=AbsZR(ZR2);
//
  eqv:=ComparisonZR(ZR01,ZR02);// это условие требует особого учёта случая сложения отрицательных чисел
// поэтому выше мы подготовили параметр un и взяли абсолютное значение из суммируемых чисел
//
//

  deci:=0;
//  if (ZR01.E>=0) or (ZR02.E>=0) then // складываем положительные числа больше единицы
//  begin
//    if (ZR01.E>=ZR02.E) then
//    begin
      expDif:=ZR01.E-ZR02.E; // к разности следует относисться осторожно, чтобы не вылететь за пределы допустимых значений Int64
// в нижеследующем алгоритме expDif должно быть не меньше нуля
// если это не так, то нужно уменьшить экспоненту второго числа
      if expDif<0 then
      begin           // выравнивание значений экспонент у суммируемых чисел
        expDif:=abs(expDif);
{
// можно показать, что нижеследующее условие в настоящем алгоритме не реализуемо
        if expDif>InfZNCount then
        begin
          Result:=ZR01;
          Result.U:=un; // для учёта случая сложения двух отрицательных чисел
          Exit;
        end;
}
        SetLength(ZR02.I,Length(ZR02.I)+expDif);
        for i:=Length(ZR02.I)-1 downto expDif do
        begin
          ZR02.I[i]:=ZR02.I[i-expDif];
        end;
        for i:=0 to expDif-1 do
        begin
          ZR02.I[i]:=0;
        end;
        expDif:=0; // таким образом, разница между значений экспонент обнулилась
        ZR02.E:=ZR01.E; // теперь мы полностью обновили второе число
      end;

//       if expDif>InfZNCount then   // обнаружена ошибка 09.03.05 . Если  InfZNCount=3;  ZR02=0,123; ZR01=1, (без нулей после запятой) , то это условие говорит, что решение есть ZR01, то есть 1, хотя на самом деле решение должно быть 1,12 .
      if (expDif+Length(ZR01.I)-MaxZNCount)>InfZNCount then   // исправлена ошибка  09.03.05
      begin
        Result:=ZR01;
        Result.U:=un; // для учёта случая сложения двух отрицательных чисел
        IsInfiniteZR(Result);
        Exit;
      end;
      if eqv>0 then
      begin          // первое число больше второго
        lenN:=Length(ZR01.I)+expDif; // длина нового числа
        SetLength(zArr, lenN);

        if expDif>Length(ZR02.I) then
        begin    // суммируемые числа не пересекаются в крайних разрядах
          if MaxZNCount < ( lenN - Length(ZR02.I) + 1 ) then
          begin  // особый случай
            Result:=ZR01;
            Result.U:=un; // для учёта случая сложения двух отрицательных чисел
            IsInfiniteZR(Result);
            Exit;
          end;
//  иначе собираем новое число по частям
          for i:=0 to High(ZR02.I) do zArr[i]:=ZR02.I[i];  // правый хвост нового числа со вторым суммируемым числом
          for i:=Length(ZR02.I) to expDif-1 do zArr[i]:=0;  // пустое поле
          for i:=expDif to lenN-1 do zArr[i]:=ZR01.I[i-expDif];  // левый хвост нового числа с первым суммируемым числом
        end
        else
        begin  // суммируемые числа пересекаются в крайних разрядах
          expDif02:=lenN-Length(ZR02.I);
          for i:=0 to expDif-1 do   // правый хвост без суммы
          begin
            zArr[i]:=ZR02.I[i];
          end;
          for i:=expDif to lenN-expDif02-1 do    // непосредственное поразрядное суммирование
          begin
            k:=ZR01.I[i-expDif]+ZR02.I[i]+deci;
            if k>9 then begin deci:=1; k:=k-10; end else deci:=0;
            zArr[i]:=k;
          end;
          if not (expDif02=0) then
          begin
            for i:=lenN-expDif02 to lenN-1 do    // левый хвост без суммы
            begin
              k:=ZR01.I[i-expDif]+deci;
              if k>9 then begin deci:=1; k:=k-10; end else deci:=0;
              zArr[i]:=k;
            end;
          end;
          if deci>0 then begin SetLength(zArr, lenN+1); zArr[lenN]:=deci; end;
        end;
      end
      else
      begin    // второе число больше или равно первому

        if eqv=0 then   // второе число равно первому
        begin
          if  Length(ZR01.I)>Length(ZR02.I) then  ZR01:=ZR02 else ZR02:=ZR01;   // исправление дыры, обнаруженной 01.04.05 (удаление нулей из переменных)
          lenN:=Length(ZR01.I); // длина нового числа
          SetLength(zArr, lenN);
          for i:=0 to lenN-1 do    // непосредственное поразрядное суммирование
          begin
            k:=ZR01.I[i]+ZR01.I[i]+deci;
            if k>9 then begin deci:=1; k:=k-10; end else deci:=0;
            zArr[i]:=k;
          end;
          if deci>0 then begin SetLength(zArr, lenN+1); zArr[lenN]:=deci; end;
        end
        else
        begin   // второе число больше первого

          lenN:=Length(ZR02.I); // длина нового числа
          expDif02:=lenN-expDif-Length(ZR01.I);
          SetLength(zArr, lenN);
          for i:=0 to expDif-1 do   // правый хвост без суммы
          begin
            zArr[i]:=ZR02.I[i];
          end;
          for i:=expDif to lenN-expDif02-1 do    // непосредственное поразрядное суммирование
          begin
// 25 марта 2005 - обнаружена ошибка в следующей строке
//            k:=ZR01.I[i-expDif]+ZR02.I[i]+deci;   // она не может быть выполнена, если пытаться просуммировать 693Z-3  и 0
// В этой функции нужно либо исключить выполнение операции сложения, если один из членов - ноль,
// либо поставить условие (-заплатку) следующего вида:
            if i > High(ZR02.I) then k:=ZR01.I[i-expDif]+deci
            else k:=ZR01.I[i-expDif]+ZR02.I[i]+deci;
// Возможность присутствия подобной ошибки в других частях текущего алгоритма ещё не исследовалась.
            if k>9 then begin deci:=1; k:=k-10; end else deci:=0;
            zArr[i]:=k;
          end;
          if not (expDif02=0) then
          begin
            for i:=lenN-expDif02 to lenN-1 do    // левый хвост без суммы
            begin
              k:=ZR02.I[i]+deci;
              if k>9 then begin deci:=1; k:=k-10; end else deci:=0;
              zArr[i]:=k;
            end;
          end;
          if deci>0 then begin SetLength(zArr, lenN+1); zArr[lenN]:=deci; end;
        end;
      end;
      Result.E:=ZR02.E;  // 01.04.05 обнаружена дыра: если просуммировать 2Z+0 и 2000Z-3, то получим результат 4Z-3 !!!! исправление ищи выше : "if eqv=0 then"
      Result.R:=decimal;
      Result.U:=un; // для учёта случая сложения двух отрицательных чисел
      Result.I:=zArr;

  IsZeroZR(Result);
//  укорачивание числа до требуемой длины точности
  if Length(Result.I)>MaxZNCount then Result:=TruncateZR(RoundZN,Result);  //
  IsInfiniteZR(Result);
{
// если не предполагать работу с целыми числами то можно сокращать запись числа на количество правых нулей
  TrimRightZR(Result);
}
// выход их функции сложения
//    Exit;
//  end;
end;


// Разность масштабируемых действительных  чисел  - (ZR1 минус ZR2)
function SubZR(const ZR1, ZR2: ZReal): ZReal;
// Copyright © 2005 Nikolai Victorovich Botcharov
// используемые операции с "масштабируемыми" действительными числами: суммирование , сравнение
var
  ZR0, ZR01, ZR02 : ZReal;
  eqv:ShortInt;
  zArr:TZN;  // массив целочисленного основания масштабируемого действительного числа
  i:Integer; // цикловая переменная
  lenN:Integer;  // длина целочисленного основания масштабируемого действительного числа
  expDif:Int64; // разность значений числовых экспонент
  k:ShortInt; // разность цифр в одном разряде при вычитании
  deci: ShortInt; // значение соответствует кол-ву единиц взятых из соседнего левого разряда числа при вычитании
  un:Char; // к алгоритму вычитания из малого числа большого
  minusLCount:Int64; // minusLCount = -InfZNCount
begin
//  замена входящих констант на локальные переменные
  ZR01:=ZR1;
  ZR02:=ZR2;
// Разность бесконечностей
If IsInfinite(ZR1) or IsInfinite(ZR2) then
begin
// ловим операцию сложения
  if (ZR1.U='I') and (ZR2.U='i') then begin  Result:=ZR1; Exit; end;
  if (ZR1.U='I') and (ZR2.U='-') then begin  Result:=ZR1; Exit; end;
// остальные случаи
  if (ZR1.U='i') and (ZR2.U='I') then begin  Result:=ZR1; Exit; end;
  if (ZR1.U='-') and (ZR2.U='I') then begin  Result:=InvertUnaryZR(ZR2); Exit; end;
  if (ZR1.U='i') and (ZR2.U='i') then begin  Result:=DefaultZR; Exit; end;
  if (ZR1.U='I') and (ZR2.U='I') then begin  Result:=DefaultZR; Exit; end;
{
  if (ZR1.U='i') and (ZR2.U='-') then ZR1.U:='-';
  if (ZR1.U='-') and (ZR2.U='i') then ZR2.U:='+';
// случаи будут учтены автоматически чуть ниже
}
//
{
  if (ZR1.U='I') then ZR1.U:='+';
  if (ZR1.U='i') then ZR1.U:='-';
  if (ZR2.U='I') then ZR2.U:='+';
  if (ZR2.U='i') then ZR2.U:='-';
// входящие константы не можем изменять
}
  if (ZR01.U='I') then ZR01.U:='+';
  if (ZR01.U='i') then ZR01.U:='-';
  if (ZR02.U='I') then ZR02.U:='+';
  if (ZR02.U='i') then ZR02.U:='-';
end;

// инверсные случаи - разность превращается в сложение
  if (ZR01.U='-')and(ZR02.U='+') then
  begin                            // сложение отрицательных чисел
    ZR02.U:='-';
    IsInfiniteZR(ZR01);
    IsInfiniteZR(ZR02);
    Result:=SumZR(ZR01, ZR02);
    Exit;
  end;

  if (ZR01.U='+')and(ZR02.U='-') then
  begin                            // сложение положительных чисел
    ZR02.U:='+';
    IsInfiniteZR(ZR01);
    IsInfiniteZR(ZR02);
    Result:=SumZR(ZR01, ZR02);
    Exit;
  end;

  un:='+'; // по рекомендации компилятора
// то есть на время отладки функции

  if (ZR01.U='-')and(ZR02.U='-') then
  begin                            // сложение положительных чисел
    eqv:=ComparisonZR(AbsZR(ZR01),AbsZR(ZR02)); // мы можем выполнить вычитание только из большего числа меньшего
    if eqv=0 then begin Result:=DefaultZR; IsInfiniteZR(Result); Exit; end;
// условия учёта случая вычитания из малого числа большого
    if eqv<0 then begin un:='+'; ZR0:=ZR01; ZR01:=ZR02; ZR02:=ZR0; end
    else
    if eqv>0 then un:='-';
  end;

  if (ZR01.U='+')and(ZR02.U='+') then
  begin                            // сложение положительных чисел
    eqv:=ComparisonZR(AbsZR(ZR01),AbsZR(ZR02)); // мы можем выполнить вычитаие только из большего числа меньшего
    if eqv=0 then begin Result:=DefaultZR; Exit; end;
// условия учёта случая вычитания из малого числа большого
    if eqv<0 then
    begin un:='-'; ZR0:=ZR01; ZR01:=ZR02; ZR02:=ZR0; end
    else
    if eqv>0 then un:='+';
  end;
//
// контрольное условие
   if MaxZNCount=0 then MaxZNCount:=1;
   if InfZNCount<MaxZNCount then InfZNCount:=MaxZNCount;
//
// это условие требует особого учёта случая сложения отрицательных чисел
// поэтому выше мы подготовили параметр un и взяли абсолютное значение из суммируемых чисел


minusLCount:=InfZNCount;
minusLCount:=-minusLCount;

// одно из чисел "меньше единицы"
  if (ZR01.E>=0) and (ZR02.E<0)
  then
  begin
    if (ZR01.E-Length(ZR02.I))>InfZNCount then begin Result:=ZR01; Result.U:=un; IsInfiniteZR(Result); Exit; end;
    if (ZR02.E+Length(ZR02.I))<minusLCount then begin Result:=ZR01; Result.U:=un; IsInfiniteZR(Result); Exit; end;
  end;
{
  if (ZR01.E<0) and (ZR02.E>0)
  then
  begin
//...
  end;
// случай не критичен, потому что мы уже подготовились, чтобы  ZR01 было больше ZR02
}
// оба числа "меньше единицы"
  if (ZR01.E<0) and (ZR02.E<0)
  then
  begin
    if (ZR01.E-ZR02.E)>(InfZNCount+Length(ZR02.I)) then
    begin Result:=ZR01; Result.U:=un; IsInfiniteZR(Result); Exit; end
// практически, запись InfZNCount+Length(ZR02.I) корректна, потому что
// InfZNCount, равная Length(...) и не может быть больше High(Integer).
// тип переменной InfZNCount (:Cardinal) позволяет нам просуммировать High(Integer)
  end;
// оба числа "больше единицы"
  if (ZR01.E>=0) and (ZR02.E>=0)
  then
  begin
    if (ZR01.E-ZR02.E)>(InfZNCount+Length(ZR02.I)) then
    begin Result:=ZR01; Result.U:=un; IsInfiniteZR(Result); Exit; end
  end;

//
// вычисление разности
//
// 1. выравнивание чисел по экспонентам
      expDif:=ZR01.E-ZR02.E;

      if expDif<0 then
      begin   // выравнивание значений экспонент у обрабатываемых вычитанием чисел
        expDif:=abs(expDif);

        SetLength(ZR02.I,Length(ZR02.I)+expDif);
        for i:=Length(ZR02.I)-1 downto expDif do
        begin
          ZR02.I[i]:=ZR02.I[i-expDif];
        end;
        for i:=0 to expDif-1 do
        begin
          ZR02.I[i]:=0;
        end;
//          expDif:=0; // таким образом, разница между значений экспонент обнулилась
        ZR02.E:=ZR01.E; // теперь мы полностью обновили второе число
      end
      else
      begin
        if expDif=0 then
        else
        begin
          SetLength(ZR01.I,Length(ZR01.I)+expDif);
          for i:=Length(ZR01.I)-1 downto expDif do
          begin
            ZR01.I[i]:=ZR01.I[i-expDif];
          end;
          for i:=0 to expDif-1 do
          begin
            ZR01.I[i]:=0;
          end;
//        expDif:=0; // таким образом, разница между значений экспонент обнулилась
          ZR01.E:=ZR02.E; // теперь мы полностью обновили первое число
        end;
      end;
// вытягивание второго числа до размера первого
// для упрощения алгоритма операции вычитания
      if  Length(ZR02.I)<Length(ZR01.I) then
      begin
        SetLength(ZR02.I,Length(ZR01.I));
{
        for i:=Length(ZR02.I) to Length(ZR01.I)-1 do
        begin
          ZR02.I[i]:=0;
        end;
// операция лишняя        
}        
      end;

// 2. непосредственное вычитание
  deci:=0;
        lenN:=Length(ZR01.I); // длина нового числа
        SetLength(zArr, lenN);
// учитываем, что числа хранятся в массивах в обратном порядке
          for i:=0 to lenN-1 do
          begin
            k:=ZR01.I[i]-ZR02.I[i]-deci;
            if k<0 then begin deci:=1; k:=10+k; end else deci:=0;
            zArr[i]:=k;
          end;
// удаление начальных нулей в числе с результатом, то есть удаление конечных нулей в массиве zArr
          TrimLeftZR(zArr); // удаление начальных нулей в числе
// формируем числовое значение результата работы функции
      Result.E:=ZR01.E;
      Result.R:=decimal;
      Result.U:=un; // для учёта случая вычитания из малого числа большого
      Result.I:=zArr;

  IsZeroZR(Result);
//  укорачивание числа до требуемой длины точности
  if Length(Result.I)>MaxZNCount then Result:=TruncateZR(RoundZN,Result);  //
  IsInfiniteZR(Result);
{
// если не предполагать работу с целыми числами то можно сокращать запись числа на количество правых нулей
  TrimRightZR(Result);
}
end;


// Произведение масштабируемых действительных  чисел
function MultZR(const ZR1, ZR2: ZReal): ZReal;
// Copyright © 2005 Nikolai Victorovich Botcharov
{
- Если результат имеет значение "000000", то это значит, что произведение чисел
критически уходит в плюс бесконечность (то есть у положительного числа сумма степеней больше High(Int64)) 9223372036854775807
- Если результат имеет значение "0000000", то это значит, что произведение чисел
критически уходит в минус бесконечность (то есть у отрицательного числа сумма степеней меньше High(Int64)) 9223372036854775807
}

// На время выполнения операции перемножения чисел величина MaxZNCount увеличивается на удвоенную величину длины числа с максимальной длиной
// используемые операции с масштабируемыми действительными числами: суммирование
var
  ZR01, ZR02 : ZReal;
  Len1,Len2:Integer; // длины чисел
  expRes : Int64; // величина экспоненты результата произведения чисел
  un:Char; // знак выполнения процедуры перемножения чисел
  i,j:Integer; // цикловые переменные
  bakMaxZNCount:Integer;
  bakInfZNCount:Integer;
  ZR0 : ZReal;  //  число с промежуточными суммами
  ZRdec : ZReal; //  первое число помноженное на разрядную цифру второго
  deci: ShortInt; // число, переходящее в следующий разряд при поразрядном перемножении
  k:ShortInt; // произведение разрядных цифр
begin
  if Length(ZR1.I)>=Length(ZR2.I)
  then begin ZR01:=ZR1; ZR02:=ZR2; end
  else begin ZR01:=ZR2; ZR02:=ZR1; end;
//
// произведение бесконечностей
If IsInfinite(ZR1) or IsInfinite(ZR2) then
begin
//----------- ловим плюс бесконечность ----------------
  If (ZR1.U = 'I') and (ZR2.U = 'I') then
  begin
      Messages('Функция MultZR :' + #13+
               'Произведение чисел критически уходит в плюс бесконечность'+ #13+
               IntToStr(ZR1.E)+ #13+IntToStr(ZR2.E));
      defaultZZReal(6,Result);  // создание нулевого масштабируемого числа
      exit;
  end;
  If (ZR1.U = 'I') and (ZR2.U = '+') and (ZR2.E > 0) then
  begin
      Messages('Функция MultZR :' + #13+
               'Произведение чисел критически уходит в плюс бесконечность'+ #13+
               IntToStr(ZR1.E)+ #13+IntToStr(ZR2.E));
      defaultZZReal(6,Result);  // создание нулевого масштабируемого числа
      exit;
  end;
  if (ZR1.U = 'i') and (ZR2.U = 'i') then
  begin
      Messages('Функция MultZR :' + #13+
               'Произведение чисел критически уходит в плюс бесконечность'+ #13+
               IntToStr(ZR1.E)+ #13+IntToStr(ZR2.E));
      defaultZZReal(6,Result);  // создание нулевого масштабируемого числа
      exit;
  end;
  if (ZR1.U = 'i') and (ZR2.U = '-') and (ZR2.E > 0) then
  begin
      Messages('Функция MultZR :' + #13+
               'Произведение чисел критически уходит в плюс бесконечность'+ #13+
               IntToStr(ZR1.E)+ #13+IntToStr(ZR2.E));
      defaultZZReal(6,Result);  // создание нулевого масштабируемого числа
      exit;
  end;

  If (ZR1.U = '+') and (ZR2.U = 'I') and (ZR1.E > 0) then
  begin
      Messages('Функция MultZR :' + #13+
               'Произведение чисел критически уходит в плюс бесконечность'+ #13+
               IntToStr(ZR1.E)+ #13+IntToStr(ZR2.E));
      defaultZZReal(6,Result);  // создание нулевого масштабируемого числа
      exit;
  end;
  if (ZR1.U = '-') and (ZR2.U = 'i') and (ZR1.E > 0) then
  begin
      Messages('Функция MultZR :' + #13+
               'Произведение чисел критически уходит в плюс бесконечность'+ #13+
               IntToStr(ZR1.E)+ #13+IntToStr(ZR2.E));
      defaultZZReal(6,Result);  // создание нулевого масштабируемого числа
      exit;
  end;
//----------- ловим минус бесконечность ----------------

  If (ZR1.U = 'I') and (ZR2.U = 'i') then
  begin
        Messages('Функция MultZR :' + #13 +
                 'Произведение чисел критически уходит в минус бесконечность'+ #13+
                 IntToStr(ZR1.E)+ #13 +IntToStr(ZR2.E));
        defaultZZReal(7,Result);  // создание нулевого масштабируемого числа
      exit;
  end;
  If (ZR1.U = 'i') and (ZR2.U = 'I') then
  begin
        Messages('Функция MultZR :' + #13 +
                 'Произведение чисел критически уходит в минус бесконечность'+ #13+
                 IntToStr(ZR1.E)+ #13 +IntToStr(ZR2.E));
        defaultZZReal(7,Result);  // создание нулевого масштабируемого числа
      exit;
  end;
  If (ZR1.U = 'I') and (ZR2.U = '-') and (ZR2.E > 0) then
  begin
        Messages('Функция MultZR :' + #13 +
                 'Произведение чисел критически уходит в минус бесконечность'+ #13+
                 IntToStr(ZR1.E)+ #13 +IntToStr(ZR2.E));
        defaultZZReal(7,Result);  // создание нулевого масштабируемого числа
      exit;
  end;
  If (ZR1.U = '-') and (ZR2.U = 'I') and (ZR1.E > 0) then
  begin
        Messages('Функция MultZR :' + #13 +
                 'Произведение чисел критически уходит в минус бесконечность'+ #13+
                 IntToStr(ZR1.E)+ #13 +IntToStr(ZR2.E));
        defaultZZReal(7,Result);  // создание нулевого масштабируемого числа
      exit;
  end;
  If (ZR1.U = '+') and (ZR2.U = 'i') and (ZR1.E > 0) then
  begin
        Messages('Функция MultZR :' + #13 +
                 'Произведение чисел критически уходит в минус бесконечность'+ #13+
                 IntToStr(ZR1.E)+ #13 +IntToStr(ZR2.E));
        defaultZZReal(7,Result);  // создание нулевого масштабируемого числа
      exit;
  end;
  If (ZR1.U = 'i') and (ZR2.U = '+') and (ZR2.E > 0) then
  begin
        Messages('Функция MultZR :' + #13 +
                 'Произведение чисел критически уходит в минус бесконечность'+ #13+
                 IntToStr(ZR1.E)+ #13 +IntToStr(ZR2.E));
        defaultZZReal(7,Result);  // создание нулевого масштабируемого числа
      exit;
  end;
// На этот момент должны быть охвачены все случаи с бесконечностями.
// и должен быть произведён выход из функции.
// Иначе бесконечности могут исчезнуть в результате выполнения операции умножения чисел:
  if (ZR01.U='I') then ZR01.U:='+';
  if (ZR01.U='i') then ZR01.U:='-';
  if (ZR02.U='I') then ZR02.U:='+';
  if (ZR02.U='i') then ZR02.U:='-';
end;

  if (ZR01.E>=0) and (ZR02.E>=0) then
  begin
{$R+}  // включение проверки вычислений в области допустимого диапазона
    try // контроль на допустимый диапазон степени
      expRes:=ZR01.E+ZR02.E;    // вычисляем новую величину степени
    except // обработка проверки исключительной ситуации
      Messages('Функция MultZR :' + #13+
               'Произведение чисел критически уходит в плюс бесконечность'+ #13+
               IntToStr(ZR01.E)+ #13+IntToStr(ZR02.E));
      defaultZZReal(6,Result);  // создание нулевого масштабируемого числа
      exit;
    end;
{$R-}  // отключение проверки вычислений в области допустимого диапазона
  end
  else
  begin
    if (ZR01.E<0) and (ZR02.E<0) then
    begin
{$R+}  // включение проверки вычислений в области допустимого диапазона
      try // контроль на допустимый диапазон степени
        expRes:=ZR01.E+ZR02.E;    // вычисляем новую величину степени
      except // обработка проверки исключительной ситуации
        Messages('Функция MultZR :' + #13 +
                 'Произведение чисел критически уходит в минус бесконечность'+ #13+
                 IntToStr(ZR01.E)+ #13 +IntToStr(ZR02.E));
        defaultZZReal(7,Result);  // создание нулевого масштабируемого числа
        exit;
      end;
{$R-}  // отключение проверки вычислений в области допустимого диапазона
    end
    else
    begin
      expRes:=ZR01.E+ZR02.E;    // вычисляем новую величину степени без проверок
    end;
  end;

  Len1:=Length(ZR01.I);
  Len2:=Length(ZR02.I);

    if (ZR01.U='+') and (ZR02.U='+') then un:='+'
    else if (ZR01.U='-') and (ZR02.U='-') then un:='+'
         else un:='-';

// контрольное условие
   if MaxZNCount=0 then MaxZNCount:=1;
   if InfZNCount<MaxZNCount then InfZNCount:=MaxZNCount;

   bakMaxZNCount:=MaxZNCount;
   bakInfZNCount:=InfZNCount;
   if (MaxInt div 2) > Len1 then MaxZNCount:=Len1*2;
//  с этого момента и до конца функции не должно быть никаких её прерываний
// чтобы не потерять bakMaxZNCount
  ZR0 := defaultZR;
  ZRdec := defaultZR;
   for i:=0 to Len2-1 do
   begin    // поразрядное перемножение чисел
     if ZR02.I[i]=0 then continue; // пропускаем шаг
     deci:=0;
     SetLength(ZRdec.I,Length(ZR01.I)+i);
     for j:=0 to i-1 do
     begin
       ZRdec.I[j]:=0;
     end;

     for j:=0 to Len1-1 do
     begin
       k:=ZR01.I[j]*ZR02.I[i]+deci;
       deci:=k div 10;
//       ZRdec.I[j+i]:=k - deci*10;
       ZRdec.I[j+i]:=k mod 10; // остаток от целочисленного деления
     end;
     if deci>0 then
     begin SetLength(ZRdec.I,Length(ZRdec.I)+1); ZRdec.I[High(ZRdec.I)]:=deci; end;
     ZR0:=SumZR(ZR0,ZRdec);
   end;


  Result:=ZR0;  // присваиваем результат операции перемножения
{
// освобождение массивов
  ZRdec := defaultZR;
  ZR0 := defaultZR;
}
  Result.E:= expRes; // Result.E +
  Result.U:= un;
  MaxZNCount :=bakMaxZNCount;
  InfZNCount :=bakInfZNCount;  // восстанавливаем текущую предельную разрядность
  IsZeroZR(Result);
//  укорачивание числа до требуемой длины точности
  if Length(Result.I)>MaxZNCount then Result:=TruncateZR(RoundZN,Result);  //
  IsInfiniteZR(Result);
{
// если не предполагать работу с целыми числами то можно сокращать запись числа на количество правых нулей
  TrimRightZR(Result);
}
end;


// Деления масштабируемых действительных  чисел   - (ZR1 разделить на ZR2)
function DivZR(const ZR1, ZR2: ZReal): ZReal;
// Copyright © 2005 Nikolai Victorovich Botcharov
// exception - 00000 - возможна исключительная ситуация: деление на ноль
// используемые операции с "масштабируемыми" действительными числами: вычитание и сравнение
var
  ZR01 : ZReal; // числитель без степени
  ZR02 : ZReal; // знаменатель без степени
  Len1,Len2,Len01,LenR,LenZR0:Integer; // длины чисел
  expRes : Int64; //
  expShift : Int64; // сдвиг степени
  LenShift : Integer; // сдвиг в числителе ZR01 до урезанного числителя ZRdec
  i,j:Integer; // цикловые переменные
  un:Char; // знак выполнения процедуры перемножения чисел

  ZRdec : ZReal; //  урезанный числитель из числителя дроби
  ZR0 : ZReal;  //  разность урезанного числителя ZRdec и знаменателя ZR02
// из вышеперечисленный чисел ZRdec и ZR0 можно было бы обойтись одним числом, но с двумя проще алгоритм
  zArr:TZN;  // массив целочисленного основания результата деления ZR01 на ZR02
  eqv:ShortInt; // результат сравнения урезанного числителя (в том числе, за вычетом знаменателя) и знаменателя
  k:ShortInt; // разрядная цифра результата деления
  bakMaxZNCount:Integer;
  bakInfZNCount:Integer;
begin
// ловим явное деление на ноль
  if ComparisonZR(ZR2,DefaultZR)=0 then
  begin
      Messages('Функция DivZR: Деление на ноль');
      defaultZZReal(5,Result);  // создание нулевого масштабируемого числа
      exit;
  end;
{
// обработка бесконечностей
If IsInfinite(ZR1) or IsInfinite(ZR2) then
begin
//----------- ловим плюс бесконечность ----------------
  If (ZR1.U = 'I') and  (ZR2.E < 0) then
  begin
      Messages('Функция DivZR :' + #13+
               'Деление чисел критически уводит в плюс бесконечность'+ #13+
               IntToStr(ZR1.E)+ #13+IntToStr(ZR2.E));
      defaultZZReal(5,Result);  // создание нулевого масштабируемого числа
      exit;
  end;
//----------- ловим минус бесконечность ----------------
  If (ZR1.U = 'i') and  (ZR2.E > 0) then
  begin
      Messages('Функция DivZR :' + #13+
               'Деление чисел критически уводит в минус бесконечность'+ #13+
               IntToStr(ZR1.E)+ #13+IntToStr(ZR2.E));
      defaultZZReal(5,Result);  // создание нулевого масштабируемого числа
      exit;
  end;
end;
}
// контрольное условие
   if MaxZNCount=0 then MaxZNCount:=1;
   if InfZNCount<MaxZNCount then InfZNCount:=MaxZNCount;

//
  Len1:=Length(ZR1.I);
  Len2:=Length(ZR2.I);
// вычисляем необходимую длину числителя для обеспечения требуемой точности результата деления
  expShift:=MaxZNCount+Len2+2 ; //  + 2 = единица на прозапас для левого нуля в результирующем числе (иногда появляется из алгоритма деления столбиком) + единица на округление
// вычисляем требуемое удлинение числителя, то есть сдвиг для экспоненты  первого числа
  if  expShift>Len1 then
  expShift:=expShift-Len1
  else expShift:=0;
//  замена входящих констант ZR1 и ZR2 на локальные переменные ZR01 и ZR02
  ZR02:=ZR2;
  ZR02.E:=0;
  ZR01:=DefaultZR;
  SetLength(ZR01.I,Len1+expShift);
//  if expShift>0 then
//  begin
    for i:=0 to Len1-1 do
    begin
      ZR01.I[i+expShift]:=ZR1.I[i];
    end;
//  end;

// определяемся со знаком результата деления
  if (ZR1.U='-') then ZR01.U:='-';
  if (ZR1.U='I') then ZR01.U:='+';
  if (ZR1.U='i') then ZR01.U:='-';
  if (ZR2.U='I') then ZR02.U:='+';
  if (ZR2.U='i') then ZR02.U:='-';
    if (ZR01.U='+') and (ZR02.U='+') then un:='+'
    else if (ZR01.U='-') and (ZR02.U='-') then un:='+'
         else un:='-';
// теперь можно поменять знак у ZR02, чтобы правильно работала функция ComparisonZR(ZR0, ZR02) далее по алгоритму
  ZR02.U:='+';

// обрабатываем предельные случаи около бесконечностей
  if (ZR1.E>0) and (ZR2.E<=InfZNCount) then
  begin
    if (ZR1.E-High(Int64)+InfZNCount)>ZR2.E then
    begin
      if un='+' then Result:=InfiniteZR('I') else Result:=InfiniteZR('i');
      exit;
    end
  end;
// обрабатываем предельный ноль
  if (ZR1.E<=InfZNCount) and (ZR2.E>=0) then
  begin
    if (ZR2.E-High(Int64)+InfZNCount)>ZR1.E then
    begin
      Result:=DefaultZR;
      exit;
    end
  end;
//
{$R+}  // включение проверки вычислений в области допустимого диапазона
try
  if ZR1.E>=0 then
    expRes:=ZR1.E-expShift +1 -ZR2.E
  else
    expRes:=ZR1.E +1 -ZR2.E-expShift;
// не понимаю, почему к expRes надо прибавить единицу
except
// трудно вообразить себе все критические случаи ...
// поэтому, предупредим пользователя, когда мы бессильны
      Messages('Функция DivZR :' + #13+
               'Алгоритм вычисления значения экспоненты результата'+#13+
               'для операции деления в отладке.'+ #13+
               IntToStr(ZR1.E)+ #13+IntToStr(ZR2.E));
      defaultZZReal(5,Result);  // создание нулевого масштабируемого числа
      exit;
// Комментарий от 12.03.05:
// Важно! Здесь надо рассмотреть случай деления EpsilonZR на число меньше единицы,
// когда невозможно определить экспоненту результата с увеличенной на сдвиг expShift разрядностью.
// (хорошая тема из разряда головоломок - решение точно существует, но как его втиснуть в существующий алгоритм?)
end;
{$R-}


  Len01:=Length(ZR01.I);
  ZR0:=DefaultZR;
  LenR:=Len01-Len2;
  SetLength(zArr,LenR);

   bakMaxZNCount:=MaxZNCount;
   bakInfZNCount:=InfZNCount;
   MaxZNCount:=Len01;  //= bakMaxZNCount+expShift
// не уверен, что это обязательно, но на всякий случай добавлено 28 февраля 2005 г.
// Хотя, из нижеследующего алгоритма следует, что новое MaxZNCount должно равняться
// bakMaxZNCount + 1. Этого вполне должно хватить для сохранения точности при вычитании

// ----------------------непосредственное деление чисел------------------------

// формируем урезанный числитель ZRdec из числителя ZR01
  ZRdec:=DefaultZR;
  SetLength(ZRdec.I,Len2);
  LenShift:=Len01-Len2;
  for j:=0 to Len2-1 do
  begin
    ZRdec.I[j]:=ZR01.I[j+LenShift];
  end;
  ZR0:=ZRdec;
//  eqv:ShortInt; // результат сравнения урезанного числителя (в том числе, за вычетом знаменателя) и знаменателя
//  k:ShortInt; // разрядная цифра результата деления
  k:=0;
  for i:=0 to LenR-1 do
  begin // в цикле по числу разрядов будущего результата деления
// сравниваем результат разности ZR0 со знаменателем ZR02
    eqv:=ComparisonZR(ZR0, ZR02);
    while eqv>0 do
    begin
// вычисляем разность ZR0 между урезанным числителем ZRdec и знаменателем ZR02
      ZR0:=SubZR(ZR0, ZR02);
      Inc(k); // наращиваем разрядную цифру результата деления
// снова сравниваем результат разности ZR0 со знаменателем ZR02
      eqv:=ComparisonZR(ZR0, ZR02);
    end;

      if eqv=0 then
      begin
        Inc(k);
        zArr[LenR-1-i]:=k;
        k:=0;
        ZRdec:=defaultZR;
        Dec(LenShift);
        ZRdec.I[0]:=ZR01.I[LenShift];
        TrimLeftZR(ZRdec.I);        // удаляем левые нули из числа  (насколько необходимо здесь выполнить это действие, ещё не выяснено)
        ZR0:=ZRdec;
        Continue;  // переходим на следующий шаг цикла for
      end;

      if eqv<0 then
// вычисляем разность ZR0 между урезанным числителем ZRdec и знаменателем ZR02
      begin
        zArr[LenR-1-i]:=k;
        k:=0;
// обновляем ZRdec с захватом очередной цифры числителя ZR01
        ZRdec:=DefaultZR;
        LenZR0:=Length(ZR0.I);
        SetLength(ZRdec.I,LenZR0+1);
        for j:=0 to High(ZR0.I) do ZRdec.I[j+1]:=ZR0.I[j];
        Dec(LenShift);
        ZRdec.I[0]:=ZR01.I[LenShift];
        TrimLeftZR(ZRdec.I);        // удаляем левые нули из числа  (необходимо для ComparisonZR(ZR0, ZR02), здесь это обязательное условие)
        ZR0:=ZRdec;
//        Continue;  // переходим на следующий шаг цикла for
      end;
  end;

// освобождение массивов
  ZRdec := defaultZR;
  ZR0 := defaultZR;
// удаление начальных нулей в числе с результатом, то есть удаление конечных нулей в массиве zArr
          TrimLeftZR(zArr); // удаление начальных нулей в числе
// результат вычисления
  Result.I:=zArr;
  Result.R:=decimal;
  Result.U:=un;
  Result.E:= expRes;
  MaxZNCount :=bakMaxZNCount;
  InfZNCount :=bakInfZNCount;  // восстанавливаем текущую предельную разрядность
  IsZeroZR(Result);
//  укорачивание числа до требуемой длины точности
  if Length(Result.I)>MaxZNCount then Result:=TruncateZR(RoundZN,Result);  //
  IsInfiniteZR(Result);
{
// если не предполагать работу с целыми числами то можно сокращать запись числа на количество правых нулей
  TrimRightZR(Result);
}
end;


// функция 1/X
function OneDivZR(const ZR: ZReal): ZReal;
// используемые операции с "масштабируемыми" действительными числами: деление
begin
Result:=DivZR(OneZR, ZR);
end;

// процент от числа
function PercentZR(const Percent: ZReal; const ZR: ZReal): ZReal;
// используемые операции с "масштабируемыми" действительными числами: деление и произведение
begin
Result:=DivZR(Percent, StrToZR('100'));
Result:=MultZR(Result,ZR);
end;


// Перевод целого числа в действительное масштабируемое
function IntToZR(Const Int:Int64): ZReal;
// Функция всегда выполнима
{
var
  RTS:Boolean;
}
begin
{
// здесь в отключении RealTypeShow нет необходимости
  if RealTypeShow then
  begin
    RTS:=True;
    RealTypeShow:=False;// отключаем печать результата в формате Real (с плавающей запятой после первого знака)
  end;
}
  Result:=StrToZR(IntToStr(Int)); // делаем конвертирование формата
{
  if RTS then
    RealTypeShow:=True;// возвращаем печать результата в формате Real (с плавающей запятой после первого знака)
}
end;


// Перевод действительного масштабируемого числа в целое
function ZRToInt(var ZR:ZReal): Int64;  // Const
// Функция не всегда выполнима
// результат - число в диапазоне [-9223372036854775808; +9223372036854775807]
// используемые операции с "масштабируемыми" действительными числами: сравнение и произведение
//
// в этой функцции следует быть внимательным с округлением/обрезанием числа
// функция написана исключительно для десятичной системы счисления
var
  Eqv:ShortInt;
  BakMaxZNCount:Integer;
  i:Integer;
  IntExp:Int64;
  ZR0:ZReal;
  Str:String;
  RTS:Boolean;

begin
// контрольное условие
   if MaxZNCount=0 then MaxZNCount:=1;
   if InfZNCount<MaxZNCount then InfZNCount:=MaxZNCount;

// неплохо было бы провести анализ оптимальности предложенного ниже алгоритма решения задачи

// Результат - "Плюс Бесконечность"
Eqv:=ComparisonZR(ZR,StrToZR(IntToStr(High(Int64))));
if Eqv>0 then
begin
    Messages('Функция ZRToInt :' + #13+
             'Число больше предельно допустимого значения целого числа'+ #13+
             ZRToStr(ZR));
    Result:=High(Int64);
    Exit;
end;
// Результат - "Минус Бесконечность"
Eqv:=ComparisonZR(ZR,StrToZR(IntToStr(Low(Int64))));
if Eqv<0 then
begin
    Messages('Функция ZRToInt :' + #13+
             'Число меньше предельно допустимого значения целого числа'+ #13+
             ZRToStr(ZR));
    Result:=Low(Int64);
    Exit;
end;

// Результат - Ноль
if (ZR.U='+') then
begin
{
  if RoundZN=0
  then  Eqv:=ComparisonZR(ZR,OneZR)
  else
}
  Eqv:=ComparisonZR(ZR,StrToZR('0,'+IntToStr(RoundZN))); // десятичная система счисления
  if (Eqv<0) then
  begin
    Result:=0;
    Exit;
  end;
end;
// Результат - Ноль
if (ZR.U='-') then
begin
{
  if RoundZN=0
  then  Eqv:=ComparisonZR(ZR,minusOneZR)
  else  Eqv:=ComparisonZR(ZR,StrToZR('-0,5'));
}
  Eqv:=ComparisonZR(ZR,StrToZR('-0,'+IntToStr(RoundZN)));  // десятичная система счисления
  if (Eqv>0) then
  begin
    Result:=0;
    Exit;
  end;
end;

BakMaxZNCount:=MaxZNCount;
if RealTypeShow then
begin
   RTS:=True;
   RealTypeShow:=False;// отключаем печать результата в формате Real (с плавающей запятой после первого знака)
end;

// Укорачивание числа
if Length(ZR.I)>19 then
begin
  MaxZNCount:=19;
  ZR0:=TruncateZR(RoundZN,ZR);
end
else
begin
  ZR0:=ZR;
end;
// контрольная проверка и удаление признака бесконечных чисел
   if (ZR0.U = 'I') then ZR0.U:='+';
   if (ZR0.U = 'i') then ZR0.U:='-';
// действительное масштабированное число уже в формате целого числа
if ZR0.E=0 then
begin
  Result:=StrToInt64(ZRToStr(ZR0));
end
else
begin
// Обрезание числа до нулевой степени
  if ZR0.E<0 then
  begin
    if ZR0.U='+' then
    begin
      Eqv:=ComparisonZR(ZR0,OneZR); // избыточное условие
      if Eqv<=0 then
      begin
//        if RoundZN=0
//        then  Result:=0    // случай округления до нуля мы уже обработали выше
//        else
        Result:=1;
      end
      else
      begin
// непосредственное обрезание масштабированного числа до целого
        MaxZNCount:=Length(ZR0.I)+ZR0.E;
        Str:=ZRToStr(ZR0);  // здесь происходит округление (или обрезание) числа
        Result:=StrToInt64(Str);    // выхода результата за пределы Int64 на данном шаге (при ZR0.E<0) не будет
      end;
    end
    else
    begin
      Eqv:=ComparisonZR(ZR0,minusOneZR); // избыточное условие
      if Eqv>=0 then
      begin
//        if RoundZN=0
//        then  Result:=0    // случай округления до нуля мы уже обработали выше
//        else
        Result:=-1;
      end
      else
      begin
// непосредственное обрезание масштабированного числа до целого
        MaxZNCount:=Length(ZR0.I)+ZR0.E;
        Str:=ZRToStr(ZR0); // здесь происходит обрезание и округление числа
        Result:=StrToInt64(Str);  // выхода результата за пределы Int64 на данном шаге (при ZR0.E<0) не будет
      end;
    end;
  end
  else   // ZR0.E>0
// Удлинение числа до нулевой степени
  begin
        MaxZNCount:=Length(ZR0.I)+ZR0.E;
        IntExp:=1;
        for i:=1 to ZR0.E do // формируем целочисленное число 10 в степени ZR0.E
        begin
          IntExp:=IntExp*10;
        end;
        ZR0:=MultZR(ZR0,StrToZR(IntToStr(IntExp))); // лучше было бы организовать простое удлинение числа до требуемого числа знаков
        ZR0.E:=0;
        Str:=ZRToStr(ZR0);
{$R+}  // включение проверки вычислений в области допустимого диапазона
    try
        Result:=StrToInt64(Str);    // возможен выход результата за пределы Int64
    except
// на самом деле в предложенном алгоритме настоящая проверка излишняя,
// потому что в самом его начале была осуществлена проверка на бесконечное число
// то есть на это шаг мы не должны попасть, если только не будет изменён алгоритм функции
      if ZR0.U='+' then
      begin
        Messages('Функция ZRToInt :' + #13+
                 'Число больше предельно допустимого значения целого числа'+ #13+
                 ZRToStr(ZR0));
        Result:=High(Int64);
      end
      else
      begin
        Messages('Функция ZRToInt :' + #13+
                 'Число меньше предельно допустимого значения целого числа'+ #13+
                 ZRToStr(ZR0));
        Result:=Low(Int64);
      end;
    end;
{$R-}
  end;
end;

if RTS then
   RealTypeShow:=True;// возвращаем печать результата в формате Real (с плавающей запятой после первого знака)

MaxZNCount:=BakMaxZNCount; // мы обязательно должны добраться до этого места алгоритма, иначе возможна потеря разрядности числовых данных
end;


// Перевод действительного числа в действительное масштабируемое
function RealToZR(Const Ext	:Extended	): ZReal;
// Функция всегда выполнима
// Аргумент в интервале MinExtended=3.4e-4932 -:- MaxExtended=1.1e+4932 , либо ноль, либо +INF, или -INF
// пределы определены в модуле Math
var
si  :ShortInt;
begin
// ловим бесконечность
    if MathIsInfinite(Ext) then
    begin
      si:= MathSign(Ext);
      if si<0 then
        Result:=InfiniteZR('i')  // хотя это может быть далеко не так, но мы хотя бы дадим знать программисту, что значение не определено
      else
        Result:=InfiniteZR('I'); // хотя это может быть далеко не так, но мы хотя бы дадим знать программисту, что значение не определено
      Exit;
    end;
// ловим ноль
    if Ext=0 then
    begin
      Result:=DefaultZR;
      Exit;
    end;
// всё остальное
Result:=StrToZR(FloatToStrF(Ext,ffExponent,16	,16));// 16  значащих цифр (предельно допустимое значение длины в компиляторе Delphi7)
// непонятно, почему значность как у Double - Ошибка компилятора?
// две последние цифры до 18 знаком почему-то забиваются числовым мусором
Result:=RefreshZR(Result); // если в числе остались нули
end;


function MinExtendedZR: ZReal; {=  3.4e-4932 - значение взято из модуля Math}
begin
   Result.R:=decimal;
   Result.E:=-4933;
   Result.U:='+';
   SetLength(Result.I, 2);  // создаём одномерный массив
   Result.I[0]:=4;
   Result.I[1]:=3;
end;

function MaxExtendedZR: ZReal; {=  1.1e+4932 - значение взято из модуля Math}
begin
   Result.R:=decimal;
   Result.E:=4931;
   Result.U:='+';
   SetLength(Result.I, 2);  // создаём одномерный массив
   Result.I[0]:=1;
   Result.I[1]:=1;
end;


// Перевод действительного масштабируемого числа в действительное
function ZRToReal(var ZR:ZReal): Extended;  // Const
// Функция не всегда выполнима
// результат - число в интервале 3.4e-4932 -:- 1.1e+4932 , либо ноль
// используемые операции с "масштабируемыми" действительными числами: сравнение
var
  Eqv:ShortInt;
  i:Integer;
  Str:String;
begin
// Результат - "Плюс Бесконечность"
Eqv:=ComparisonZR(ZR,MaxExtendedZR);
if Eqv>0 then
begin
    Messages('Функция ZRToReal :' + #13+
             'Число больше предельно допустимого значения действительного числа'+ #13+
             ZRToStr(ZR));
    Result:=1.1e+4932;
    Exit;
end;
// Результат - "Минус Бесконечность"
Eqv:=ComparisonZR(ZR,InvertUnaryZR(MaxExtendedZR));
if Eqv<0 then
begin
    Messages('Функция ZRToReal :' + #13+
             'Число меньше предельно допустимого значения действительного числа'+ #13+
             ZRToStr(ZR));
    Result:=-1.1e+4932;
    Exit;
end;

// Результат - Ноль
if (ZR.U='+') then
begin
  Eqv:=ComparisonZR(ZR,MinExtendedZR);
  if (Eqv<0) then
  begin
    Result:=0;
    Exit;
  end;
end;
// Результат - Ноль
if (ZR.U='-') then
begin
  Eqv:=ComparisonZR(ZR,InvertUnaryZR(MinExtendedZR));
  if (Eqv>0) then
  begin
    Result:=0;
    Exit;
  end;
end;
// результат - обычное действительное число
  Str:=ZRToSTR(ZR);
  i:=Pos('Z',Str);
  if i>0 then
  begin    // заменяем обозначение экспоненциальной части действительного числа
    Delete(Str,i,1);
    Insert('e',Str,i);
  end;
Result:=StrToFloat(Str); // всё проще, чем с целыми числами

end;


// порядковый номер минимального числа из одномерного динамического массива масштабируемых действительных чисел
function MinfromArrZR(const Arr: array of ZReal): Integer;
// функция определяет первый минимум из массива
// используемые операции с "масштабируемыми" действительными числами: сравнение
var
  i,N,K:Integer;
  eqv:ShortInt;
begin
  N:=Length(Arr);
  if N=0 then Result:=-1
  else
    if N=1 then Result:=0
    else
    begin
      K:=0;
      for i:=1 to N-1 do
      begin
        eqv:=ComparisonZR(Arr[K], Arr[i]);
        if eqv>0 then
        begin
          K:=i;
        end;
      end;
      Result:=K;
    end;
end;


// порядковый номер максимального числа из одномерного динамического массива  масштабируемых действительных чисел
function MaxfromArrZR(const Arr: array of ZReal): Integer;
// функция определяет первый максимум из массива
// используемые операции с "масштабируемыми" действительными числами: сравнение
var
  i,N,K:Integer;
  eqv:ShortInt;
begin
  N:=Length(Arr);
  if N=0 then Result:=-1
  else
    if N=1 then Result:=0
    else
    begin
      K:=0;
      for i:=1 to N-1 do
      begin
        eqv:=ComparisonZR(Arr[K], Arr[i]);
        if eqv<0 then
        begin
          K:=i;
        end;
      end;
      Result:=K;
    end;
end;


// порядковые номера минимального и максимального числа из одномерного
// динамического массива  "масштабируемых" действительных чисел
// с описанием типа массива в качестве результата функции
function MinMaxfromArrZR(const Arr: array of ZReal; out IndMin, IndMax: Integer): ShortInt;
// Copyright © 2005 Nikolai Victorovich Botcharov
// функция определяет индексы первого минимума и первого максимума из массива,
// а в качестве результата выдаёт тип массива:
{
-3 - пустой числовой массив
-2 - числовой массив из одного элемента
-1 - убывающий числовой массив
 0 - массив одинаковых элементов
 1 - возрастающий числовой массив
 2 - нелинейный числовой массив
}
// самый короткий проход по возрастающему числовому массиву__!!!!!!!!!!!!!!!!!!!
// самый длинный проход по убывающему числовому массиву
// используемые операции с "масштабируемыми" действительными числами: сравнение
var
  i,N,KMin,KMax:Integer;
  eqv, eqv1:ShortInt;
begin
  N:=Length(Arr);
  if N=0 then begin Result:=-3; IndMin:=-1; IndMax:=-1; end
  else
    if N=1 then begin Result:=-2; IndMin:=0; IndMax:=0; end
    else
    begin
// начальная индексация миниму и максимума
      eqv:=ComparisonZR(Arr[0], Arr[1]);
      if eqv<0 then
      begin
        KMin:=0;
        KMax:=1;
        Result:=1;
      end
      else
      begin
        if eqv>0 then
        begin
          KMax:=0;
          KMin:=1;
          Result:=-1;
        end
        else   // eqv=0
        begin
          KMin:=0;
          KMax:=0;
          Result:=0;
        end;
      end;
// дальнейший проход по длинному массиву
      if N>2 then
      begin
        for i:=2 to N-1 do
        begin
          eqv:=ComparisonZR(Arr[KMax], Arr[i]);
          if eqv<0 then
          begin
            KMax:=i;
            if Result<>1 then Result:=2;
          end
          else
          begin
            if eqv>0 then
            begin
              eqv1:=ComparisonZR(Arr[KMin], Arr[i]);
              if eqv1>0 then
              begin
                KMin:=i;
                if Result<>-1 then Result:=2;
              end
              else Result:=2;
            end
            else  // eqv=0
            begin
              if Result<>0 then Result:=2;
            end;
          end;
        end; // for
      end; // N>2
//
      IndMin:=KMin;
      IndMax:=KMax;
    end; // N>1
end;


// порядковые номера максимального и минимального числа из одномерного
// динамического массива  масштабируемых действительных чисел
// с описанием типа массива в качестве результата функции
function MaxMinfromArrZR(const Arr: array of ZReal; out IndMax, IndMin: Integer): ShortInt;
// Copyright © 2005 Nikolai Victorovich Botcharov
// функция определяет индексы первого минимума и первого максимума из массива,
// а в качестве результата выдаёт тип массива:
{
-3 - пустой числовой массив
-2 - числовой массив из одного элемента
-1 - убывающий числовой массив
 0 - массив одинаковых элементов
 1 - возрастающий числовой массив
 2 - нелинейный числовой массив
}
// самый короткий проход по убывающему числовому массиву_____!!!!!!!!!!!!!!!!!!!
// самый длинный проход по возрастающему числовому массиву
// используемые операции с "масштабируемыми" действительными числами: сравнение
var
  i,N,KMin,KMax:Integer;
  eqv, eqv1:ShortInt;
begin
  N:=Length(Arr);
  if N=0 then begin Result:=-3; IndMin:=-1; IndMax:=-1; end
  else
    if N=1 then begin Result:=-2; IndMin:=0; IndMax:=0; end
    else
    begin
// начальная индексация миниму и максимума
      eqv:=ComparisonZR(Arr[0], Arr[1]);
      if eqv<0 then
      begin
        KMin:=0;
        KMax:=1;
        Result:=1;
      end
      else
      begin
        if eqv>0 then
        begin
          KMax:=0;
          KMin:=1;
          Result:=-1;
        end
        else   // eqv=0
        begin
          KMin:=0;
          KMax:=0;
          Result:=0;
        end;
      end;
// дальнейший проход по длинному массиву
      if N>2 then
      begin
        for i:=2 to N-1 do
        begin
          eqv:=ComparisonZR(Arr[KMin], Arr[i]);
          if eqv>0 then
          begin
            KMin:=i;
            if Result<>-1 then Result:=2;
          end
          else
          begin
            if eqv<0 then
            begin
              eqv1:=ComparisonZR(Arr[KMax], Arr[i]);
              if eqv1<0 then
              begin
                KMax:=i;
                if Result<>1 then Result:=2;
              end
              else Result:=2;
            end
            else  // eqv=0
            begin
              if Result<>0 then Result:=2;
            end;
          end;
        end; // for
      end; // N>2
//
      IndMin:=KMin;
      IndMax:=KMax;
    end; // N>1
end;


// Константа PI
function Pi_ZR: ZReal;
var
  BakMaxZNCount:Cardinal;
  BakMaxZNCountOpt:Cardinal;
  metod:Byte;
  i:Integer;
  N:Integer;
  ZR0,ZR1,ZR2,ZR3:ZReal;
  R0,R1,R2,R3:Single; // Double
  ZR1103, ZR26390, ZR396, ZRn:ZReal;
  strPi:AnsiString;
  gess,diff:Int64;
  bool:Boolean;
begin

  metod:=0; //--------! ! ! ! ! ! !-------- Выберите метод определения числа Пи
// 0 - строковая переменная константы Пи (1010 знаков)
// 1 - [ZReal] Метод вычисления числа Пи, основанный на вычислении ряда Грегори-Лейбница
// 2 - [Single(Double)] Контроль ряда Грегори-Лейбница  вычисления числа Пи
// 3 - [ZReal] Метод вычисления числа Пи по формуле Гаусса
// 4 - [Single(Double)] Контроль формулы Гаусса вычисления числа Пи
// 5 - [ZReal] Метод вычисления числа Пи по формуле Хьютона (контрольный вариант)
// 6 - [ZReal] Метод вычисления числа Пи по формуле РАМАНУДЖАН из статьи "Рамануджан и число p" ДЖОНАТАН М. БОРВЕЙН, ПИТЕР Б. БОРВЕЙН (рекомендуемый)
// 7 - [ZReal] Метод вычисления числа Пи по формуле ДЖ.БОРВЕЙН и П.БОРВЕЙН  из статьи "Рамануджан и число p" ДЖОНАТАН М. БОРВЕЙН, ПИТЕР Б. БОРВЕЙН (ещё не сделано)

    case metod of
0:begin
// const Pi
//    Result := StrToZR('3141592653589793Z-15'); // Double
    strPi:=
'31415926535897932384626433832795028841971693993751058209749445923078164062862'+
'08998628034825342117067982148086513282306647093844609550582231725359408128481'+
'11745028410270193852110555964462294895493038196442881097566593344612847564823'+
'37867831652712019091456485669234603486104543266482133936072602491412737245870'+
'06606315588174881520920962829254091715364367892590360011330530548820466521384'+
'14695194151160943305727036575959195309218611738193261179310511854807446237996'+
'27495673518857527248912279381830119491298336733624406566430860213949463952247'+
'37190702179860943702770539217176293176752384674818467669405132000568127145263'+
'56082778577134275778960917363717872146844090122495343014654958537105079227968'+
'92589235420199561121290219608640344181598136297747713099605187072113499999983'+
'72978049951059731732816096318595024459455346908302642522308253344685035261931'+
'18817101000313783875288658753320838142061717766914730359825349042875546873115'+
'95628638823537875937519577818577805321712268066130019278766111959092164201989380952572Z-1009';

    Result := StrToZR(strPi);// ZReal
// 31415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572Z-1009

  end;

1:begin
// ---------------------ZReal
// Метод, основанный на вычислении ряда Грегори-Лейбница
// pi/4 = 1 -  1/3 + 1/5 - 1/7 + 1/9 - ...
//----------------------------------------
//    pi    |    N    |     t
//--------------------------------
//    3.141592653589793
// N:   1000
// Pi: 3142591654339543050901127737252204566153538256316955873675303860503427171619557703217696070138604748Z-99
// Pi: 31425916543395430509011277372526Z-31
// Pi: 31425916Z-7
// Pi: 3142591654339544Z-15 - Double
// Pi: 31425917Z-7          - Single
// t(AMD2200) =   1.00 sec  /   0.34 sec  /   0.11 sec  / 0 sec  / 0 sec
// N:  10000
// Pi: 3141692643590543213460768320877940222544825752138710733999805489190209879979564374094471751246362546Z-99
// Pi: 31416926435905432134607683208799Z-31
// Pi: 31416942Z-7
// Pi: 3141692643590534Z-15 - Double
// Pi: 31416984Z-7          - Single
// t(AMD2200) =  10.56 sec  /   3.6 sec  /   1.12 sec  / 0 msec  / 0 msec
// N: 100000
// Pi: 3141602653489793988460143364529440394040917831472762036846331303482711437961073654096918976224047126Z-99
// Pi: 31416026534897939884601433645319Z-31
// Pi: 31416042Z-7
// Pi: 314160265348972Z-14  - Double
// Pi: 31416056Z-7          - Single
// t(AMD2200) = 107.59 sec  /  36.60 sec  /  11.46 sec  / 0 msec  / 0 msec
//--------------------------------
  N:=1000;
  ZR1:=OneZR; // =1
  ZR2:=SumZR(OneZR,OneZR); // =2
  ZR0:=ZR1;  // =1
  for i:=1 to N do
  begin
    ZR1:=InvertUnaryZR(ZR1);
// ZR0 = ZR0 + ( ZR1 / ((2*i) + 1) )
    ZR0:=SumZR( ZR0, DivZR(ZR1, SumZR(OneZR, MultZR(ZR2, IntToZR(i)) ) ) );
{
    ZR3:=MultZR(ZR2, IntToZR(i));
    ZR3:=SumZR(OneZR, ZR3);
    ZR3:=DivZR(ZR1, ZR3);
    ZR0:=SumZR(ZR0, ZR3);
}
  end;
//
  ZR2:=SumZR(ZR2,ZR2); // =4
  Result:=MultZR(ZR0,ZR2); // = 4 * ZR0
  end;

2:begin
// ---------------------Single (Double)
// Метод, основанный на вычислении ряда Грегори-Лейбница
// pi/4 = 1 -  1/3 + 1/5 - 1/7 + 1/9 - ...
  N:=100000;
  R1:=1; // =1
  R2:=2; // =2
  R0:=R1;  // =1
  for i:=1 to N do
  begin
    R1:=R1*(-1);
// ZR0 = ZR0 + ( ZR1 / ((2*i) + 1) )
    R0:=R0 + ( R1 / ((2*i) + 1) );
  end;
//
  Result:=RealToZR(R0*4); // = 4 * R0
  Exit;
  end;

3:begin
// ---------------------ZReal
// контрольное условие
   if MaxZNCount=0 then MaxZNCount:=1;
   if InfZNCount<MaxZNCount then InfZNCount:=MaxZNCount;
//
{
/*
** Pascal Sebah : September 1999
**
** Subject:
**
**    A very easy program to compute Pi with many digits.
**    No optimisations, no tricks, just a basic program to learn how
**    to compute in multiprecision.
**
** Formulae:
**
**    Pi/4 =    arctan(1/2)+arctan(1/3)                     (Hutton 1)
**    Pi/4 =  2*arctan(1/3)+arctan(1/7)                     (Hutton 2)
**    Pi/4 =  4*arctan(1/5)-arctan(1/239)                   (Machin)
**    Pi/4 = 12*arctan(1/18)+8*arctan(1/57)-5*arctan(1/239) (Gauss)
**
**      with arctan(x) =  x - x^3/3 + x^5/5 - ...      Double(16 знаков) требует 6 членов ряда arctan(x)
**                                                     40 знаков точности требует 26 членов ряда arctan(x)
**
**    The Lehmer's measure is the sum of the inverse of the decimal
**    logarithm of the pk in the arctan(1/pk). The more the measure
**    is small, the more the formula is efficient.
**    For example, with Machin's formula:
**
**      E = 1/log10(5)+1/log10(239) = 1.852
**
** Data:
**
**    A big real (or multiprecision real) is defined in base B as:
**      X = x(0) + x(1)/B^1 + ... + x(n-1)/B^(n-1)
**      where 0<=x(i)<B
**
** Results: (PentiumII, 450Mhz)
**
**   Formula      :    Hutton 1  Hutton 2   Machin   Gauss
**   Lehmer's measure:   5.418     3.280      1.852    1.786
**
**  1000   decimals:     0.2s      0.1s       0.06s    0.06s
**  10000  decimals:    19.0s     11.4s       6.7s     6.4s
**  100000 decimals:  1891.0s   1144.0s     785.0s   622.0s
//
// Delphi 7.0, Win2000, Amd2200+, Ram: 512 Мб :  1000 decimals - Gauss - 69 sec
//
**
** With a little work it's possible to reduce those computation
** times by a factor 3 and more:
**
**     => Work with double instead of long and the base B can
**        be choosen as 10^8
**     => During the iterations the numbers you add are smaller
**        and smaller, take this in account in the +, *, /
**     => In the division of y=x/d, you may precompute 1/d and
**        avoid multiplications in the loop (only with doubles)
**     => MaxDiv may be increased to more than 3000 with doubles
**     => ...
*/
}
//     Pi/4 = 12*arctan(1/18)+8*arctan(1/57)-5*arctan(1/239) (Гаусс),
// где arctan(x) = x - x^3/3 + x^5/5 - ... вычисляется в отдельной функции ArctanZR
// Чем ближе аргумент к модулю единицы, тем больше членов ряда необходимо учитывать

// С учётом особенности точности функции приближённого вычисления арктангенса
// мы локально изменяем длину мантиссы масштабируемого действительного числа
    BakMaxZNCount:=MaxZNCount;
    MaxZNCount:=MaxZNCount+3;

//arctan(1/18)
    ZR0:=ArctanZR(DivZR(OneZR,IntToZR(18)));        // не забудьте в функции арктангенса переключить метод его вычисления
//12*arctan(1/18)
    ZR1 :=MultZR(ZR0,IntToZR(12));
//arctan(1/57)
    ZR0:=ArctanZR(DivZR(OneZR,IntToZR(57)));        // не забудьте в функции арктангенса переключить метод его вычисления
//12*arctan(1/18)+8*arctan(1/57)
    ZR1 :=SumZR(ZR1,MultZR(ZR0,IntToZR(8)));
//arctan(1/239)
    ZR0:=ArctanZR(DivZR(OneZR,IntToZR(239)));       // не забудьте в функции арктангенса переключить метод его вычисления
//12*arctan(1/18)+8*arctan(1/57)-5*arctan(1/239)
    ZR1 :=SubZR(ZR1,MultZR(ZR0,IntToZR(5)));
    ZR1 := MultZR(ZR1,IntToZR(4));

    MaxZNCount:=BakMaxZNCount;
    Result:=TruncateZR(RoundZN,ZR1); // теперь получили чистое число с округлением
  end;

4:begin
// ---------------------Double (Контроль формулы Гаусса вычисления числа Пи)
//     Pi/4 = 12*arctan(1/18)+8*arctan(1/57)-5*arctan(1/239) (Гаусс)
   Result:=RealToZR((12*arctan(1/18)+8*arctan(1/57)-5*arctan(1/239))*4);
  end;

5:begin
// ---------------------ZReal
// контрольное условие
   if MaxZNCount=0 then MaxZNCount:=1;
   if InfZNCount<MaxZNCount then InfZNCount:=MaxZNCount;

//    Pi/4 =    arctan(1/2)+arctan(1/3)             (Хьютон - Первая формула)
// где arctan(x) = x - x^3/3 + x^5/5 - ... вычисляется в отдельной функции ArctanZR

// С учётом особенности точности функции приближённого вычисления арктангенса
// мы локально изменяем длину мантиссы масштабируемого действительного числа
  BakMaxZNCount:=MaxZNCount;
  MaxZNCount:=MaxZNCount+3;

//arctan(1/2)+arctan(1/3)
  ZR1 :=SumZR(ArctanZR(DivZR(OneZR,TwoZR)),ArctanZR(DivZR(OneZR,IntToZR(3))));
  ZR1 := MultZR(ZR1,IntToZR(4));

  MaxZNCount:=BakMaxZNCount;
  Result:=TruncateZR(RoundZN,ZR1); // теперь получили чистое число с округлением
// Резюме:
// Формула Хьютона - чрезмерно медленная операция, если использовать функцию
// вычисления arctan без оптимизации. А оптимизацию мы не можем применить,
// потому что она основана на знании числа Пи.
  end;

6:begin // - [ZReal] Метод вычисления числа Пи по формуле РАМАНУДЖАНА из статьи "Рамануджан и число p" ДЖОНАТАН М. БОРВЕЙН, ПИТЕР Б. БОРВЕЙН
// 1/Pi =  2*sqrt(2)/9801 * ( {[(4*0)! * (1103 + 26390*0)]/[(0!)^4 * 396^(4*0)]} + ... )

    if MaxZNCount=0 then MaxZNCount:=1;
    if InfZNCount<MaxZNCount then InfZNCount:=MaxZNCount;

    BakMaxZNCount:=MaxZNCount;
    MaxZNCount:=MaxZNCount+3;
    ZR0:=DivZR(MultZR(SqrtZR(TwoZR),TwoZR),StrToZR('9801'));
// чтобы не зависеть от константы Sqrt2_ZR мы её будем вычислять каждый раз заново


    ZR1103:=StrToZR('1103');
    ZR26390:=StrToZR('26390');
    ZR396:=StrToZR('396');

    Result:=ZR1103; // первый член разложения
    gess:=HighDeciZR(Result,bool).E - MaxZNCount + 2; // требуемая точность вычислений
// строим второй член разложения
    ZR1:=IntPowZR(ZR396,4);
    ZR2:=ZR26390;
    ZRn:=DivZR(MultZR(FactorZR(4),SumZR(ZR1103,ZR2)),ZR1);
    i:=1;
    Result:=SumZR(Result,ZRn);
// два члена ряда дают 16 верных знаков
// строим остальные члены разложения
    diff:=HighDeciZR(ZRn,bool).E;
    BakMaxZNCountOpt:=MaxZNCount;
    while diff>gess do
    begin
      inc(i);
// непосредственная реализация формулы РАМАНУДЖАНА без оптимизации алгоритма её вычисления
      ZR1:=MultZR(IntPowZR(ZR396,4*i),IntPowZR(FactorZR(i),4));
      ZR2:=SumZR(ZR2,ZR26390);
      MaxZNCount:=Abs(diff-gess)+2;  // для сокращения времени вычисления суммы разложения
      ZRn:=DivZR(MultZR(FactorZR(4*i),SumZR(ZR1103,ZR2)),ZR1);
      diff:=HighDeciZR(ZRn,bool).E;
      MaxZNCount:=BakMaxZNCountOpt;
      Result:=SumZR(Result,ZRn);
    end;
    Result:=OneDivZR(MultZR(Result,ZR0));
    MaxZNCount:=BakMaxZNCount;
    Result:=TruncateZR(RoundZN,Result); // теперь получили чистое число с округлением
{
1010 верных знаков дают 127 членов разложения, которые вычисляются 13,5 сек.
}
  end;

7:begin // - [ZReal] Метод вычисления числа Пи по формуле ДЖ.БОРВЕЙН и П.БОРВЕЙН  из статьи "Рамануджан и число p" ДЖОНАТАН М. БОРВЕЙН, ПИТЕР Б. БОРВЕЙН
// реализация в планах
{
1/Pi =  12 * SUM (–1)^n * (6n)! * [212 175 710 912 * sqrt(61) + 1 657 145 277 365 + n*(13 773 980 892 672 * sqrt(61) + 107 578 229 802 750)] / [(n!)^3 * (3n)! * [5 280 * (236 674 + 30 303 * sqrt(61))]^(3n + 3/2)]
}
    Result:=StrToZR('3,1415926535897932384626433832795028841971693993751058209749445923078164062862');
  end;

    end; // case
end;


// Возведение числа в целочисленную степень
function IntPowZR(const ZR: ZReal; Power:Int64): ZReal;
// Здесь использовано ограничение для Power: |Power| < High(Int64) div 100 (максимальное значение степени, на которое можно возвести число e)
{
--------
Фигурирующий во многих источниках алгоритм быстрого возведения числа в степень:  x^y
--------
a=1
s=x - Пусть будет число 2
y=степень
пока y<>0: 1) если y неч.a=a*s; 2) y=y/2; 3) если y<>0 то s=s*s
Результат: a
---------------------
блок-схема вычисления
---------------------
a | 1    2    8   8    2048   134217728   134217728             134217728                              134217728                              1,5541351137805832567355695254582e+85
y | 283  141  70  35   17     8           4                     2                                      1                                      0
s | 2    4    16  256  65536  4294967296  18446744073709551616  3,4028236692093846346337460743177e+38  1,1579208923731619542357098500864e+77  Ответ - 1,5541351137805832567355695254588e+85
---------------------
Блок-схема возведения числа в степень, равную одному миллиону (10^6), будет иметь 20 шагов
----------
Дополнительные знаковые правила
----------
 11^ 10001   - алгоритм и решение не меняются
 9,2948902763203827530096394762282e+10414
  92948902763203827530096394762282Z+10383

----------
-11^ 10001   - алгорит не меняется, а в решении меняется знак, если степень нечётная
-9,2948902763203827530096394762282e+10414
 -92948902763203827530096394762282Z+10383

----------
-11^-10001   - к алгоритму добавляется один последний шаг - Реш.=1/Реш., и в решении меняется знак, если степень нечётная
-1,0758599297805538757759671198937e-10415
 -10758599297805538757759671198937Z-10446

_______________________________________________________________________________
_______________________________________________________________________________
}
var
  metod:Byte;
  BakMaxZNCount:Integer;
  ZR0: ZReal;
  yPower: Int64;
  aPower: ZReal;
  sPower: ZReal;
begin
// особые случаи
    case Power of
-2:begin
     Result:=OneDivZR(SQRZR(ZR)); Exit;
   end;
-1:begin
     Result:=OneDivZR(ZR); Exit;
   end;
0:begin
    Result:=OneZR;  Exit;
  end;
1:begin
    Result:=ZR; Exit;
  end;
2:begin
    Result:=SQRZR(ZR); Exit;
  end;
    end;  // case Power

    if Abs(Power) > 92233720368547758 then     //(High(Int64) div 100)
    begin
      if Power>0 then
      Messages('Функция IntPowZR:'#13'Недопустимое значение аргумента.'+
               #13'Power =    '+IntToStr(Power)+' ,'+
                  'что больше 92233720368547758.')
      else
      Messages('Функция IntPowZR:'#13'Недопустимое значение аргумента.'+
               #13'Power =    '+IntToStr(Power)+' ,'+
                  'что меньше -92233720368547758.');
      Exit;
    end;

   metod:=1; //---! ! !--- Выберите метод приближённого вычисления функции возведения в целочисленную степень
// 0 - алгоритм последовательного перемножения (контроль следующего алгоритма)
// 1 - быстрое возведение в степень

// контрольное условие перед повышением точности вычисления
  if MaxZNCount=0 then MaxZNCount:=1;
  if InfZNCount<MaxZNCount then InfZNCount:=MaxZNCount;

  BakMaxZNCount:=MaxZNCount;
  MaxZNCount:=MaxZNCount+Length(IntToStr(Abs(Power)))+1; // повышение точности вычисления

// глобальные переменные
    ZR0:=AbsZR(ZR);      // модуль аргумента
    yPower:=Abs(Power);  // модуль показателя степени
    aPower:=OneZR;       // начальное решение функции возведения мультиразрядного действительного числа в натуральную степень
    sPower:=ZR0;
//
    case metod of

0:begin    // последовательное перемножение
    while yPower<>0 do
    begin
      aPower := MultZR(aPower,ZR0);
      Dec(yPower);
    end;
  end;

1:begin    // быстрое возведение в степень
    while yPower<>0 do
    begin
      if (yPower and 1)=1 then        // yPower - нечётно
      begin
        aPower:= MultZR(aPower,sPower);
        Dec(yPower);
      end
      else
      begin
        sPower:= SQRZR(sPower);
        yPower:= yPower div 2;
      end;
    end;
  end;
    end;  // case  metod

// определяем решение
    Result:=aPower;
    if (Power and 1)=1 then   // Power - нечётно
      if (ZR.U='-') or (ZR.U='i') then Result:=InvertUnaryZR(Result); // меняем знак решения

    if Power<0 then Result:=OneDivZR(Result); // обращаем решение

  MaxZNCount:=BakMaxZNCount;

end;


// Арктангенс
function ArctanZR(const ZR: ZReal ): ZReal;
// Copyright © 2005 Nikolai Victorovich Botcharov
var
  metod:Byte;
  BakMaxZNCount:Integer;
  i,j:Integer;
  N:Integer; // кол-во членов ряда
  ZR0,ZR1,ZR2,ZR3:ZReal;
  R0,R1,R2,R3,r4,r5:Double; //
  bool:Boolean;
  Re0,Re1,Re2,Re3,re4,re5:Extended;
  SignR0 , Lx , f1  :Double;
  SignR0a, SignR0b, SignR0c, SignR0d, SignR0e, SignR0f :ShortInt;
  x :Double;
  iExp:Integer;
  InvertR0:Boolean;
  re:Extended;
  eqv:ShortInt;
  sp:Integer;
  a:Double;
  sqrt3 , piDiv24 , piDiv12 , piDiv6 , piDiv2:Double;
  indRate: Array of Byte;  // массив индексов для оптимизации по области определения функции
begin
// контрольное условие
  if MaxZNCount=0 then MaxZNCount:=1;
  if InfZNCount<MaxZNCount then InfZNCount:=MaxZNCount;

   metod:=6; //---! ! !--- Выберите метод приближённого вычисления Арктангенса
// 0 - ищем ArcTan(X)=Pi/4  [Double]  (для вычисления числа Пи)
// 1 - ищем ArcTan(X)=Pi/4  [ZReal]  с оптимизацией   (для вычисления числа Пи ) при условии, что X<=1/18
// 2 - ищем ArcTan(X)  [ZReal]    без оптимизации с целью исследования сходимости разложений функции в ряды при разных значениях аргумента
// 3,4 - ищем ArcTan(X) [Double],[ZReal] геометрический вариант вычисления АркТангенса по приближённым формулам из математического справочника (точность только 2 знака)
// 5,6 - ищем ArcTan(X) [Double],[ZReal] оптимальный вариант вычисления АркТангенса на интервале [-Pi/2;Pi/2] (с оптимизацией)
    case metod of

0:begin
// ---------------------Double
    if MaxZNCount>4 then  N:=Trunc(MaxZNCount*0.4) else N:=2;
  ZR0:=ZR;
  R3:=ZRToReal(ZR0);
// запись, подобная двум вышеприведённым строчкам чревата порчей данных в ZR
  R0:=Sqr(R3);
  R1:=R3;
  for i:=2 to N do
  begin
    R1:=R0*R1*(-1);
    R2:=R1/(i*2-1);
    R3:=R3+R2;
  end;
  Result:=RealToZR(R3)
  end;

1:begin
// ---------------------ZReal
// кол-во членов ряда arctan(x) для обеспечения гарантированной точности
// определяется, как: Trunc(MaxZNCount*0.4) при x=1/18
{
  N  - MaxZNCount
  6  -   16
 16  -   40
 67  -  168
398  - 1000
Отсюда видно, что весь вопрос в оптимизации алгоритма вычисления ряда
Например в уменьшении значности при вычислении очередного члена ряда
но с возвратом значности перед суммирование членов ряда
// провести исследование выигрыша от оптимизации
//
Arctan(1/18)
Мультиразрядное число:             55498505245716835557198148092237210439803345059388029139558910877592343218312624788505966403041525995105435199630261739218304681Z-129
системный калькулятор Windows:  0,055498505245716835557198148092237
Вычимсление в формате Double:   0,0554985052457168

Обнаружено, что на длинных числах значение получается завышенным по сравнению с
ещё более длинным числом, и это несоответствие касается последних двух знаков
длинного числа.
}
// контрольное условие
    if MaxZNCount>4 then  N:=Trunc(MaxZNCount*0.4) else N:=2;  // ориентировочное определение числа членов ряда

  BakMaxZNCount:=MaxZNCount;
  Result:=ZR;
  ZR0:=SqrZR(ZR);
  ZR1:=ZR;
  for i:=2 to N do
  begin
    MaxZNCount:=BakMaxZNCount-i*2+2; // эта оптимизация даёт экономию времени с коэффициентом 0,4 от времени расчёта при постоянном числе знаков и при том же числе членов разложения
    ZR1:=MultZR(ZR0,InvertUnaryZR(ZR1));
    ZR2:=DivZR(ZR1,IntToZR(i*2-1));
    MaxZNCount:=BakMaxZNCount;
    Result:=SumZR(Result,ZR2);
  end;
//  MaxZNCount:=BakMaxZNCount;
  end;

2:begin
// ---------------------ZReal
// где arctan(x) =  x - x^3/3 + x^5/5 -   (при |x| < 1)
// где arctan(x) =  (+/-)pi/4   (при |x| = 1)
// где arctan(x) =  (+/-)pi/2 - 1/x + 1/(3*x^3) - 1/(5*x^5) +   (при |x| > 1)
// Замечание: В районе |x| = 1 +/- Epsilon требуются особые правила вычисления
// функции, иначе получается, что может потребоваться вычисление бесконечного
// ряда для достижения высокой значности результата.

  N:=MaxZNCount; //+Round(MaxZNCount*0.3) число членов бесконечного ряда для вычисления arctan(x)

  eqv:=ComparisonZR(AbsZR(ZR),OneZR);

if eqv<0 then         // |x| < 1
begin
// arctan(x) =  x - x^3/3 + x^5/5 -   (при |x| < 1)
  BakMaxZNCount:=MaxZNCount;
  Result:=ZR;
  ZR0:=SqrZR(ZR);
  ZR1:=ZR;
  for i:=2 to N do
  begin
    ZR1:=MultZR(ZR0,InvertUnaryZR(ZR1));
    ZR2:=DivZR(ZR1,IntToZR(i*2-1));
    Result:=SumZR(Result,ZR2);
  end;
{
вычисления без оптимизации
x=0.9  ;  Result: ... - 145 членов ряда - 16 знаков точного значения
x=0.9  ;  Result: ... - 245 членов ряда - 24 знака  точного значения
результаты сравнивались с 32-значным числом из калькулятора Windows
------------------------------------------------
x=Pi/8=0.39  ;  Result:  0,37419668052268493829329707618118  (вычислено в калькуляторе Windows)

вычисление 1000 знаков тригонометрической функции ArcTan

arctan(0.3926990816987242)  Pi/8_Double=0.3926990816987242
3741966805226849774474102785406519775331930480939437301396251137687228399241398068200784152099650212012924257513793513260237870735452760847253198567191915587819872062588841012861935425998593175629676195191802867763414994351572978056965109425216859824554396806314042483230444437654658803088355071872813862128026835979392904784357683147939735085080090604601777435901581166069063596607657108688789688415265250431123704212030076046016137186584898059929533879701813511058916880950589271105707993434689366268209797477993809572264145200885165701639922930513134622192352451473175982695216453892690410289124040855767282382289863167468695851768774511391304600705926501542236002321804163996724106670287793295034655325343688840007475416216809335511064482870707691180481749359546453036145468952145755176626594128208943805726211960405872628585024632144037113356639207361406344711001468350418169333446932166194941545401836658590333408582245943475486975449376162084578247088752017765175995671076537897483153593336221Z-1000

arctan(PiDiv8_ZR)= (без оптимизации - MaxZNCount не меняется )
3741966805226849382932970761811837877286225864074507618239060205542759124516630976435518832332087392893066862969212750295160765349583181687491964677139523651394574462411900137608219116857195335176338272260459742800279276704883540436335472128454979617158054023715101789920668638337781076648205572827469280962385843506353048050265352525663100142739253878295460958126504772314319301253952796178205600818234638458811365404946187368161346847090386166276974791615722129904070574282085058576057633908032584468757786449786159567983148439697693507869320722063929873179466457760853836018361089914562450768077599829054655269273946646309851958681600359850122782964839949998418032169390425722865486340196179379175914162292678145108760290403849639418072610749001823259747675209241694037355493088237584518498650553830409663190727810102924233777219970641979185241384858687061383104119304371414281493483475549640881246045899615866650778749351283946130742589207189012238339756751339178293127769208632597791358042685538Z-1000

arctan(PiDiv8_ZR)= (с оптимизацией - MaxZNCount:=BakMaxZNCount-i) расхождение с предыдущим числом  начинается с 815 знака
3741966805226849382932970761811837877286225864074507618239060205542759124516630976435518832332087392893066862969212750295160765349583181687491964677139523651394574462411900137608219116857195335176338272260459742800279276704883540436335472128454979617158054023715101789920668638337781076648205572827469280962385843506353048050265352525663100142739253878295460958126504772314319301253952796178205600818234638458811365404946187368161346847090386166276974791615722129904070574282085058576057633908032584468757786449786159567983148439697693507869320722063929873179466457760853836018361089914562450768077599829054655269273946646309851958681600359850122782964839949998418032169390425722865486340196179379175914162292678145108760290403849639418072610749001823259747675209241694037355493088237584518498650553830409663190727796878070520396338519948533396351991195649183745721502287757260070445880425287124684534675121841280843516391670659154090227374148368646173842002519398823866224165746751648219560508979099Z-1000

arctan(PiDiv8_ZR)= (контрольное вычисление - MaxZNCount:=MaxZNCount+100) расхождение с числом, полученным без оптимизации, начинается с 816 знака.
3741966805226849382932970761811837877286225864074507618239060205542759124516630976435518832332087392893066862969212750295160765349583181687491964677139523651394574462411900137608219116857195335176338272260459742800279276704883540436335472128454979617158054023715101789920668638337781076648205572827469280962385843506353048050265352525663100142739253878295460958126504772314319301253952796178205600818234638458811365404946187368161346847090386166276974791615722129904070574282085058576057633908032584468757786449786159567983148439697693507869320722063929873179466457760853836018361089914562450768077599829054655269273946646309851958681600359850122782964839949998418032169390425722865486340196179379175914162292678145108760290403849639418072610749001823259747675209241694037355493088237584518498650553830409663190727832508512570080248909813571462397433423127272396677649647812407280145216102712853343162756607976334279077530604208164717855804261784806563020469517643996810407748398565999067410906638962Z-1000

arctan(PiDiv8_ZR)[125 sec]= (контрольное вычисление - MaxZNCount:=MaxZNCount+300) расхождение с предыдущим числом  начинается с 897 знака.
3741966805226849382932970761811837877286225864074507618239060205542759124516630976435518832332087392893066862969212750295160765349583181687491964677139523651394574462411900137608219116857195335176338272260459742800279276704883540436335472128454979617158054023715101789920668638337781076648205572827469280962385843506353048050265352525663100142739253878295460958126504772314319301253952796178205600818234638458811365404946187368161346847090386166276974791615722129904070574282085058576057633908032584468757786449786159567983148439697693507869320722063929873179466457760853836018361089914562450768077599829054655269273946646309851958681600359850122782964839949998418032169390425722865486340196179379175914162292678145108760290403849639418072610749001823259747675209241694037355493088237584518498650553830409663190727832508512570080248909813571462397433423127272396677649647812407280145216102712853356374352364845163423759613665837824152188194732318922385012267970934631663774555243372038846958221026418Z-1000

37419668052268493829329707618118  (arctan(Pi/8) -вычислено в калькуляторе Windows)

Выявлено, что на малой значности (порядка 30 знаков) входящего аргумента, равного Pi/8, кол-во членов ряда функции должно быть больше (~ на 8-9 членов), чем размер мантиссы аргумента

// Будьте бдительны! Входящий параметр имеет критическое влияние на точность приближенного решения (см. результат, полученный для аргумента типа  Double).
Сколько знаков вошло в функцию, столько же и будет принадлежать точному значению, остальное может быть мусором, если входящий аргумент - урезанная до определённой значности константа.
}
end
else
begin
  if eqv=0 then     // |x| = 1
  begin
{
|x| = 1
Calc Windows    -    Result: 0,78539816339744830961566084581988
Zreal 245 знаков -   Result:   78539816339744830961566084581987572104929234984377645524373614807695410157155224965700870633552926699553702162832057666177346115238764555793133985203211634228200123681415575780331247739312589496273775878873911174393544291563804039548389418602483Z-245
}
    Result:=PiDiv4_ZR;
    if GetUnaryZR(ZR)<0 then Result:=InvertUnaryZR(Result);
  end
  else   // eqv>0      // |x| > 1
  begin

// arctan(x) =  (+/-)pi/2 - 1/x + 1/(3*x^3) - 1/(5*x^5) +   (при |x| > 1)
    Result:=PiDiv2_ZR; // pi/2
    if GetUnaryZR(ZR)<0 then Result:=InvertUnaryZR(Result);
    ZR1:=InvertUnaryZR(ZR);
    Result:=SumZR(Result,OneDivZR(ZR1));  // pi/2 - 1/x
    ZR0:=SqrZR(ZR);
    for i:=2 to N do
    begin
      ZR1:=MultZR(ZR0,InvertUnaryZR(ZR1));
      ZR2:=OneDivZR(MultZR(ZR1,IntToZR(i*2-1)));
      Result:=SumZR(Result,ZR2);
    end;
{
x=18  ;  Result:   1,5152978215491797836741235435475  вычислено в калькуляторе Windows
  N = MaxZNCount
x=18 (106. сек) ;   1000 знаков и членов ряда  Result:
1515297821549179783674123543547514231658781354628164881347913385276315859924791874525511446268017007995968608057010891584328617628843428513126835496704028250749032811003680331785389294513036186440571400161494828808941996527561353344989562373262771367765132054561673223044168214766617158852445423691561100961917583435893891521862112854798614531182198296687808662913231502219280664760940619605158172148204852127660336827107769208087200298600150706778880099608336316415224829540045211576350454866067484215386284152535165765487708144354573055806230998200557097499419679124561333450169576131316506622621932994911976661757072354322066968040986692861836242861380803613870574242742012889780642008062614634721699242749841889523490726885754848497046826079959079826772461115892930262210675674923104132326897552279594399863042653934278814779157184356952000877496114098991860185674074601183836537705688497156563478596351682281149872422747887420370000085444244662681492558955599770496234534125331797154982199259693Z-999

x=18 ( 2.2 сек) ;  точность до последних двух знаков - 245 членов ряда   Result:
15152978215491797836741235435475142316587813546281648813479133852763158599247918745255114462680170079959686080570108915843286176288434285131268354967040282507490328110036803317853892945130361864405714001614948288089419965275613533449895623732631Z-244

x=18 ( 0.6 сек) ;  точность до предпоследнего знака - 145 членов ряда  Result:
1515297821549179783674123543547514231658781354628164881347913385276315859924791874525511446268017007995968608057010891584328617628843428513126836Z-144

15152978215491797836741235435475  (arctan(18) - вычислено в калькуляторе Windows )
}
  end;
end;
  end; // 2:

3:begin
// ---------------------Double  (геометрический способ)  - нерабочий вариант
//
// Пусть аргумент АркТангенса представлен отношением X=x/y
   ZR0:=ZR;
   R0:=ZRToReal(ZR0);
// запись, подобная двум вышеприведённым строчкам чревата порчей данных в ZR

// тогда - x и y есть катеты прямоугольного треугольника с гипотенузой D,
// являющейся диаметром описаной окружности. D=SQRT(x^2+y^2) .

    If R0<0 then SignR0:=-1 else if R0=0 then SignR0:=0 else SignR0:=1;
//  Определим длину дуги Lx, огибающей хорду R0:

// геометрический способ определения арктангенса (Бронштейн. Справочник по математике. 1964 г. Планиметрия. Плоские фигуры. стр. 169)
   R1:=SQRT(R0*R0+1)/2;  // радиус описанной окружности
   f1:=R1-sqrt((R1*R1)-(R0*R0/4.0));  // стрела сегмента
//   Lx:=sqrt(R0*R0+((f1*f1)*16./3.0)); // приближённая формула  даёт точное решение только на двух знаках
   Lx:=sqrt(R0*R0+((f1*f1)*16.345279505781/3.0)); // приближённая формула  даёт точность получше и 16 знаков для аргумента, равного единице
   Result:=RealToZR(Lx/R1/2.0*SignR0);
  end;

4:begin
// ---------------------ZReal  (геометрический способ)
// Будет сделано, если будет отлажен предыдущий случай на типе переменных Double
    Result:=DefaultZR;
  end;

5:begin
// ---------------------Double  (оптимальный вариант вычисления АркТангенса от любого аргумента с результатом на интервале [-Pi/2;Pi/2])
// переработанный вариант, предложенный "Nikitin V.F. 2000"
  N:=16;
   ZR0:=ZR;
   R0:=ZRToReal(ZR0);
// запись, подобная двум вышеприведённым строчкам чревата порчей данных в ZR

// определяем знак аргумента
    If R0<0 then begin SignR0:=-1; R0:=Abs(R0); end else if R0=0 then SignR0:=0 else SignR0:=1;
// обращаем аргумент, если он больше 1
    If R0>1 then begin InvertR0:=True; R0:=1/R0; end else InvertR0:=False;
// локальные константы
    sqrt3:=SQRT(3);
    piDiv12:=PI/12;
    piDiv6:=Pi/6;
    piDiv2:=PI/2;
    sp:=0;
// сокращение области определения до PI/12
    x:=R0;
    while(x>piDiv12) do
    begin
      Inc(sp); a:=x+sqrt3; a:=1/a; x:=x*sqrt3; x:=x-1; x:=x*a;
    end;
// подготовка новых констант
  R3:=x;
  R0:=Sqr(R3);
  R1:=R3;
// вычисление бесконечного ряда  arctan(x) =  x - x^3/3 + x^5/5 -   (у нас |x| < 1)
  for i:=2 to N do
  begin
    R1:=R0*R1*(-1);
    R2:=R1/(i*2-1);
    R3:=R3+R2;
  end;
// доопределение сокращённой области
    a:= R3;
    while(sp>0) do
    begin
      a:=a+piDiv6; Dec(sp);
    end;
// учёт обращённого аргумента
    if InvertR0 then a:=piDiv2-a;
// смена знака результата
    if SignR0<0 then a:=-a;
// смотрим, что получилось
  Result:=RealToZR(a);
  end;

6:begin
// ---------------------ZReal   (оптимальный вариант вычисления АркТангенса от любого аргумента с результатом на интервале [-Pi/2;Pi/2])
// Основная оптимизация алгоритма вычисления разложения функции касается количества его членов и числа знаков в очередном члене разложения
// Дополнительная оптимизация по области определения функции
// Используемые операции с "масштабируемыми" действительными числами: сравнение, суммирование, разность, произведение, деление, другие.
// Используемые константы: 1/tg(pi/12) {OdTgPId12_ZR}, 1/tg(pi/192) {OdTgPId192_ZR},
// 1/tg(pi/1536) {OdTgPId1536_ZR},  1/tg(pi/1536) {OdTgPId12288_ZR},
// 1/tg(pi/1536) {OdTgPId196608_ZR},  1/tg(pi/50)  {OdTgPId50_ZR}
// PI/100,   PI/50,  Pi/393216, Pi/196608, Pi/24576, Pi/12288,
// Pi/3072, Pi/1536, Pi/384, Pi/192, PI/24, Pi/12,  PI/6,  PI/2

// определяем знак аргумента
    eqv:= ComparisonZR(ZR,DefaultZR) ;
    If eqv<0 then begin SignR0a:=-1; ZR0:=AbsZR(ZR); end
    else  If eqv=0 then begin Result:=DefaultZR; Exit; end   // выходим, потому что известно решение
          else begin ZR0:=ZR; SignR0a:=1; end;
// обращаем аргумент, если он больше 1
    eqv:= ComparisonZR(ZR0,OneZR) ;
    If eqv>1 then begin InvertR0:=True; ZR0:=OneDivZR(ZR0); end
    else InvertR0:=False;
{
// если в программе не предполагается работать с количеством знаков больше, чем 1000,
// то необходимо добавить условие, обрабатывающее ситуацию  ZR0=OneZR :
    If eqv=1 then
    begin
      Result:=PiDiv4_ZR;
      if SignR0<0 then Result:=InvertUnaryZR(Result);
      Exit;
    end;
}
//
//
    BakMaxZNCount:=MaxZNCount;
    MaxZNCount:=MaxZNCount+2;
    sp:=0;
// Дополнительная оптимизация: Каскадное сокращение области определения
// сокращение области определения до PI/24
    eqv:= ComparisonZR(ZR0,PiDiv24_ZR) ;   //
    while eqv>0 do
    begin
      Inc(sp);
      ZR1:=SumZR(ZR0,OdTgPId12_ZR);        //
      ZR1:=OneDivZR(ZR1);
      ZR0:=MultZR(ZR0,OdTgPId12_ZR);       //
      ZR0:=SubZR(ZR0,OneZR);
      ZR0:=MultZR(ZR0,ZR1);
      SetLength(indRate,sp);
      indRate[sp-1]:=0;
      eqv:= ComparisonZR(ZR0,PiDiv24_ZR) ; //
    end;

// вставка дополнительного шага сокращения области определения функции
// обращение знака...
// может возникнуть ситуация, что шаг будет пропущен, тогда нужно
// выполнить его обход, чтобы ничего не изменить
  if ComparisonZR(AbsZR(ZR0),PiDiv100_ZR)>0 then  //
  begin

    If ComparisonZR(ZR0,DefaultZR)<0 then begin SignR0f:=-1; ZR0:=AbsZR(ZR0); end
    else SignR0f:=1;
//    if not eqv>0 then SignR0b:=1; // если шаг пропускается, то не
// сокращение области определения до PI/100
    eqv:=1  ;
    while eqv>0 do
    begin
      Inc(sp);
      ZR1:=SumZR(ZR0,OdTgPId50_ZR);        //
      ZR1:=OneDivZR(ZR1);
      ZR0:=MultZR(ZR0,OdTgPId50_ZR);       //
      ZR0:=SubZR(ZR0,OneZR);
      ZR0:=MultZR(ZR0,ZR1);
      SetLength(indRate,sp);
      indRate[sp-1]:=5;    // прежнюю нумерацию индексации не сдвигаем
      eqv:= ComparisonZR(ZR0,PiDiv100_ZR) ; //
    end;
  end; // ComparisonZR(AbsZR(ZR0),PiDiv100_ZR)>0


// Повторное обращение знака.

// может возникнуть ситуация, что второй шаг будет пропущен, тогда нужно
// выполнить его обход, чтобы ничего не изменить
  if ComparisonZR(AbsZR(ZR0),PiDiv384_ZR)>0 then  //
  begin

    If ComparisonZR(ZR0,DefaultZR)<0 then begin SignR0b:=-1; ZR0:=AbsZR(ZR0); end
    else SignR0b:=1;
//    if not eqv>0 then SignR0b:=1; // если шаг пропускается, то не
// сокращение области определения до PI/384
    eqv:=1  ;
    while eqv>0 do
    begin
      Inc(sp);
      ZR1:=SumZR(ZR0,OdTgPId192_ZR);        //
      ZR1:=OneDivZR(ZR1);
      ZR0:=MultZR(ZR0,OdTgPId192_ZR);       //
      ZR0:=SubZR(ZR0,OneZR);
      ZR0:=MultZR(ZR0,ZR1);
      SetLength(indRate,sp);
      indRate[sp-1]:=1;
      eqv:= ComparisonZR(ZR0,PiDiv384_ZR) ; //
    end;
  end; // ComparisonZR(AbsZR(ZR0),PiDiv384_ZR)>0

// Третье обращение знака.

// может возникнуть ситуация, что третий шаг будет пропущен, тогда нужно
// выполнить его обход, чтобы ничего не изменить
  if ComparisonZR(AbsZR(ZR0),PiDiv3072_ZR)>0 then    //
  begin

    If ComparisonZR(ZR0,DefaultZR)<0 then begin SignR0c:=-1; ZR0:=AbsZR(ZR0); end
    else SignR0c:=1;
// сокращение области определения до PI/3072
    eqv:=1  ;
    while eqv>0 do
    begin
      Inc(sp);
      ZR1:=SumZR(ZR0,OdTgPId1536_ZR);        //
      ZR1:=OneDivZR(ZR1);
      ZR0:=MultZR(ZR0,OdTgPId1536_ZR);       //
      ZR0:=SubZR(ZR0,OneZR);
      ZR0:=MultZR(ZR0,ZR1);
      SetLength(indRate,sp);
      indRate[sp-1]:=2;
      eqv:= ComparisonZR(ZR0,PiDiv3072_ZR) ; //
    end;
  end; // ComparisonZR(AbsZR(ZR0),PiDiv3072_ZR)>0

// четвёртое обращение знака.

// может возникнуть ситуация, что четвёртый шаг будет пропущен, тогда нужно
// выполнить его обход, чтобы ничего не изменить
  if ComparisonZR(AbsZR(ZR0),PiDiv24576_ZR)>0 then   //
  begin

    If ComparisonZR(ZR0,DefaultZR)<0 then begin SignR0d:=-1; ZR0:=AbsZR(ZR0); end
    else SignR0d:=1;
// сокращение области определения до PI/24576
    eqv:=1  ;
    while eqv>0 do
    begin
      Inc(sp);
      ZR1:=SumZR(ZR0,OdTgPId12288_ZR);        //
      ZR1:=OneDivZR(ZR1);
      ZR0:=MultZR(ZR0,OdTgPId12288_ZR);       //
      ZR0:=SubZR(ZR0,OneZR);
      ZR0:=MultZR(ZR0,ZR1);
      SetLength(indRate,sp);
      indRate[sp-1]:=3;
      eqv:= ComparisonZR(ZR0,PiDiv24576_ZR) ; //
    end;
  end; // ComparisonZR(AbsZR(ZR0),PiDiv24576_ZR)>0

// пятое обращение знака.

// может возникнуть ситуация, что пятый шаг будет пропущен, тогда нужно
// выполнить его обход, чтобы ничего не изменить
  if ComparisonZR(AbsZR(ZR0),PiDiv393216_ZR)>0 then   //
  begin

    If ComparisonZR(ZR0,DefaultZR)<0 then begin SignR0e:=-1; ZR0:=AbsZR(ZR0); end
    else SignR0e:=1;
// сокращение области определения до PI/393216
    eqv:=1  ;
    while eqv>0 do
    begin
      Inc(sp);
      ZR1:=SumZR(ZR0,OdTgPId196608_ZR);        //
      ZR1:=OneDivZR(ZR1);
      ZR0:=MultZR(ZR0,OdTgPId196608_ZR);       //
      ZR0:=SubZR(ZR0,OneZR);
      ZR0:=MultZR(ZR0,ZR1);
      SetLength(indRate,sp);
      indRate[sp-1]:=4;
      eqv:= ComparisonZR(ZR0,PiDiv393216_ZR) ; //
    end;
  end; // ComparisonZR(AbsZR(ZR0),PiDiv393216_ZR)>0

// подготовка констант
    ZR3:=SqrZR(ZR0);
    ZR1:=ZR0;

    MaxZNCount:=MaxZNCount-2;
// вычисление разложения arctan(x) =  x - x^3/3 + x^5/5 -   (на данный момент у нас |x| < 1)
// пока старший разряд очередного члена этого ряда больше нижнего разряда
// суммы предыдущих членов нашего разложения
    iExp:=HighDeciZR(ZR0,bool).E-MaxZNCount; // Степень младшего разряда суммы членов ряда   (в нашем алгоритме она всегда меньше нуля)
    j:=0; // Степень старшего разряда очередного члена ряда
    i:=2; // стартовый номер очередного члена ряда
    while (j>iExp) do
    begin
      MaxZNCount:=j-iExp+2; // оптимизированная длина числа очередного члена разложения
// +2 - для повышения точности вычислений
      ZR1:=MultZR(ZR3,InvertUnaryZR(ZR1));
      ZR2:=DivZR(ZR1,IntToZR(i*2-1));
      j:=HighDeciZR(ZR2,bool).E; // Степень старшего разряда очередного члена ряда
      MaxZNCount:=BakMaxZNCount+2; // восстановливаем точность вычислений перед суммированием членов ряда
      ZR0:=SumZR(ZR0,ZR2);
      Inc(i);
    end;

// доопределение сокращённой области  (в обратном порядке относительно её сокращения)
// Дополнительная оптимизация: Каскадное восстановление области определения
    while(sp>0) do
    begin
      if indRate[sp-1]=0 then
      begin
        if SignR0e<0 then begin ZR0:=InvertUnaryZR(ZR0); SignR0e:=1 end; // промежуточная смена знака, если был пропущен один из предыдущих шагов
        if SignR0d<0 then begin ZR0:=InvertUnaryZR(ZR0); SignR0d:=1 end; // промежуточная смена знака, если был пропущен один из предыдущих шагов
        if SignR0c<0 then begin ZR0:=InvertUnaryZR(ZR0); SignR0c:=1 end; // промежуточная смена знака, если был пропущен второй шаг "Каскадного сокращения области определения"
        if SignR0b<0 then begin ZR0:=InvertUnaryZR(ZR0); SignR0b:=1 end; // промежуточная смена знака, если был пропущен один из предыдущих шагов
        if SignR0f<0 then begin ZR0:=InvertUnaryZR(ZR0); SignR0f:=1 end; // промежуточная смена знака
        ZR0:=SumZR(ZR0,PiDiv12_ZR)
      end
      else if indRate[sp-1]=5 then   // вставка дополнительного условия
           begin
             if SignR0e<0 then begin ZR0:=InvertUnaryZR(ZR0); SignR0e:=1 end; // промежуточная смена знака, если был пропущен один из предыдущих шагов
             if SignR0d<0 then begin ZR0:=InvertUnaryZR(ZR0); SignR0d:=1 end; // промежуточная смена знака, если был пропущен один из предыдущих шагов
             if SignR0c<0 then begin ZR0:=InvertUnaryZR(ZR0); SignR0c:=1 end; // промежуточная смена знака, если был пропущен один из предыдущих шагов
             if SignR0b<0 then begin ZR0:=InvertUnaryZR(ZR0); SignR0b:=1 end; // промежуточная смена знака
             ZR0:=SumZR(ZR0,PiDiv50_ZR);
           end
      else if indRate[sp-1]=1 then
           begin
             if SignR0e<0 then begin ZR0:=InvertUnaryZR(ZR0); SignR0e:=1 end; // промежуточная смена знака, если был пропущен один из предыдущих шагов
             if SignR0d<0 then begin ZR0:=InvertUnaryZR(ZR0); SignR0d:=1 end; // промежуточная смена знака, если был пропущен один из предыдущих шагов
             if SignR0c<0 then begin ZR0:=InvertUnaryZR(ZR0); SignR0c:=1 end; // промежуточная смена знака
             ZR0:=SumZR(ZR0,PiDiv192_ZR);
           end
           else if indRate[sp-1]=2 then
                begin
                  if SignR0e<0 then begin ZR0:=InvertUnaryZR(ZR0); SignR0e:=1 end; // промежуточная смена знака, если был пропущен один из предыдущих шагов
                  if SignR0d<0 then begin ZR0:=InvertUnaryZR(ZR0); SignR0d:=1 end; // промежуточная смена знака
                  ZR0:=SumZR(ZR0,PiDiv1536_ZR);
                end
                else if indRate[sp-1]=3 then
                     begin
                       if SignR0e<0 then begin ZR0:=InvertUnaryZR(ZR0); SignR0e:=1 end; // промежуточная смена знака
                       ZR0:=SumZR(ZR0,PiDiv12288_ZR);
                     end
                     else if indRate[sp-1]=4 then
                          begin
                            ZR0:=SumZR(ZR0,PiDiv196608_ZR);
                          end; //
      Dec(sp);                        //
    end;
// учёт обращённого аргумента
    if InvertR0 then ZR0:=SubZR(PiDiv2_ZR,ZR0);
// смена знака результата
    if SignR0a<0 then ZR0:=InvertUnaryZR(ZR0);
// смотрим, что получилось
  MaxZNCount:=BakMaxZNCount;
  Result:=ZR0;
{
__________________________________
ArctanZR(X)   -    методом сужения области определения до [0,pi/12] ©"Nikitin V.F. 2000"
// Последовательное описание разработки вышеизложенного алгоритма вычисления Арктангенса
__________________________________
арг X        T (sec)     N (чл.р.)
----------------------------------
1000,001    8,5          169        // вычисления дольше, чем в последнем случае с аргументом, равным 0,001, в виду того, что сказывается значность входящего аргумента
   2,0     20,0          410
   1,0     41,5          873
   0,9     35,0          743
   0,26     4,6          854
   0,13     3,0          545
   0,12... 26,7                     // 1000 знаков
   0,016... 2,2          281        // 32 знака
   0,001    0,8          169
__________________________________
Вывод (перед дополнительной оптимизацией по области определения):
Высокая точность катастрофически увеличивает необходимое время на вычисление
функции, даже с учётом оптимизации по длине бесконечного ряда и значности её членов.
Для уменьшения времени расчёта сократим область определения функции в два раза.
Как видно из приведённой ниже таблицы, оптимизация привела к полуторократному
улучшению производительности функции. Однако этого не достаточно, потому что ещё
нельзя сказать, что функция выполняется на "Раз".
__________________________________
ArctanZR(X)   -   1000 знаков     - методом сужения области определения до [0,pi/24]
__________________________________
арг X        T (sec)     N (чл.р.)
----------------------------------
1000,001    9,4          170
   2,0     20,6          410
   1,0      0,6          3
   0,9     19,4          392
   0,26    11,5          237
   0,13     3,0          545          // почему такое маленькое время вычисления?
   0,12... 26,8          563          // 1000 знаков
   0,016... 2,2          281          // 32 знака
   0,001    0,8          169
__________________________________
0,001
9999996666668666665238096349205440116209345542680130914310481876454723406695622912734749014084020132116492147102870209112992719336589404762114217767007553710342939219748638341393494079766388072890942777440997947348105420974134174363319807076047332164625425797759680362616939709149416983715972207798883250289477008919054940964469797563520049201783733321561704147942311124536246981595235414656483663017271630836828486061336896821091272711396835198755374553175233154369405056319963383805473979074524228293761478198928012163540741466752404157063936821616136540658766951451090568990170061227187910346436843335045874534343292066296966884034562793366334738643021810900834166719221864199593709225587910163414928925180281985464337632449650476928626603432337909470313480622630821420422129301117131833503156172003089364354294440896776742103394467730309196795840111804369216048953117858675430154509788606924090927942366192927129011920609547733095697147277993338529676826678516847264760433926626052818034552947070Z-1003
999999666666866666523809634920544011620934554268013091431048187645472340669562291273474901408402013211649214710287020911299271933658940476211421776700755371034293921974863834139349407976638807289094277744099794734810542097413417436331980707604733216462542579775968036261693970914941698371597220779888325028947700891905494096446979756352004920178373332156170414794231112453624698159523541465648366301727163083682848606133689682109127271139683519875537455317523315436940505631996338380547397907452422829376147819892801216354074146675240415706393682161613654065876695145109056899017006122718791034643684333504587453434329206629696688403456279336633473864302181090083416671922186419959370922558791016341492892518028198546433763244965047692862660343233790947031348062263082142042212930111713183350315617200308936435429444089677674210339446773030919679584011180436921604895311785867543015450978860692409092794236619292712901192060954773309569714727799333852967682667851684726476043392662605281803455294707001405Z-1008

Аргумент: 0,016362461737446839783659600954581
1636100173050486940818000717203003016036536134274834874115901828774683020439973863309897575192091179367010702808245726450133711415753555125232797804949677475732776587201507760858498429680937851130558489263445078811240447074843877344566710891965066454581966836363649153508229545076820790233611054223302847819118535046750043557229070339378805229624966307698123436669587596962458241987940747810593152924817408591458027905987957411207855520439201047883152827195440183575991540385173113531063344476255567611815256006247490563117367581218149586021783308332293586932372220433663190206267987306405606938123902048229624430329633597405370300938145942918999254618220444557867575211254697207112328276987681756384570063589989833902447577837524975332171462396883965352587103079326745336455218404838885544414476986606876426144044539765564436241625254461699760349481884169891026895225158960897354102567462919957750590633646739934888999674843340896813693035655187964947877359114993910908750220106339147578762518728234Z-1001
163610017305048694081800071720300301603653613427483487411590182877468302043997386330989757519209117936701070280824572645013371141575355512523279780494967747573277658720150776085849842968093785113055848926344507881124044707484387734456671089196506645458196683636364915350822954507682079023361105422330284781911853504675004355722907033937880522962496630769812343666958759696245824198794074781059315292481740859145802790598795741120785552043920104788315282719544018357599154038517311353106334447625556761181525600624749056311736758121814958602178330833229358693237222043366319020626798730640560693812390204822962443032963359740537030093814594291899925461822044455786757521125469720711232827698768175638457006358998983390244757783752497533217146239688396535258710307932674533645521840483888554441447698660687642614404453976556443624162525446169976034948188416989102689522515896089735410256746291995775059063364673993488899967484334089681369303565518796494787735911499391090875022010633914757876251872823429457Z-1006

Аргумент: 1292750040481430547159993832697135646458876915022384256737998502042180339250211018865129492559778999437863301293078138726017258250689114318604915228162796318294685899700597945989710461243566289152568769897732429242518692975387119143659316035745452943569156198437184868039038308872809202569494246967337118015492516614056318139072196486956128384034828484170838094266063678239927990312174477135594279506111820114772926727748040632599409505527648590570165195303071522764509329211676431358755677679701072112509170011590189322727380620970542767707000098494746952851302380855218441015911826624341483866201406152165106870178468599254439459186546783208981426375591391468065734721255066343382524573579031684829375635232125439859233767145760402835460114246907490306609353063045293529651244814291454300202067384873645509563507162375178871168667040216856636253231914072995335369852209814691406563565778143236818989673445513107811660526522436305040244946386640094460643094086579177789868526899743374153100612538671Z-1000
1285619909395704107182281178202278113807210788899626403499154878425471554360869070376648772694572128708753694347465288113472167899101314686351192976931730541675597979390221245192524209350277672803255884248209656799149308366368100860528222345201202120713481961928109653619807986016618307954991169648326919126641988374694663964560091823894929722510769433987240916885301853715640968943649677964905357341537018480530912272878085687918015306521453504907802969736403007774950329925359906615348110050693987497608737602384192805710461376052538549670477424646135673886864759942676913302366247081524133598158719378856624006790982363933821041821383502103483864204685507608779167001057168441129464137484340007591354592724746670323697941983082983694095643912322241477203086346567973095369773140204242574465302307119730971945617832134860112424629831484730340665722487349763704004751132641175750146523228908932903225463479343037576783672926699594278190566794580387931676899520829580975431935302971147045677241011862Z-1000
128561990939570410718228117820227811380721078889962640349915487842547155436086907037664877269457212870875369434746528811347216789910131468635119297693173054167559797939022124519252420935027767280325588424820965679914930836636810086052822234520120212071348196192810965361980798601661830795499116964832691912664198837469466396456009182389492972251076943398724091688530185371564096894364967796490535734153701848053091227287808568791801530652145350490780296973640300777495032992535990661534811005069398749760873760238419280571046137605253854967047742464613567388686475994267691330236624708152413359815871937885662400679098236393382104182138350210348386420468550760877916700105716844112946413748434000759135459272474667032369794198308298369409564391232224147720308634656797309536977314020424257446530230711973097194561783213486011242462983148473034066572248734976370400475113264117575014652322890893290322546347934303757678367292669959427819056679458038793167689952082958097543193530297114704567724101186226586Z-1005

0,13
1292750040481430547159993832697135646458876915022384256737998502042180339250211018865129492559778999437863301293078138726017258250689114318604915228162796318294685899700597945989710461243566289152568769897732429242518692975387119143659316035745452943569156198437184868039038308872809202569494246967337118015492516614056318139072196486956128384034828484170838094266063678239927990312174477135594279506111820114772926727748040632599409505527648590570165195303071522764509329211676431358755677679701072112509170011590189322727380620970542767707000098494746952851302380855218441015911826624341483866201406152165106870178468599254439459186546783208981426375591391468065734721255066343382524573579031684829375635232125439859233767145760402835460114246907490306609353063045293529651244814291454300202067384873645509563507162375178871168667040216856636253231914072995335369852209814691406563565778143236818989673445513107811660526522436305040244946386640094460643094086579177789868526899743374153100612538671Z-1000
129275004048143054715999383269713564645887691502238425673799850204218033925021101886512949255977899943786330129307813872601725825068911431860491522816279631829468589970059794598971046124356628915256876989773242924251869297538711914365931603574545294356915619843718486803903830887280920256949424696733711801549251661405631813907219648695612838403482848417083809426606367823992799031217447713559427950611182011477292672774804063259940950552764859057016519530307152276450932921167643135875567767970107211250917001159018932272738062097054276770700009849474695285130238085521844101591182662434148386620140615216510687017846859925443945918654678320898142637559139146806573472125506634338252457357903168482937563523212543985923376714576040283546011424690749030660935306304529352965124481429145430020206738487364550956350716237517887116866704021685663625323191407299533536985220981469140656356577814323681898967344551310781166052652243630504024494638664009446064309408657917778986852689974337415310061253867128518Z-1005
,26
2543680585532659314288571233246097128713425975527433378503102708768709597262063150980594922263666557112738209355177053505813916440522060373363946585361942800438145718119763912570115439088894299330249752538550830257063675055756454919528031312336934700979716851074412956821642802715568503129791842551504544713761560578245401982608204722511318294423968709766201672110969814986224310013278818059381299856044121310993859763088116793877819692403490154659931644270843592554674579519318247268739380245757952099323863007978613515958303270296086244754453700704408583738163225979134292929020106462480773972476249536784757345997684087552553131715364129399581096966635033762285784785453694813982195803381498111752866718495997767343596129227012058461161554169955318109909944311535918554163899490488574035209716557987490483078464473072066637006976382804522873849862435480107532032378580810247806732010479896742531439575876574997695813116631533256041385021069119372492767682752139156925383462978031583009413280569790Z-1000
254368058553265931428857123324609712871342597552743337850310270876870959726206315098059492226366655711273820935517705350581391644052206037336394658536194280043814571811976391257011543908889429933024975253855083025706367505575645491952803131233693470097971685107441295682164280271556850312979184255150454471376156057824540198260820472251131829442396870976620167211096981498622431001327881805938129985604412131099385976308811679387781969240349015465993164427084359255467457951931824726873938024575795209932386300797861351595830327029608624475445370070440858373816322597913429292902010646248077397247624953678475734599768408755255313171536412939958109696663503376228578478545369481398219580338149811175286671849599776734359612922701205846116155416995531810990994431153591855416389949048857403520971655798749048307846447307206663700697638280452287384986243548010753203237858081024780673201047989674253143957587657499769581311663153325604138502106911937249276768275213915692538346297803158300941328056979035487Z-1005
,9
7328151017865065916407920727342802519857556793582560863105069319282124712665579439661780111216246881054082500042849531588804330871994229984629891646661941922334045152389415720691498051465394777468094351847569954244937468825574232710269255125066072071370496105082240015111538692966337692618383660222142905086109645549426160514945788646328012046311156956522388174517469898714142774517579267795164758722373723144026266141973509598176004755712762780622548774288156047661282695439628676054498619034237399407446256146235772264154294068265591208280257067639692906922501744099095898196619009904252059290010847634636944574611918544659040931438037063834061235192518486232704662162438276005699424815372141566513766481172200880778000043219667033525889339756042569431683245610104845467198675796957929354871251442408247871748599140235704494305837192593195633775690759407626879671501389501578803153383857397078387409678687451950867835331842592245996250858020357140718947136385405580802922408780483277000738887256212Z-1000
732815101786506591640792072734280251985755679358256086310506931928212471266557943966178011121624688105408250004284953158880433087199422998462989164666194192233404515238941572069149805146539477746809435184756995424493746882557423271026925512506607207137049610508224001511153869296633769261838366022214290508610964554942616051494578864632801204631115695652238817451746989871414277451757926779516475872237372314402626614197350959817600475571276278062254877428815604766128269543962867605449861903423739940744625614623577226415429406826559120828025706763969290692250174409909589819661900990425205929001084763463694457461191854465904093143803706383406123519251848623270466216243827600569942481537214156651376648117220088077800004321966703352588933975604256943168324561010484546719867579695792935487125144240824787174859914023570449430583719259319563377569075940762687967150138950157880315338385739707838740967868745195086783533184259224599625085802035714071894713638540558080292240878048327700073888725621173845Z-1005
1
7853981633974483096156608458198757210492923498437764552437361480769541015715522496570087063355292669955370216283205766617734611523876455579313398520321202793625710256754846302763899111557372387325954911072027439164833615321189120584466957913178004772864121417308650871526135816620533484018150622853184311467516515788970437203802302407073135229288410919731475900028326326372051166303460367379853779023582643175914398979882730465293454831529482762796370186155949906873918379714381812228069845457529872824584183406101641607715053487365988061842976755449652359256926348042940732941880961687046169173512830001420317863158902069464428356894474022934092946803671102253062383575366373963427626980699223147308855049890280322554902160086045399534074436928274901296768028374999995932445124877649329332040240796487561148638367270756606305770633361712588154827970427525007844596882216468833020953551542944172868258995633726071888671827898907159705884468984379894454644451330428067016532504819691527989773041050493Z-1000
785398163397448309615660845819875721049292349843776455243736148076954101571552249657008706335529266995537021628320576661773461152387645557931339852032120279362571025675484630276389911155737238732595491107202743916483361532118912058446695791317800477286412141730865087152613581662053348401815062285318431146751651578897043720380230240707313522928841091973147590002832632637205116630346036737985377902358264317591439897988273046529345483152948276279637018615594990687391837971438181222806984545752987282458418340610164160771505348736598806184297675544965235925692634804294073294188096168704616917351283000142031786315890206946442835689447402293409294680367110225306238357536637396342762698069922314730885504989028032255490216008604539953407443692827490129676802837499999593244512487764932933204024079648756114863836727075660630577063336171258815482797042752500784459688221646883302095355154294417286825899563372607188867182789890715970588446898437989445464445133042806701653250481969152798977304105049368785Z-1005
2
1107148717794090503017065460178537040070047645401432646676539207433710338977362794013417128686170641434544191005450315810041104123150279960391149134120134938005805785186089159020277066323548671948337093046927250546427929146225306917409377626797415839477802650155236302150617431245551139595028661343071619620451122700330078743309876584050730556855033496160917167182032143557952418577001974141917867556092072396370970780081569293338989816628296388058648735549977420441253262448910061152421541607476658452967630519135912384306883380785499443665836032138897074518792365757298891993783946015848255470901612250351968711897831227460369643896101759549486816806083720841936706092318858507663251672427870156094793691467362050699710474237952805081154791173982305447826322952479276589220603404510278110198878003520641243073406563806386080606837666971733818544308606074699132134849976299998223302991267312103414276992963861911174853919055822470048763842269788306246988883221693259159049588694161190408677435945636Z-999
110714871779409050301706546017853704007004764540143264667653920743371033897736279401341712868617064143454419100545031581004110412315027996039114913412013493800580578518608915902027706632354867194833709304692725054642792914622530691740937762679741583947780265015523630215061743124555113959502866134307161962045112270033007874330987658405073055685503349616091716718203214355795241857700197414191786755609207239637097078008156929333898981662829638805864873554997742044125326244891006115242154160747665845296763051913591238430688338078549944366583603213889707451879236575729889199378394601584825547090161225035196871189783122746036964389610175954948681680608372084193670609231885850766325167242787015609479369146736205069971047423795280508115479117398230544782632295247927658922060340451027811019887800352064124307340656380638608060683766697173381854430860607469913213484997629999822330299126731210341427699296386191117485391905582247004876384226978830624698888322169325915904958869416119040867743594563556638Z-1004
1000,001
1569796327228229642564918881871397712263466960981546128526390249798173824380337989830994351509267439671315958859303428919137830050301403745330645152786991620082293918573577819393540501615172492602296952581416410943295223698222640288010739758468863834231323426643415475743012130030014334125397987702909777958959772567251890143609186817599095571167685711918913423628149778545851110357033924206523102488186091310352055996434434317119815834419940433980499079628942017675220641394773415693719756138653188968469679972601058759411988279877544223017316739126935565810313625902593726614348273578458410979952498054996991945411031097655709803317960040106355381104485315470516636015250943021434917035257997254946953807030183188069335310177965080499584121506381011447422527429374825006980401093208054631111803230808665269558320007385985125400543793319140473151453125399021124904577820496209843859434396194545453981016161172667086248291549228611999386707448588419783049087168220657687965429746777465224389335714207Z-999
156979632722822964256491888187139771226346696098154612852639024979817382438033798983099435150926743967131595885930342891913783005030140374533064515278699162008229391857357781939354050161517249260229695258141641094329522369822264028801073975846886383423132342664341547574301213003001433412539798770290977795895977256725189014360918681759909557116768571191891342362814977854585111035703392420652310248818609131035205599643443431711981583441994043398049907962894201767522064139477341569371975613865318896846967997260105875941198827987754422301731673912693556581031362590259372661434827357845841097995249805499699194541103109765570980331796004010635538110448531547051663601525094302143491703525799725494695380703018318806933531017796508049958412150638101144742252742937482500698040109320805463111180323080866526955832000738598512540054379331914047315145312539902112490457782049620984385943439619454545398101616117266708624829154922861199938670744858841978304908716822065768796542974677746522438933571420686732Z-1004

Вывод:
Предельное время работы функции по табличным данным уменьшилось чуть менее, чем в два раза.
Следует ещё сильнее ужать область определения, чтобы уменьшить время вычисления
разложения, хотя бы до 10 секунд, на высокой разрядности аргумента.

__________________________________
арг X        T (sec)     N (чл.р.)
----------------------------------
tg(pi/192)   13,4       281                 // 1000 знаков
tg(pi/3072)   8,0       169                 // 1000 знаков
__________________________________
Аргумент
(~pi/192): 0,016362461737446839783659600954581163624617374468397836596009545811636246173744683978365960095458116362461737446839783659600954581163624617374468397836596009545811636246173744683978365960095458116362461737446839783659600954581163624617374468397836596009545811636246173744683978365960095458116362461737446839783659600954581163624617374468397836596009545811636246173744683978365960095458116362461737446839783659600954581163624617374468397836596009545811636246173744683978365960095458116362461737446839783659600954581163624617374468397836596009545811636246173744683978365960095458116362461737446839783659600954581163624617374468397836596009545811636246173744683978365960095458116362461737446839783659600954581163624617374468397836596009545811636246173744683978365960095458116362461737446839783659600954581163624617374468397836596009545811636246173744683978365960095458116362461737446839783659600954581163624617374468397836596009545811636246173744683978365960095458116362461737446839783659600954163624617
1636100173050486940818000717203019374118721716634228759065833030804664503303917172396742869462873350777027547795273532379632463968147311159495490515310118129528745523966023119486232593036172851009865828442936775938252230388155622710461048630352742204055216092675862197426844665134546369452221381610016848243039350414886782640251131347375682253677743310386743275827558705278786598961542735215831379000828850202202049227663022722624059958936991754878566582173821776024754762354491391757093292258059136238666842497583817901063355850209247202826081623784139052788169947059701317211399665906967460903176557311216756917551537948937866987577552652468997152816032796303973472415964036170719269766563670532988188596806824699655811079161137815634211515502780643786136498977244304222843573334644935776200311621118210828333012857263685624182407926685826276354222988832822656428952015314539114454848430194004671070218806212367646681030239521446438316662651567591126971571306007826921196411023392454671429726841309Z-1001
163610017305048694081800071720301937411872171663422875906583303080466450330391717239674286946287335077702754779527353237963246396814731115949549051531011812952874552396602311948623259303617285100986582844293677593825223038815562271046104863035274220405521609267586219742684466513454636945222138161001684824303935041488678264025113134737568225367774331038674327582755870527878659896154273521583137900082885020220204922766302272262405995893699175487856658217382177602475476235449139175709329225805913623866684249758381790106335585020924720282608162378413905278816994705970131721139966590696746090317655731121675691755153794893786698757755265246899715281603279630397347241596403617071926976656367053298818859680682469965581107916113781563421151550278064378613649897724430422284357333464493577620031162111821082833301285726368562418240792668582627635422298883282265642895201531453911445484843019400467107021880621236764668103023952144643831666265156759112697157130600782692119641102339245467142972684130858438Z-1006

Аргумент
(~pi/3072):0,001022654215094841154940098025921810226542150948411549400980259218102265421509484115494009802592181022654215094841154940098025921810226542150948411549400980259218102265421509484115494009802592181022654215094841154940098025921810226542150948411549400980259218102265421509484115494009802592181022654215094841154940098025921810226542150948411549400980259218102265421509484115494009802592181022654215094841154940098025921810226542150948411549400980259218102265421509484115494009802592181022654215094841154940098025921810226542150948411549400980259218102265421509484115494009802592181022654215094841154940098025921810226542150948411549400980259218102265421509484115494009802592181022654215094841154940098025921810226542150948411549400980259218102265421509484115494009802592181022654215094841154940098025921810226542150948411549400980259218102265421509484115494009802592181022654215094841154940098025921810226542150948411549400980259218102265421509484115494009802592181022654215094841154940098025921810228
1022653858590427486478725059661333276102833173461440657331098532799206772655551249082346011581960109497696312008071036908650378711697840401325952321821579541770994842685505657607071613001164300032419131602133381447556309923607893587673805101281355146741477290828317904252421199263015452418541647986830229317574440504090008995647798323096530375642391604879216562292555550010583780999943535400601475428774136589036218675687785142362622577263445611858545697733753223867650232812960299061389145150236801491428699435109102245256866005735411827139507225694212581034901768015669615256969848546538133430050333943508155930673178558328714188030071142502672816209770442848740397801129047060138373236473949617323651207555714090518661465363673362533994925172794467389650342398943016229551902941241138200552554195726937046726715442278275493899603612342977667839821947644233435251096814191967440936472765124636249117330747223579176978503926343412506635969889931383759307748958184019064357337314255895627638693895468Z-1002
102265385859042748647872505966133327610283317346144065733109853279920677265555124908234601158196010949769631200807103690865037871169784040132595232182157954177099484268550565760707161300116430003241913160213338144755630992360789358767380510128135514674147729082831790425242119926301545241854164798683022931757444050409000899564779832309653037564239160487921656229255555001058378099994353540060147542877413658903621867568778514236262257726344561185854569773375322386765023281296029906138914515023680149142869943510910224525686600573541182713950722569421258103490176801566961525696984854653813343005033394350815593067317855832871418803007114250267281620977044284874039780112904706013837323647394961732365120755571409051866146536367336253399492517279446738965034239894301622955190294124113820055255419572693704672671544227827549389960361234297766783982194764423343525109681419196744093647276512463624911733074722357917697850392634341250663596988993138375930774895818401906435733731425589562763869389546824931Z-1007

// Для проверки оптимальности сжатия области определения функции нам потребуются
новые константы: pi/1536, pi/3072 и тангенс от pi/1536
// В результате последней оптимизации проверим увеличение времени на накладные
расходы, связанные с сокращением области определения функции.
********************************************************************************
Результаты дополнительной оптимизации: "Каскадного сжатия области определения функции"
____________________________________________________________
арг X        T (sec)     N (чл.р.)  sp (накладные расходы)
-------------------------------------------------------------
1000,001    9,8          169        6
   2,0     11,2          159       11
   1,0      0,6            3        3
   0,9     10,1          157        8
   0,26     9,4          162        5
   0,13    10,0          150        9
   0,12...  9,9          144        9                  // 1000 знаков
   0,016... 4,6           88        1                  // 32 знака
   0,001    0,8          169        0
   pi/192   4,7           88        1                  // 1000 знаков
   pi/3072  8,7          169        1                  // 1000 знаков
____________________________________________________________
Как видно из таблицы, Каскадное сжатие области определения функции на два порядка
по сравнению с областью определения из предыдущих расчётов привело к ~2,5 кратному
уменьшению времени вычислений. Накладные расходы пока остаются небольшими по
сравнению со временем расчёта элементов бесконечного ряда и их суммы.

Попробуем сжать область определения функции ещё на два порядка, и посмотрим,
улучшится ли временной показатель выполнения функции.
____________________________________________________________
арг X        T (sec)     N (чл.р.)  sp (накладные расходы)
-------------------------------------------------------------
1000,001    7,7           99       11
   2,0     10,1           90       21(4+4+3+2+8)       // В этом примере накладные расходы сильно повлияли на невозможность сокращения времени расчёта (на них уходит больше 50% времени)
   1,0      0,6            3        3
   0,9      8,7           94       15
   0,26     6,6           86        9
   0,13     9,4           97       17                  // В этом примере накладные расходы сильно повлияли на невозможность сокращения времени расчёта (на них уходит порядка 50% времени)
   0,12...  8,0           96       12                  // 1000 знаков
   0,016... 4,5           88        1                  // 32 знака
   0,001    6,1           99        5                  // здесь вообще появились накладные расходы, которые повлияли на ухудшение точности решения до двух последних знаков
   pi/192   4,6           88        1                  // 1000 знаков
   pi/3072  2,3           17        5                  // 1000 знаков
____________________________________________________________
Общий итог, незначительное улучшение быстродействия по сравнению с предыдущим
шагом оптимизации заметно, однако оно очень далеко от ожидаемого эффекта.
Слабое сокращение времени видимо связано с кратность шага уменьшения области
определения функции. Поэтому введём между первым и вторым шагом сжатия области
определения функции промежуточный, с диапазоном - [0;pi/100]. Такой ход должен
положительно повлиять на время вычислений.
____________________________________________________________
арг X        T (sec)     N (чл.р.)  sp (накладные расходы)
-------------------------------------------------------------
1000,001    7,8           99       11                  /-/ здесь ничего не изменилось, следовательно необходимо выбрать ещё один меньший, несимметричныё к существующим, диапазон
   2,0      8,2           96       13                  /+/ вот теперь совсем другое дело (заметный прогресс, можно ещё продолжить в том же духе, то есть выбрать ещё какой-нибудь диапазон, несимметричный к существующим)
   1,0      0,6            3        3
   0,9      7,2           98        9                  /+/ появился временной выигрыш
   0,26     6,6           86        9                  /-/ ничего не изменилось
   0,13     5,7           71        8                  /+/ очень хорошее улучшение временного показателя (почти на 40% относительно предпоследних данных)
   0,12...  7,8           98       11                  /+/ 1000 знаков - есть очень небольшое ускорение
   0,016... 4,5           88        1                  /-/ 32 знака     - здесь ничего не изменилось
   0,001    6,1           99        5                  /-/ этого аргумента наша оптимизация не коснулась
   pi/192   4,5           88        1                  /-/ 1000 знаков  - здесь ничего не изменилось
   pi/3072  2,3           17        5                  /-/ 1000 знаков  - этого аргумента наша оптимизация не коснулась

____________________________________________________________
Окончательный вывод.
Глобальный выигрыш по времени работы функции после всех оптимизаций - 5 раз (для самого сложного случая).
В дальнейшем можно попробовать создать нерегулярное решето из
диапазонов сжатия области определения функции.
Ожидаемый дополнительный выигрыш по времени - не более 30%.

Приложение. Таблица времён вычислений функции от различных аргументов
с точностью в 1000 знаков (без анализа)
____________________________________________________________
арг X        T (sec)
-------------------------------------------------------------
0,1          8,3
0,2          6,6
0,3          6,1
0,4          8,0
0,5          7,6
0,6          6,8
0,7          7,2
0,8          8,5
1,1          9,0
1,2          8,4
1,3          7,3
1,4          9,9
1,5          7,5
1,6          8,5
1,7          8,1
1,8          8,3
1,9          9,0
____________________________________________________________

}
  end;
    end; // case
end;


// Арккотангенс
function ArccotanZR(const ZR: ZReal ): ZReal;
begin
  MaxZNCount:=MaxZNCount+2;
  if ComparisonZR(ZR, DefaultZR)=0 then
    Result := PiDiv2_ZR
  else
// Result := ArcTan(1 / X);
  Result := ArctanZR(OneDivZR(ZR));
  MaxZNCount:=MaxZNCount-2;
end;


// Квадрат числа
function SqrZR(const ZR: ZReal ): ZReal;
begin
  MaxZNCount:=MaxZNCount+1;
  Result:=MultZR(ZR,ZR);
  MaxZNCount:=MaxZNCount-1;
end;


// знак числа ( - result: +1 or 0 or -1)
function GetUnaryZR(const ZR: ZReal): Shortint;
begin
  if ComparisonZR(ZR, DefaultZR)=0 then
  begin Result:=0 end
  else
  begin
    if (ZR.U='I') or (ZR.U='+') then Result:=1 else Result:=-1
  end;
end;


// Константа 2*PI  (Число из 1009 знаков)
function PiMult2_ZR: ZReal;
var
  strPiMult2:AnsiString;
begin
    strPiMult2:=
'62831853071795864769252867665590057683943387987502116419498891846156328125724'+
'17997256069650684234135964296173026564613294187689219101164463450718816256962'+
'23490056820540387704221111928924589790986076392885762195133186689225695129646'+
'75735663305424038182912971338469206972209086532964267872145204982825474491740'+
'13212631176349763041841925658508183430728735785180720022661061097640933042768'+
'29390388302321886611454073151918390618437223476386522358621023709614892475992'+
'54991347037715054497824558763660238982596673467248813132861720427898927904494'+
'74381404359721887405541078434352586353504769349636935338810264001136254290527'+
'12165557154268551557921834727435744293688180244990686029309917074210158455937'+
'85178470840399122242580439217280688363196272595495426199210374144226999999967'+
'45956099902119463465632192637190048918910693816605285044616506689370070523862'+
'37634202000627567750577317506641676284123435533829460719650698085751093746231'+
'91257277647075751875039155637155610643424536132260038557532223918184328403978761905144Z-1009';

// 62831853071795864769252867665590057683943387987502116419498891846156328125724179972560696506842341359642961730265646132941876892191011644634507188162569622349005682054038770422111192892458979098607639288576219513318668922569512964675735663305424038182912971338469206972209086532964267872145204982825474491740132126311763497630418419256585081834307287357851807200226610610976409330427682939038830232188661145407315191839061843722347638652235862102370961489247599254991347037715054497824558763660238982596673467248813132861720427898927904494743814043597218874055410784343525863535047693496369353388102640011362542905271216555715426855155792183472743574429368818024499068602930991707421015845593785178470840399122242580439217280688363196272595495426199210374144226999999967459560999021194634656321926371900489189106938166052850446165066893700705238623763420200062756775057731750664167628412343553382946071965069808575109374623191257277647075751875039155637155610643424536132260038557532223918184328403978761905144Z-1009
    Result := StrToZR(strPiMult2);// ZReal
end;

// Константа PI/2  (Число из 1000 знаков)
function PiDiv2_ZR: ZReal;
var
  strPiDiv2:AnsiString;
begin
//  Result:=DivZR(Pi_ZR,IntToZR(2));
    strPiDiv2:=
'15707963267948966192313216916397514420985846996875529104874722961539082031431'+
'04499314017412671058533991074043256641153323546922304775291115862679704064240'+
'55872514205135096926055277982231147447746519098221440548783296672306423782411'+
'68933915826356009545728242834617301743052271633241066968036301245706368622935'+
'03303157794087440760460481414627045857682183946295180005665265274410233260692'+
'07347597075580471652863518287979597654609305869096630589655255927403723118998'+
'13747836759428763624456139690915059745649168366812203283215430106974731976123'+
'68595351089930471851385269608588146588376192337409233834702566000284063572631'+
'78041389288567137889480458681858936073422045061247671507327479268552539613984'+
'46294617710099780560645109804320172090799068148873856549802593536056749999991'+
'86489024975529865866408048159297512229727673454151321261154126672342517630965'+
'59408550500156891937644329376660419071030858883457365179912674521437773436557'+
'97814319411768937968759788909288902660856134033065009639383055979546082100995Z-1000';

// 15707963267948966192313216916397514420985846996875529104874722961539082031431044993140174126710585339910740432566411533235469223047752911158626797040642405587251420513509692605527798223114744774651909822144054878329667230642378241168933915826356009545728242834617301743052271633241066968036301245706368622935033031577940874407604604814146270458576821839462951800056652652744102332606920734759707558047165286351828797959765460930586909663058965525592740372311899813747836759428763624456139690915059745649168366812203283215430106974731976123685953510899304718513852696085881465883761923374092338347025660002840635726317804138928856713788948045868185893607342204506124767150732747926855253961398446294617710099780560645109804320172090799068148873856549802593536056749999991864890249755298658664080481592975122297276734541513212611541266723425176309655940855050015689193764432937666041907103085888345736517991267452143777343655797814319411768937968759788909288902660856134033065009639383055979546082100995Z-1000
    Result := StrToZR(strPiDiv2);// ZReal
end;


// Константа PI/4  (Число из 1000 знаков)
function PiDiv4_ZR: ZReal;
var
  strPiDiv4:AnsiString;
begin
//  Result:=DivZR(Pi_ZR,IntToZR(4));
    strPiDiv4:=
'78539816339744830961566084581987572104929234984377645524373614807695410157155'+
'22496570087063355292669955370216283205766617734611523876455579313398520321202'+
'79362571025675484630276389911155737238732595491107202743916483361532118912058'+
'44669579131780047728641214173086508715261358166205334840181506228531843114675'+
'16515788970437203802302407073135229288410919731475900028326326372051166303460'+
'36737985377902358264317591439897988273046529345483152948276279637018615594990'+
'68739183797143818122280698454575298728245841834061016416077150534873659880618'+
'42976755449652359256926348042940732941880961687046169173512830001420317863158'+
'90206946442835689447402293409294680367110225306238357536637396342762698069922'+
'31473088550498902803225549021600860453995340744369282749012967680283749999959'+
'32445124877649329332040240796487561148638367270756606305770633361712588154827'+
'97042752500784459688221646883302095355154294417286825899563372607188867182789'+
'8907159705884468984379894454644451330428067016532504819691527989773041050498Z-1000';

// 7853981633974483096156608458198757210492923498437764552437361480769541015715522496570087063355292669955370216283205766617734611523876455579313398520321202793625710256754846302763899111557372387325954911072027439164833615321189120584466957913178004772864121417308650871526135816620533484018150622853184311467516515788970437203802302407073135229288410919731475900028326326372051166303460367379853779023582643175914398979882730465293454831529482762796370186155949906873918379714381812228069845457529872824584183406101641607715053487365988061842976755449652359256926348042940732941880961687046169173512830001420317863158902069464428356894474022934092946803671102253062383575366373963427626980699223147308855049890280322554902160086045399534074436928274901296768028374999995932445124877649329332040240796487561148638367270756606305770633361712588154827970427525007844596882216468833020953551542944172868258995633726071888671827898907159705884468984379894454644451330428067016532504819691527989773041050498Z-1000
    Result := StrToZR(strPiDiv4);// ZReal

end;

// Константа PI/6  (Число из 1000 знаков)
function PiDiv6_ZR: ZReal;
var
  strPiDiv6:AnsiString;
begin
//  Result:=DivZR(Pi_ZR,IntToZR(6));

    strPiDiv6:=
'52359877559829887307710723054658381403286156656251763682915743205130273438103'+
'48331046724708903528446636913477522137177745156407682584303719542265680214135'+
'19575047350450323086850926607437158159155063660738135162610988907688079274705'+
'63113052754520031819094142782057672476840905444136889893454337485687895409783'+
'44343859313624802534868271382090152858940613154317266685550884248034110868973'+
'57825323585268238842878394293265325515364352896988768632184186424679077063327'+
'12492789198095878748187132303050199152163894556040677610718100356582439920412'+
'28651170299768239504617565361960488627920641124697446115675220000946878575439'+
'26804630961890459631601528939529786911406816870825571691091597561841798713281'+
'54315392366999268535483699347733906969330227162912855166008645120189166666639'+
'54963416585099552888026827197658374099092244847171070870513755574475058769885'+
'31361835000522973125481097922201396903436196278191217266375581738125911455193'+
'2604773137256312656253262969762967553618711344355003213127685326515360700332Z-1000';

// 5235987755982988730771072305465838140328615665625176368291574320513027343810348331046724708903528446636913477522137177745156407682584303719542265680214135195750473504503230868509266074371581591550636607381351626109889076880792747056311305275452003181909414278205767247684090544413688989345433748568789540978344343859313624802534868271382090152858940613154317266685550884248034110868973578253235852682388428783942932653255153643528969887686321841864246790770633271249278919809587874818713230305019915216389455604067761071810035658243992041228651170299768239504617565361960488627920641124697446115675220000946878575439268046309618904596316015289395297869114068168708255716910915975618417987132815431539236699926853548369934773390696933022716291285516600864512018916666663954963416585099552888026827197658374099092244847171070870513755574475058769885313618350005229731254810979222013969034361962781912172663755817381259114551932604773137256312656253262969762967553618711344355003213127685326515360700332Z-1000
    Result := StrToZR(strPiDiv6);// ZReal
end;


// Константа PI/8  (Число из 1000 знаков)
function PiDiv8_ZR: ZReal;
var
  strPiDiv8:AnsiString;
begin
//  Result:=DivZR(Pi_ZR,IntToZR(8));
    strPiDiv8:=
'39269908169872415480783042290993786052464617492188822762186807403847705078577'+
'61248285043531677646334977685108141602883308867305761938227789656699260160601'+
'39681285512837742315138194955577868619366297745553601371958241680766059456029'+
'22334789565890023864320607086543254357630679083102667420090753114265921557337'+
'58257894485218601901151203536567614644205459865737950014163163186025583151730'+
'18368992688951179132158795719948994136523264672741576474138139818509307797495'+
'34369591898571909061140349227287649364122920917030508208038575267436829940309'+
'21488377724826179628463174021470366470940480843523084586756415000710158931579'+
'45103473221417844723701146704647340183555112653119178768318698171381349034961'+
'15736544275249451401612774510800430226997670372184641374506483840141874999979'+
'66222562438824664666020120398243780574319183635378303152885316680856294077413'+
'98521376250392229844110823441651047677577147208643412949781686303594433591394'+
'9453579852942234492189947227322225665214033508266252409845763994886520525249Z-1000';

// 3926990816987241548078304229099378605246461749218882276218680740384770507857761248285043531677646334977685108141602883308867305761938227789656699260160601396812855128377423151381949555778686193662977455536013719582416807660594560292233478956589002386432060708654325435763067908310266742009075311426592155733758257894485218601901151203536567614644205459865737950014163163186025583151730183689926889511791321587957199489941365232646727415764741381398185093077974953436959189857190906114034922728764936412292091703050820803857526743682994030921488377724826179628463174021470366470940480843523084586756415000710158931579451034732214178447237011467046473401835551126531191787683186981713813490349611573654427524945140161277451080043022699767037218464137450648384014187499997966222562438824664666020120398243780574319183635378303152885316680856294077413985213762503922298441108234416510476775771472086434129497816863035944335913949453579852942234492189947227322225665214033508266252409845763994886520525249Z-1000
    Result := StrToZR(strPiDiv8);// ZReal
end;

// Константа PI/12  (Число из 1000 знаков)
function PiDiv12_ZR: ZReal;
var
  strPiDiv12:AnsiString;
begin
//  Result:=DivZR(Pi_ZR,IntToZR(12));

    strPiDiv12:=
'26179938779914943653855361527329190701643078328125881841457871602565136719051'+
'74165523362354451764223318456738761068588872578203841292151859771132840107067'+
'59787523675225161543425463303718579079577531830369067581305494453844039637352'+
'81556526377260015909547071391028836238420452722068444946727168742843947704891'+
'72171929656812401267434135691045076429470306577158633342775442124017055434486'+
'78912661792634119421439197146632662757682176448494384316092093212339538531663'+
'56246394599047939374093566151525099576081947278020338805359050178291219960206'+
'14325585149884119752308782680980244313960320562348723057837610000473439287719'+
'63402315480945229815800764469764893455703408435412785845545798780920899356640'+
'77157696183499634267741849673866953484665113581456427583004322560094583333319'+
'77481708292549776444013413598829187049546122423585535435256877787237529384942'+
'65680917500261486562740548961100698451718098139095608633187790869062955727596'+
'6302386568628156328126631484881483776809355672177501606563842663257680350166Z-1000';

// 2617993877991494365385536152732919070164307832812588184145787160256513671905174165523362354451764223318456738761068588872578203841292151859771132840107067597875236752251615434254633037185790795775318303690675813054944538440396373528155652637726001590954707139102883623842045272206844494672716874284394770489172171929656812401267434135691045076429470306577158633342775442124017055434486789126617926341194214391971466326627576821764484943843160920932123395385316635624639459904793937409356615152509957608194727802033880535905017829121996020614325585149884119752308782680980244313960320562348723057837610000473439287719634023154809452298158007644697648934557034084354127858455457987809208993566407715769618349963426774184967386695348466511358145642758300432256009458333331977481708292549776444013413598829187049546122423585535435256877787237529384942656809175002614865627405489611006984517180981390956086331877908690629557275966302386568628156328126631484881483776809355672177501606563842663257680350166Z-1000
    Result := StrToZR(strPiDiv12);// ZReal
end;


// Константа PI/24  (Число из 1000 знаков)
function PiDiv24_ZR: ZReal;
var
  strPiDiv24:AnsiString;
begin
//  Result:=DivZR(Pi_ZR,IntToZR(24));

    strPiDiv24:=
'13089969389957471826927680763664595350821539164062940920728935801282568359525'+
'87082761681177225882111659228369380534294436289101920646075929885566420053533'+
'79893761837612580771712731651859289539788765915184533790652747226922019818676'+
'40778263188630007954773535695514418119210226361034222473363584371421973852445'+
'86085964828406200633717067845522538214735153288579316671387721062008527717243'+
'39456330896317059710719598573316331378841088224247192158046046606169769265831'+
'78123197299523969687046783075762549788040973639010169402679525089145609980103'+
'07162792574942059876154391340490122156980160281174361528918805000236719643859'+
'81701157740472614907900382234882446727851704217706392922772899390460449678320'+
'38578848091749817133870924836933476742332556790728213791502161280047291666659'+
'88740854146274888222006706799414593524773061211792767717628438893618764692471'+
'32840458750130743281370274480550349225859049069547804316593895434531477863798'+
'3151193284314078164063315742440741888404677836088750803281921331628840175083Z-1000';

// 1308996938995747182692768076366459535082153916406294092072893580128256835952587082761681177225882111659228369380534294436289101920646075929885566420053533798937618376125807717127316518592895397887659151845337906527472269220198186764077826318863000795477353569551441811921022636103422247336358437142197385244586085964828406200633717067845522538214735153288579316671387721062008527717243394563308963170597107195985733163313788410882242471921580460466061697692658317812319729952396968704678307576254978804097363901016940267952508914560998010307162792574942059876154391340490122156980160281174361528918805000236719643859817011577404726149079003822348824467278517042177063929227728993904604496783203857884809174981713387092483693347674233255679072821379150216128004729166665988740854146274888222006706799414593524773061211792767717628438893618764692471328404587501307432813702744805503492258590490695478043165938954345314778637983151193284314078164063315742440741888404677836088750803281921331628840175083Z-1000
    Result := StrToZR(strPiDiv24);// ZReal
end;


// Константа PI/50  (Число из 1000 знаков)
function PiDiv50_ZR: ZReal;
var
  strPiDiv50:AnsiString;
begin
//  Result:=DivZR(Pi_ZR,IntToZR(50));

    strPiDiv50:=
'62831853071795864769252867665590057683943387987502116419498891846156328125724'+
'17997256069650684234135964296173026564613294187689219101164463450718816256962'+
'23490056820540387704221111928924589790986076392885762195133186689225695129646'+
'75735663305424038182912971338469206972209086532964267872145204982825474491740'+
'13212631176349763041841925658508183430728735785180720022661061097640933042768'+
'29390388302321886611454073151918390618437223476386522358621023709614892475992'+
'54991347037715054497824558763660238982596673467248813132861720427898927904494'+
'74381404359721887405541078434352586353504769349636935338810264001136254290527'+
'12165557154268551557921834727435744293688180244990686029309917074210158455937'+
'85178470840399122242580439217280688363196272595495426199210374144226999999967'+
'45956099902119463465632192637190048918910693816605285044616506689370070523862'+
'37634202000627567750577317506641676284123435533829460719650698085751093746231'+
'9125727764707575187503915563715561064342453613226003855753222391818432840398Z-1001';

//6283185307179586476925286766559005768394338798750211641949889184615632812572417997256069650684234135964296173026564613294187689219101164463450718816256962234900568205403877042211119289245897909860763928857621951331866892256951296467573566330542403818291297133846920697220908653296426787214520498282547449174013212631176349763041841925658508183430728735785180720022661061097640933042768293903883023218866114540731519183906184372234763865223586210237096148924759925499134703771505449782455876366023898259667346724881313286172042789892790449474381404359721887405541078434352586353504769349636935338810264001136254290527121655571542685515579218347274357442936881802449906860293099170742101584559378517847084039912224258043921728068836319627259549542619921037414422699999996745956099902119463465632192637190048918910693816605285044616506689370070523862376342020006275677505773175066416762841234355338294607196506980857510937462319125727764707575187503915563715561064342453613226003855753222391818432840398Z-1001

    Result := StrToZR(strPiDiv50);// ZReal
end;


// Константа PI/100  (Число из 1000 знаков)
function PiDiv100_ZR: ZReal;
var
  strPiDiv100:AnsiString;
begin
//  Result:=DivZR(Pi_ZR,IntToZR(100));
    strPiDiv100:=
'31415926535897932384626433832795028841971693993751058209749445923078164062862'+
'08998628034825342117067982148086513282306647093844609550582231725359408128481'+
'11745028410270193852110555964462294895493038196442881097566593344612847564823'+
'37867831652712019091456485669234603486104543266482133936072602491412737245870'+
'06606315588174881520920962829254091715364367892590360011330530548820466521384'+
'14695194151160943305727036575959195309218611738193261179310511854807446237996'+
'27495673518857527248912279381830119491298336733624406566430860213949463952247'+
'37190702179860943702770539217176293176752384674818467669405132000568127145263'+
'56082778577134275778960917363717872146844090122495343014654958537105079227968'+
'92589235420199561121290219608640344181598136297747713099605187072113499999983'+
'72978049951059731732816096318595024459455346908302642522308253344685035261931'+
'18817101000313783875288658753320838142061717766914730359825349042875546873115'+
'95628638823537875937519577818577805321712268066130019278766111959092164201989380952572Z-1011';

//31415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572Z-1011

    Result := StrToZR(strPiDiv100);// ZReal
end;


// Константа PI/192  (Число из 1000 знаков)
function PiDiv192_ZR: ZReal;
var
  strPiDiv192:AnsiString;
begin
//  Result:=DivZR(Pi_ZR,IntToZR(192));
    strPiDiv192:=
'16362461737446839783659600954580744188526923955078676150911169751603210449407'+
'33853452101471532352639574035461725667868045361377400807594912356958025066917'+
'24867202297015725964640914564824111924735957393980667238315934033652524773345'+
'50972828985787509943466919619393022649012782951292778091704480464277467315557'+
'32607456035507750792146334806903172768418941610724145839234651327510659646554'+
'24320413620396324638399498216645414223551360280308990197557558257712211582289'+
'72653996624404962108808478844703187235051217048762711753349406361432012475128'+
'83953490718677574845192989175612652696225200351467951911148506250295899554824'+
'77126447175590768634875477793603058409814630272132991153466124238075562097900'+
'48223560114687271417338656046166845927915695988410267239377701600059114583324'+
'85926067682843610277508383499268241905966326514740959647035548617023455865589'+
'16050573437663429101712843100687936532323811336934755395742369293164347329747'+
'8938991605392597705079144678050927360505847295110938504102401664536050218854Z-1001';

//  1636246173744683978365960095458074418852692395507867615091116975160321044940733853452101471532352639574035461725667868045361377400807594912356958025066917248672022970157259646409145648241119247359573939806672383159340336525247733455097282898578750994346691961939302264901278295129277809170448046427746731555732607456035507750792146334806903172768418941610724145839234651327510659646554243204136203963246383994982166454142235513602803089901975575582577122115822897265399662440496210880847884470318723505121704876271175334940636143201247512883953490718677574845192989175612652696225200351467951911148506250295899554824771264471755907686348754777936030584098146302721329911534661242380755620979004822356011468727141733865604616684592791569598841026723937770160005911458332485926067682843610277508383499268241905966326514740959647035548617023455865589160505734376634291017128431006879365323238113369347553957423692931643473297478938991605392597705079144678050927360505847295110938504102401664536050218854Z-1001
    Result := StrToZR(strPiDiv192);// ZReal
end;


// Константа PI/384  (Число из 1000 знаков)
function PiDiv384_ZR: ZReal;
var
  strPiDiv384:AnsiString;
begin
//  Result:=DivZR(Pi_ZR,IntToZR(384));

    strPiDiv384:=
'81812308687234198918298004772903720942634619775393380754555848758016052247036'+
'69267260507357661763197870177308628339340226806887004037974561784790125334586'+
'24336011485078629823204572824120559623679786969903336191579670168262623866727'+
'54864144928937549717334598096965113245063914756463890458522402321387336577786'+
'63037280177538753960731674034515863842094708053620729196173256637553298232771'+
'21602068101981623191997491083227071117756801401544950987787791288561057911448'+
'63269983122024810544042394223515936175256085243813558766747031807160062375644'+
'19767453593387874225964945878063263481126001757339759555742531251479497774123'+
'85632235877953843174377388968015292049073151360664955767330621190377810489502'+
'41117800573436357086693280230834229639578479942051336196888508000295572916624'+
'29630338414218051387541917496341209529831632573704798235177743085117279327945'+
'80252867188317145508564215503439682661619056684673776978711846465821736648739'+
'4694958026962988525395723390254636802529236475554692520512008322680251094268Z-1002';

//  8181230868723419891829800477290372094263461977539338075455584875801605224703669267260507357661763197870177308628339340226806887004037974561784790125334586243360114850786298232045728241205596236797869699033361915796701682626238667275486414492893754971733459809696511324506391475646389045852240232138733657778663037280177538753960731674034515863842094708053620729196173256637553298232771216020681019816231919974910832270711177568014015449509877877912885610579114486326998312202481054404239422351593617525608524381355876674703180716006237564419767453593387874225964945878063263481126001757339759555742531251479497774123856322358779538431743773889680152920490731513606649557673306211903778104895024111780057343635708669328023083422963957847994205133619688850800029557291662429630338414218051387541917496341209529831632573704798235177743085117279327945802528671883171455085642155034396826616190566846737769787118464658217366487394694958026962988525395723390254636802529236475554692520512008322680251094268Z-1002
    Result := StrToZR(strPiDiv384);// ZReal
end;


// Константа PI/1536  (Число из 1000 знаков)
function PiDiv1536_ZR: ZReal;
var
  strPiDiv1536:AnsiString;
begin
//  Result:=DivZR(Pi_ZR,IntToZR(1536));

    strPiDiv1536:=
'20453077171808549729574501193225930235658654943848345188638962189504013061759'+
'17316815126839415440799467544327157084835056701721751009493640446197531333646'+
'56084002871269657455801143206030139905919946742475834047894917542065655966681'+
'88716036232234387429333649524241278311265978689115972614630600580346834144446'+
'65759320044384688490182918508628965960523677013405182299043314159388324558192'+
'80400517025495405797999372770806767779439200350386237746946947822140264477862'+
'15817495780506202636010598555878984043814021310953389691686757951790015593911'+
'04941863398346968556491236469515815870281500439334939888935632812869874443530'+
'96408058969488460793594347242003823012268287840166238941832655297594452622375'+
'60279450143359089271673320057708557409894619985512834049222127000073893229156'+
'07407584603554512846885479374085302382457908143426199558794435771279319831986'+
'45063216797079286377141053875859920665404764171168444244677961616455434162184'+
'8673739506740747131348930847563659200632309118888673130128002080670062773567Z-1002';

// 2045307717180854972957450119322593023565865494384834518863896218950401306175917316815126839415440799467544327157084835056701721751009493640446197531333646560840028712696574558011432060301399059199467424758340478949175420656559666818871603623223438742933364952424127831126597868911597261463060058034683414444665759320044384688490182918508628965960523677013405182299043314159388324558192804005170254954057979993727708067677794392003503862377469469478221402644778621581749578050620263601059855587898404381402131095338969168675795179001559391104941863398346968556491236469515815870281500439334939888935632812869874443530964080589694884607935943472420038230122682878401662389418326552975944526223756027945014335908927167332005770855740989461998551283404922212700007389322915607407584603554512846885479374085302382457908143426199558794435771279319831986450632167970792863771410538758599206654047641711684442446779616164554341621848673739506740747131348930847563659200632309118888673130128002080670062773567Z-1002
    Result := StrToZR(strPiDiv1536);// ZReal
end;


// Константа PI/3072  (Число из 1000 знаков)
function PiDiv3072_ZR: ZReal;
var
  strPiDiv3072:AnsiString;
begin
//  Result:=DivZR(Pi_ZR,IntToZR(3072));

    strPiDiv3072:=
'10226538585904274864787250596612965117829327471924172594319481094752006530879'+
'58658407563419707720399733772163578542417528350860875504746820223098765666823'+
'28042001435634828727900571603015069952959973371237917023947458771032827983340'+
'94358018116117193714666824762120639155632989344557986307315300290173417072223'+
'32879660022192344245091459254314482980261838506702591149521657079694162279096'+
'40200258512747702898999686385403383889719600175193118873473473911070132238931'+
'07908747890253101318005299277939492021907010655476694845843378975895007796955'+
'52470931699173484278245618234757907935140750219667469944467816406434937221765'+
'48204029484744230396797173621001911506134143920083119470916327648797226311187'+
'80139725071679544635836660028854278704947309992756417024611063500036946614578'+
'03703792301777256423442739687042651191228954071713099779397217885639659915993'+
'22531608398539643188570526937929960332702382085584222122338980808227717081092'+
'43368697533703735656744654237818296003161545594443365650640010403350313867835Z-1003';

// 10226538585904274864787250596612965117829327471924172594319481094752006530879586584075634197077203997337721635785424175283508608755047468202230987656668232804200143563482872790057160301506995295997337123791702394745877103282798334094358018116117193714666824762120639155632989344557986307315300290173417072223328796600221923442450914592543144829802618385067025911495216570796941622790964020025851274770289899968638540338388971960017519311887347347391107013223893107908747890253101318005299277939492021907010655476694845843378975895007796955524709316991734842782456182347579079351407502196674699444678164064349372217654820402948474423039679717362100191150613414392008311947091632764879722631118780139725071679544635836660028854278704947309992756417024611063500036946614578037037923017772564234427396870426511912289540717130997793972178856396599159932253160839853964318857052693792996033270238208558422212233898080822771708109243368697533703735656744654237818296003161545594443365650640010403350313867835Z-1003
    Result := StrToZR(strPiDiv3072);// ZReal
end;


// Константа PI/12288  (Число из 1000 знаков)
function PiDiv12288_ZR: ZReal;
var
  strPiDiv12288:AnsiString;
begin
//  Result:=DivZR(Pi_ZR,IntToZR(12288));

    strPiDiv12288:=
'25566346464760687161968126491532412794573318679810431485798702736880016327198'+
'96646018908549269300999334430408946356043820877152188761867050557746914167058'+
'20105003589087071819751429007537674882399933428094792559868646927582069958352'+
'35895045290292984286667061905301597889082473361394965768288250725433542680558'+
'32199150055480860612728648135786207450654596266756477873804142699235405697741'+
'00500646281869257247499215963508459724299000437982797183683684777675330597327'+
'69771869725632753295013248194848730054767526638691737114608447439737519492388'+
'81177329247933710695614045586894769837851875549168674861169541016087343054413'+
'70510073711860575991992934052504778765335359800207798677290819121993065777969'+
'50349312679198861589591650072135696762368274981891042561527658750092366536445'+
'09259480754443141058606849217606627978072385179282749448493044714099149789983'+
'06329020996349107971426317344824900831755955213960555305847452020569292702731'+
'0842174383425933914186163559454574000790386398610841412660002600837578466959Z-1003';

// 2556634646476068716196812649153241279457331867981043148579870273688001632719896646018908549269300999334430408946356043820877152188761867050557746914167058201050035890870718197514290075376748823999334280947925598686469275820699583523589504529029298428666706190530159788908247336139496576828825072543354268055832199150055480860612728648135786207450654596266756477873804142699235405697741005006462818692572474992159635084597242990004379827971836836847776753305973276977186972563275329501324819484873005476752663869173711460844743973751949238881177329247933710695614045586894769837851875549168674861169541016087343054413705100737118605759919929340525047787653353598002077986772908191219930657779695034931267919886158959165007213569676236827498189104256152765875009236653644509259480754443141058606849217606627978072385179282749448493044714099149789983063290209963491079714263173448249008317559552139605553058474520205692927027310842174383425933914186163559454574000790386398610841412660002600837578466959Z-1003
    Result := StrToZR(strPiDiv12288);// ZReal
end;

// Константа PI/24576  (Число из 1000 знаков)
function PiDiv24576_ZR: ZReal;
var
  strPiDiv24576:AnsiString;
begin
//  Result:=DivZR(Pi_ZR,IntToZR(24576));

    strPiDiv24576:=
'12783173232380343580984063245766206397286659339905215742899351368440008163599'+
'48323009454274634650499667215204473178021910438576094380933525278873457083529'+
'10052501794543535909875714503768837441199966714047396279934323463791034979176'+
'17947522645146492143333530952650798944541236680697482884144125362716771340279'+
'16099575027740430306364324067893103725327298133378238936902071349617702848870'+
'50250323140934628623749607981754229862149500218991398591841842388837665298663'+
'84885934862816376647506624097424365027383763319345868557304223719868759746194'+
'40588664623966855347807022793447384918925937774584337430584770508043671527206'+
'85255036855930287995996467026252389382667679900103899338645409560996532888984'+
'75174656339599430794795825036067848381184137490945521280763829375046183268222'+
'54629740377221570529303424608803313989036192589641374724246522357049574894991'+
'53164510498174553985713158672412450415877977606980277652923726010284646351365'+
'5421087191712966957093081779727287000395193199305420706330001300418789233479Z-1003';

// 1278317323238034358098406324576620639728665933990521574289935136844000816359948323009454274634650499667215204473178021910438576094380933525278873457083529100525017945435359098757145037688374411999667140473962799343234637910349791761794752264514649214333353095265079894454123668069748288414412536271677134027916099575027740430306364324067893103725327298133378238936902071349617702848870502503231409346286237496079817542298621495002189913985918418423888376652986638488593486281637664750662409742436502738376331934586855730422371986875974619440588664623966855347807022793447384918925937774584337430584770508043671527206852550368559302879959964670262523893826676799001038993386454095609965328889847517465633959943079479582503606784838118413749094552128076382937504618326822254629740377221570529303424608803313989036192589641374724246522357049574894991531645104981745539857131586724124504158779776069802776529237260102846463513655421087191712966957093081779727287000395193199305420706330001300418789233479Z-1003

    Result := StrToZR(strPiDiv24576);// ZReal
end;

// Константа PI/196608  (Число из 1000 знаков)
function PiDiv196608_ZR: ZReal;
var
  strPiDiv196608:AnsiString;
begin
//  Result:=DivZR(Pi_ZR,IntToZR(196608));

    strPiDiv196608:=
'15978966540475429476230079057207757996608324174881519678624189210550010204499'+
'35403761817843293313124584019005591472527388048220117976166906598591821354411'+
'37565627243179419887344643129711046801499958392559245349917904329738793723970'+
'22434403306433115179166913690813498680676545850871853605180156703395964175348'+
'95124468784675537882955405084866379656659122666722798671127589187022128561088'+
'12812903926168285779687009977192787327686875273739248239802302986047081623329'+
'81107418578520470809383280121780456284229704149182335696630279649835949682743'+
'00735830779958569184758778491809231148657422218230421788230963135054589409008'+
'56568796069912859994995583782815486728334599875129874173306761951245666111230'+
'93968320424499288493494781295084810476480171863681901600954786718807729085278'+
'18287175471526963161629280761004142486295240737051718405308152946311968618739'+
'41455638122718192482141448340515563019847472008725347066154657512855807939206'+
'9276358989641208696366352224659108750493991499131775882912501625523486541849Z-1004';

// 1597896654047542947623007905720775799660832417488151967862418921055001020449935403761817843293313124584019005591472527388048220117976166906598591821354411375656272431794198873446431297110468014999583925592453499179043297387937239702243440330643311517916691369081349868067654585087185360518015670339596417534895124468784675537882955405084866379656659122666722798671127589187022128561088128129039261682857796870099771927873276868752737392482398023029860470816233298110741857852047080938328012178045628422970414918233569663027964983594968274300735830779958569184758778491809231148657422218230421788230963135054589409008565687960699128599949955837828154867283345998751298741733067619512456661112309396832042449928849349478129508481047648017186368190160095478671880772908527818287175471526963161629280761004142486295240737051718405308152946311968618739414556381227181924821414483405155630198474720087253470661546575128558079392069276358989641208696366352224659108750493991499131775882912501625523486541849Z-1004

    Result := StrToZR(strPiDiv196608);// ZReal
end;

// Константа PI/393216  (Число из 1000 знаков)
function PiDiv393216_ZR: ZReal;
var
  strPiDiv393216:AnsiString;
begin
//  Result:=DivZR(Pi_ZR,IntToZR(393216));

    strPiDiv393216:=
'79894832702377147381150395286038789983041620874407598393120946052750051022496'+
'77018809089216466565622920095027957362636940241100589880834532992959106772056'+
'87828136215897099436723215648555234007499791962796226749589521648693968619851'+
'12172016532165575895834568454067493403382729254359268025900783516979820876744'+
'75622343923377689414777025424331898283295613333613993355637945935110642805440'+
'64064519630841428898435049885963936638434376368696241199011514930235408116649'+
'05537092892602354046916400608902281421148520745911678483151398249179748413715'+
'03679153899792845923793892459046155743287111091152108941154815675272947045042'+
'82843980349564299974977918914077433641672999375649370866533809756228330556154'+
'69841602122496442467473906475424052382400859318409508004773933594038645426390'+
'91435877357634815808146403805020712431476203685258592026540764731559843093697'+
'07278190613590962410707241702577815099237360043626735330773287564279039696034'+
'6381794948206043481831761123295543752469957495658879414562508127617432709246Z-1005';

// 7989483270237714738115039528603878998304162087440759839312094605275005102249677018809089216466565622920095027957362636940241100589880834532992959106772056878281362158970994367232156485552340074997919627962267495895216486939686198511217201653216557589583456845406749340338272925435926802590078351697982087674475622343923377689414777025424331898283295613333613993355637945935110642805440640645196308414288984350498859639366384343763686962411990115149302354081166490553709289260235404691640060890228142114852074591167848315139824917974841371503679153899792845923793892459046155743287111091152108941154815675272947045042828439803495642999749779189140774336416729993756493708665338097562283305561546984160212249644246747390647542405238240085931840950800477393359403864542639091435877357634815808146403805020712431476203685258592026540764731559843093697072781906135909624107072417025778150992373600436267353307732875642790396960346381794948206043481831761123295543752469957495658879414562508127617432709246Z-1005

    Result := StrToZR(strPiDiv393216);// ZReal
end;


// Константа sqrt(2)  (Число из 1000 знаков)
function Sqrt2_ZR: ZReal;
var
  strSqrtTwo:AnsiString;
begin
    strSqrtTwo:=
'14142135623730950488016887242096980785696718753769480731766797379907324784621'+
'07038850387534327641572735013846230912297024924836055850737212644121497099935'+
'83141322266592750559275579995050115278206057147010955997160597027453459686201'+
'47285174186408891986095523292304843087143214508397626036279952514079896872533'+
'96546331808829640620615258352395054745750287759961729835575220337531857011354'+
'37460340849884716038689997069900481503054402779031645424782306849293691862158'+
'05784631115966687130130156185689872372352885092648612494977154218334204285686'+
'06014682472077143585487415565706967765372022648544701585880162075847492265722'+
'60020855844665214583988939443709265918003113882464681570826301005948587040031'+
'86480342194897278290641045072636881313739855256117322040245091227700226941127'+
'57362728049573810896750401836986836845072579936472906076299694138047565482372'+
'89971803268024744206292691248590521810044598421505911202494413417285314781058'+
'0360337107730918286931471017111168391658172688941975871658215212822951848847Z-999';

//  1414213562373095048801688724209698078569671875376948073176679737990732478462107038850387534327641572735013846230912297024924836055850737212644121497099935831413222665927505592755799950501152782060571470109559971605970274534596862014728517418640889198609552329230484308714321450839762603627995251407989687253396546331808829640620615258352395054745750287759961729835575220337531857011354374603408498847160386899970699004815030544027790316454247823068492936918621580578463111596668713013015618568987237235288509264861249497715421833420428568606014682472077143585487415565706967765372022648544701585880162075847492265722600208558446652145839889394437092659180031138824646815708263010059485870400318648034219489727829064104507263688131373985525611732204024509122770022694112757362728049573810896750401836986836845072579936472906076299694138047565482372899718032680247442062926912485905218100445984215059112024944134172853147810580360337107730918286931471017111168391658172688941975871658215212822951848847Z-999
    Result := StrToZR(strSqrtTwo);// ZReal
end;


// Константа sqrt(3)  (Число из 1000 знаков)
function Sqrt3_ZR: ZReal;
var
  strSqrtThree:AnsiString;
begin
    strSqrtThree:=
'17320508075688772935274463415058723669428052538103806280558069794519330169088'+
'00037081146186757248575675626141415406703029969945094998952478811655512094373'+
'64852809323190230558206797482010108467492326501531234326690332288665067225466'+
'89218379712270471316603678615880190499865373798593894676503475065760507566183'+
'48129606100947602187190325083145829523959832997789824508288714463832917347224'+
'16398458785539766795806381835366611084317378089437831610208830552490167002352'+
'07111442886959909563657970871684980728994932964842830207864086039887386975375'+
'82317317831395992983007838702877053913369563312103707264019249106768231199288'+
'37564114142201674275210237299427083105989845947598766428889779614783795839022'+
'88548529035760338528080643819723446610596897228728652641538226646984200211954'+
'84155278441181286534507035191650016689294415480846071277143999762926834629577'+
'43836189511012714863874697654598245178855097537901388066496191196222295711055'+
'5242923723192197738262561631468842032853716682938649611917049738836395495938Z-999';

//  1732050807568877293527446341505872366942805253810380628055806979451933016908800037081146186757248575675626141415406703029969945094998952478811655512094373648528093231902305582067974820101084674923265015312343266903322886650672254668921837971227047131660367861588019049986537379859389467650347506576050756618348129606100947602187190325083145829523959832997789824508288714463832917347224163984587855397667958063818353666110843173780894378316102088305524901670023520711144288695990956365797087168498072899493296484283020786408603988738697537582317317831395992983007838702877053913369563312103707264019249106768231199288375641141422016742752102372994270831059898459475987664288897796147837958390228854852903576033852808064381972344661059689722872865264153822664698420021195484155278441181286534507035191650016689294415480846071277143999762926834629577438361895110127148638746976545982451788550975379013880664961911962222957110555242923723192197738262561631468842032853716682938649611917049738836395495938Z-999
    Result := StrToZR(strSqrtThree);// ZReal
end;


// Константа 1/tg(pi/12) = 1/(2-sqrt(3))  (Число из 1000 знаков)
function OdTgPId12_ZR: ZReal;
// Константа используется для вычисления АркТангенса
var
  strOdTssT:AnsiString;
begin
//    Result := OneDivZR(SubZR(TwoZR,Sqrt3_ZR)); // применена табличная формула Тангенса

    strOdTssT:=
'37320508075688772935274463415058723669428052538103806280558069794519330169088'+
'00037081146186757248575675626141415406703029969945094998952478811655512094373'+
'64852809323190230558206797482010108467492326501531234326690332288665067225466'+
'89218379712270471316603678615880190499865373798593894676503475065760507566183'+
'48129606100947602187190325083145829523959832997789824508288714463832917347224'+
'16398458785539766795806381835366611084317378089437831610208830552490167002352'+
'07111442886959909563657970871684980728994932964842830207864086039887386975375'+
'82317317831395992983007838702877053913369563312103707264019249106768231199288'+
'37564114142201674275210237299427083105989845947598766428889779614783795839022'+
'88548529035760338528080643819723446610596897228728652641538226646984200211954'+
'84155278441181286534507035191650016689294415480846071277143999762926834629577'+
'43836189511012714863874697654598245178855097537901388066496191196222295711055'+
'5242923723192197738262561631468842032853716682938649611917049738836395495936Z-999';

//  3732050807568877293527446341505872366942805253810380628055806979451933016908800037081146186757248575675626141415406703029969945094998952478811655512094373648528093231902305582067974820101084674923265015312343266903322886650672254668921837971227047131660367861588019049986537379859389467650347506576050756618348129606100947602187190325083145829523959832997789824508288714463832917347224163984587855397667958063818353666110843173780894378316102088305524901670023520711144288695990956365797087168498072899493296484283020786408603988738697537582317317831395992983007838702877053913369563312103707264019249106768231199288375641141422016742752102372994270831059898459475987664288897796147837958390228854852903576033852808064381972344661059689722872865264153822664698420021195484155278441181286534507035191650016689294415480846071277143999762926834629577438361895110127148638746976545982451788550975379013880664961911962222957110555242923723192197738262561631468842032853716682938649611917049738836395495936Z-999
    Result := StrToZR(strOdTssT);// ZReal
end;


// Константа 1/tg(pi/50)    (Число из 1000 знаков)
function OdTgPId50_ZR: ZReal;
// Константа используется для вычисления АркТангенса
var
  strOdTgPId50:AnsiString;
//  BakMaxZNCount:Integer;
begin
{
  BakMaxZNCount:=MaxZNCount;
  MaxZNCount:=MaxZNCount+3;
    Result := OneDivZR(TanZR(PiDiv50_ZR));
  MaxZNCount:=BakMaxZNCount;
    Exit;
}

    strOdTgPId50:=
'15894544843865303445760369399703974690059742372666480503465020948417649841077'+
'58320081824593326016657475266129390444007608907151979681909002960574649023445'+
'58675692063733263010195798472356781946959533341751508457018056138289459107311'+
'79428768797464171572464861285869165009289373379800499807475036001608945385135'+
'24076301281560795948742450238321769941383799629470743144584027166019235860176'+
'13628560174602172406316531189768259762134160325598035186239290294081147466556'+
'04397983717080426568236596435361079408279403775529740150745376842572216713548'+
'97876077553814321824913252976927347776296627400603766707044353364955506611028'+
'78649078165086631152906162867907681091451551684396289138075658990268865873513'+
'22722388063717083303118211405736314794427342728516295013623937179531701318378'+
'96881750211611604886549373071112944873265985032848061398615617252325044748472'+
'48604960722458372522622484994582627612342529033833864816460296768103088493332'+
'8984996690027668533624561880964794581654684530342627749240119829676980991504Z-998';

//  1589454484386530344576036939970397469005974237266648050346502094841764984107758320081824593326016657475266129390444007608907151979681909002960574649023445586756920637332630101957984723567819469595333417515084570180561382894591073117942876879746417157246486128586916500928937337980049980747503600160894538513524076301281560795948742450238321769941383799629470743144584027166019235860176136285601746021724063165311897682597621341603255980351862392902940811474665560439798371708042656823659643536107940827940377552974015074537684257221671354897876077553814321824913252976927347776296627400603766707044353364955506611028786490781650866311529061628679076810914515516843962891380756589902688658735132272238806371708330311821140573631479442734272851629501362393717953170131837896881750211611604886549373071112944873265985032848061398615617252325044748472486049607224583725226224849945826276123425290338338648164602967681030884933328984996690027668533624561880964794581654684530342627749240119829676980991504Z-998
    Result := StrToZR(strOdTgPId50);// ZReal
end;


// Константа 1/tg(pi/192)    (Число из 1000 знаков)
function OdTgPId192_ZR: ZReal;
// Константа используется для вычисления АркТангенса
var
  strOdTgPId192:AnsiString;
//  BakMaxZNCount:Integer;
begin
{
  BakMaxZNCount:=MaxZNCount;
  MaxZNCount:=MaxZNCount+3;
    Result := OneDivZR(TanZR(PiDiv192_ZR));
  MaxZNCount:=BakMaxZNCount;
    Exit;
}
    strOdTgPId192:=
'61110043896023413194013386999291355071708300580767716074632275916966295096091'+
'58447097315617631988024617192397089175192345159882416830151019445174666341564'+
'67958542483279203837013295120357258193942391566569945807406429556008573657391'+
'42234575476299914274253498475128573246840900732381455242168380034834043147685'+
'13678864722796902840571214742671867885187618545653854526083763781199450030056'+
'66898169831773253954839312937552579465277136698150314165184512025300969265376'+
'64649192767502986808765662138974942244403518548743568707517013315079476514471'+
'63528904421735661560938449474189133814318385325317545003940726793819576295714'+
'74485269037837619886074538779992206299862743768811403885754718985046850539706'+
'74858902132542562418117123405872031416778779666953267753135562647939621906414'+
'94806060584971212087460398605986527136641736413274983558429422059286817558803'+
'57559040020005956031734131851057585315924443960536256221506478923384715583366'+
'4561209792096200464463551832794261387638985875805262684072013378960850878482Z-998';

//  6111004389602341319401338699929135507170830058076771607463227591696629509609158447097315617631988024617192397089175192345159882416830151019445174666341564679585424832792038370132951203572581939423915665699458074064295560085736573914223457547629991427425349847512857324684090073238145524216838003483404314768513678864722796902840571214742671867885187618545653854526083763781199450030056668981698317732539548393129375525794652771366981503141651845120253009692653766464919276750298680876566213897494224440351854874356870751701331507947651447163528904421735661560938449474189133814318385325317545003940726793819576295714744852690378376198860745387799922062998627437688114038857547189850468505397067485890213254256241811712340587203141677877966695326775313556264793962190641494806060584971212087460398605986527136641736413274983558429422059286817558803575590400200059560317341318510575853159244439605362562215064789233847155833664561209792096200464463551832794261387638985875805262684072013378960850878482Z-998

    Result := StrToZR(strOdTgPId192);// ZReal
end;


// Константа 1/tg(pi/1536)   (Число из 1000 знаков)
function OdTgPId1536_ZR: ZReal;
// Константа используется для вычисления АркТангенса
var
  strOdTgPId1536:AnsiString;
//  BakMaxZNCount:Integer;
begin
{
  BakMaxZNCount:=MaxZNCount;
  MaxZNCount:=MaxZNCount+3;
    Result := OneDivZR(TanZR(PiDiv1536_ZR));
  MaxZNCount:=BakMaxZNCount;
    Exit;
}
    strOdTgPId1536:=
'48892330340887327551351766822959109846127974474901327001817321186329037958799'+
'64009217713272489634579383742410067063997093906951171283627264983225026087807'+
'78071162043048287013991071293258515769214987293135653640407132874978998547362'+
'24222729670260996205962018451259659445654657343627838856031818856154233888870'+
'11711634329286715453137726512272826977812571353346163053938883395997157211169'+
'48815688061589164962444607807949420379657538153239628085364743833561932043572'+
'25664040887355354136695532693029135108894818667712853176318060154521910947507'+
'58443098287606144941159555124203873106083646439330231795353369399596795565584'+
'57185655512245039559092043956004177313610932694769457562665617422609874778022'+
'93998857886692546978481896427863898230716469931116654685799741160990015672185'+
'93079575931682259710109276942230280305807786428116513949225659562516842085249'+
'17945658696699506975982091281827315062409005469159967311127044797017435359882'+
'4910427978496982555149617096597426022557860880096078334589174254283507600457Z-997';

//  4889233034088732755135176682295910984612797447490132700181732118632903795879964009217713272489634579383742410067063997093906951171283627264983225026087807780711620430482870139910712932585157692149872931356536404071328749789985473622422272967026099620596201845125965944565465734362783885603181885615423388887011711634329286715453137726512272826977812571353346163053938883395997157211169488156880615891649624446078079494203796575381532396280853647438335619320435722566404088735535413669553269302913510889481866771285317631806015452191094750758443098287606144941159555124203873106083646439330231795353369399596795565584571856555122450395590920439560041773136109326947694575626656174226098747780229399885788669254697848189642786389823071646993111665468579974116099001567218593079575931682259710109276942230280305807786428116513949225659562516842085249179456586966995069759820912818273150624090054691599673111270447970174353598824910427978496982555149617096597426022557860880096078334589174254283507600457Z-997
    Result := StrToZR(strOdTgPId1536);// ZReal
end;


// Константа 1/tg(pi/12288)   (Число из 1000 знаков)
function OdTgPId12288_ZR: ZReal;
// Константа используется для вычисления АркТангенса
var
  strOdTgPId12288:AnsiString;
//  BakMaxZNCount:Integer;
begin
{
  BakMaxZNCount:=MaxZNCount;
  MaxZNCount:=MaxZNCount+3;
    Result := OneDivZR(TanZR(PiDiv12288_ZR));
  MaxZNCount:=BakMaxZNCount;
    Exit;
}
    strOdTgPId12288:=
'39113917962052645179618522955873829070452399683327642063920568180319969241287'+
'97759447457554238145720045139046754061110346246958382639712369928470592379397'+
'22367854568357663919137465062182669982942498227739805901020081213625615796487'+
'58537896268641257414164225170208249035547852261742738973960197868757872780487'+
'03284102307474879523637271269315537366303365883873611697084424328836327875753'+
'28983200936318787351154176352537921583863332095057654628179101486113478087132'+
'20202854278278106537889968312967261377517469918749222528994129321001365683914'+
'21001864008216144483736050378324069409706042441364451737647853674461125897815'+
'97023606728820853490569730265500703238312265838633410575216082412661479169252'+
'36181347323132749209492891494213039614565832803626728473868951303106338634259'+
'11451576155978423884130156935785081852840377196514168680835947371163229664934'+
'56048831060295256881290470825233277554793542096156348406710994684101197290391'+
'8072729815238328376240253439743923349629612925278663012317635008235665668576Z-996';

//  3911391796205264517961852295587382907045239968332764206392056818031996924128797759447457554238145720045139046754061110346246958382639712369928470592379397223678545683576639191374650621826699829424982277398059010200812136256157964875853789626864125741416422517020824903554785226174273897396019786875787278048703284102307474879523637271269315537366303365883873611697084424328836327875753289832009363187873511541763525379215838633320950576546281791014861134780871322020285427827810653788996831296726137751746991874922252899412932100136568391421001864008216144483736050378324069409706042441364451737647853674461125897815970236067288208534905697302655007032383122658386334105752160824126614791692523618134732313274920949289149421303961456583280362672847386895130310633863425911451576155978423884130156935785081852840377196514168680835947371163229664934560488310602952568812904708252332775547935420961563484067109946841011972903918072729815238328376240253439743923349629612925278663012317635008235665668576Z-996
    Result := StrToZR(strOdTgPId12288);// ZReal
end;


// Константа 1/tg(pi/196608)   (Число из 1000 знаков)
function OdTgPId196608_ZR: ZReal;
// Константа используется для вычисления АркТангенса
var
  strOdTgPId196608:AnsiString;
//  BakMaxZNCount:Integer;
begin
{
  BakMaxZNCount:=MaxZNCount;
  MaxZNCount:=MaxZNCount+3;
    Result := OneDivZR(TanZR(PiDiv196608_ZR));
  MaxZNCount:=BakMaxZNCount;
    Exit;
}
    strOdTgPId196608:=
'62582270097496394169448257683334644552397156192155750275181565682819196741677'+
'64235139669157159031252440700894073067682932013126473974666869957521585646342'+
'08339583991071602504122205467316359894074426749133970473359682179868078467811'+
'96312291326299867571357316240176331818877440043821274819967907623011528653206'+
'74130097477284453711160014318313154162600452279833142207350946531271003237098'+
'80325827358345892357948009281530136572441580504704260739600029565540512758715'+
'08665504971229649729897200681422510958011589099992036855167088572142107395225'+
'04757517979034804081715742909532728192963189341937741346456366741926217738717'+
'47450302217147980581929426527752759075030722325961508162251058252198708715288'+
'71195139865422277232847573698629563809663237344702250324050168740727637186204'+
'45691844475787822120105405834660525738248033169505235021671594629234714031539'+
'89571080138866697793262793717113321670626312341353149320477493334167485539171'+
'7371665167625539947116500001090034078198812845658021465676480105786731042439Z-995';

//  6258227009749639416944825768333464455239715619215575027518156568281919674167764235139669157159031252440700894073067682932013126473974666869957521585646342083395839910716025041222054673163598940744267491339704733596821798680784678119631229132629986757135731624017633181887744004382127481996790762301152865320674130097477284453711160014318313154162600452279833142207350946531271003237098803258273583458923579480092815301365724415805047042607396000295655405127587150866550497122964972989720068142251095801158909999203685516708857214210739522504757517979034804081715742909532728192963189341937741346456366741926217738717474503022171479805819294265277527590750307223259615081622510582521987087152887119513986542227723284757369862956380966323734470225032405016874072763718620445691844475787822120105405834660525738248033169505235021671594629234714031539895710801388666977932627937171133216706263123413531493204774933341674855391717371665167625539947116500001090034078198812845658021465676480105786731042439Z-995
    Result := StrToZR(strOdTgPId196608);// ZReal
end;


// Тангенс
function TanZR(const ZR: ZReal): ZReal;
var
  BakMaxZNCount:Cardinal;
  metod:Byte;
  ZR1, ZR2: ZReal;
  i,n,k :Integer;
  sinus,cosin: ZReal;
begin
// контрольное условие
  if MaxZNCount=0 then MaxZNCount:=1;
  if InfZNCount<MaxZNCount then InfZNCount:=MaxZNCount;

  if EqvToZR(ZR,DefaultZR) then begin Result:=DefaultZR; Exit; end; // Избегаем холостой счёт

   metod:=1; //---! ! !--- Выберите метод приближённого вычисления Арктангенса
// 0 - метод цепной дроби для аргумента меньше, чем |pi/8|
// 1 - универсальный метод: tanZR = Sin(X) / Cos(X) (через процедуру SinCosZR)
    case metod of

0:begin
//  метод цепной дроби  tan(x) = x/(1-x^2/(3-x^2/(5-x^2/(7-x^2/...)))).
  BakMaxZNCount:=MaxZNCount;
  MaxZNCount:=MaxZNCount+4;

  n:=MaxZNCount div 2;  // для обеспечения сходимости на любом числе знаков при значении аргумента не больше, чем |pi/8|
  ZR2:=SqrZR(ZR);
  ZR1:=DefaultZR;
  k:=n*2+3;
  MaxZNCount:=0;                 // к оптимизации времени вычисления функции
  for i:=n downto 0 do
  begin
    MaxZNCount:=MaxZNCount+2;    // к оптимизации времени вычисления функции
    if i=0 then ZR1:=DivZR(ZR,SubZR(OneZR,ZR1))
    else begin k:=k-2; ZR1:=DivZR(ZR2,SubZR(IntToZR(k),ZR1)); end;
  end;
  MaxZNCount:=BakMaxZNCount;
  Result:=ZR1;
{
tg(pi/8) - 1000 знаков (32 зн. для аргумента) - 32,5 сек.
tg(pi/8) - 1000 знаков (1000 зн. для аргумента) - 32,8 сек.
tg(pi/8) - 1000 знаков (1000 зн. для аргумента) - 14,2 сек. с оптимизацией по времени вычисления
 100 знаков от аргумента с любой точностью вычисляются  0,1 секунды

Изложенный алгоритм вычисления тангенса от малого аргумента через цепную дробь имеет
один недостаток. При очень малых значениях аргумента при высокой точности вычисления
мы будем иметь неоправданно большое число шагов итерационного процесса. И это
количество невозможно сократить "в лоб", потому что цикл идет от обратного,
с последней итерации к первой.
}
  end;

1: begin
    SinCosZR(ZR, sinus, cosin);
    if EqvToZR(cosin,DefaultZR) then
    begin
        Messages('Функция TanZR: Деление на ноль');
        defaultZZReal(5,Result);  // создание нулевого масштабируемого числа
        exit;
    end
    else
    Result:=DivZR(sinus,cosin);
  end;

    end; // case
end;


// Квадратный корень из числа
function SqrtZR(const ZR: ZReal ): ZReal;
// Copyright © 2005 Nikolai Victorovich Botcharov
Label 33,34,35;   // для пропуска приближённого метода нахождения решения, если известно точное решение
var
  BakMaxZNCount:Integer;
  metod:Byte;
  expo,i:Integer;
  x, a, b:Extended;
  sp: Integer;
  inv: Boolean;
  eqv:ShortInt;
  ZR0, ZR1, ZR2, ZR3, ZR4, ZR05, ZR6, ZR7, ZR16: ZReal;
  KoeffZR: ZReal;
  Exp:Int64;
  SQRPower: Int64;
  bool: Boolean;
  eps_guess, guess, next_guess: ZReal;
  bip: Boolean;
begin
// Особые случаи
    if (ZR.U='i') or (ZR.U='-') then   // с отрицательными числами не работаем
    begin
      Messages('Функция SqrtZR:'#13' Попытка взять корень из отрицательного числа.');
      defaultZZReal(8,Result);  // создание нулевого масштабируемого числа
      Exit;
    end;
    if ComparisonZR(ZR, DefaultZR)=0 then   // нулевой результат
    begin Result:=DefaultZR; Exit; end;
    if ComparisonZR(ZR, OneZR)=0 then   // корень из единицы равен единице
    begin Result:=OneZR; Exit; end;
//
// можно вычислять корень
//

   metod:=2; //---! ! !--- Выберите метод приближённого вычисления квадратного корня
{
   0-2: метод Ньютона  (оптимально)
   3:   метод ГАЛЛЕЯ   (короткий итерационый процесс по сравнения с методом Ньютона, но медленный по времени вычисления)
   4..8:   квадратный корень из 2  (здесь пусто)
   9: смешанный метод из методов Ньютона и ГАЛЛЕЯ (преимуществ не найдено)
   10:  простой итерационный метод
}
    case metod of
0:begin  // ---------------------Double (метод Ньютона)
// переведённый на Delphi алгоритм Никитина (с использование разрядно-зависимых внешних функций frexp и ldexp)
(*
// Copyright (c) Nikitin V.F. 2000                                               /for "ANSI C"/
/* Square root almost without mathematic library. Optimized for floating
   point single precision. The functions frexp() and ldexp() from the
   mathematic library are very fast and machine-dependent.
   The second variant is less fast but does not use the math library
   at all.

   Square root decomposing the argument into the mantisse and the
   exponent (faster program):
   float Sqroot(float x);

   Square root without usage of any external functions (slower but
   machine-independent):
   float Sqroot1(float x);

   In case of invalid domain (x<0.) functions return zero (do not
   generate an error as library equivalents).
*/

#include <math.h>   /* frexp() and ldexp() only */

/* 4 iterations needed for the single precision */
#define ITNUM 4

/* variant using external f.p. decomposition/combining to [0.5,1] */
float Sqroot(float x) {
  int expo,i;
  float a,b;
  if(x<=0.F) return(0.F);
  /* decompose x into mantisse ranged [0.5,1) and exponent. Machine-
     dependent operation is presented here as a function call. */
  x=frexp(x,&expo);
  /* odd exponent: multiply mantisse by 2 and decrease exponent
     making it even. Now the mantisse is ranged [0.5,2.) */
  if(expo&1) {x*=2.F;expo--;}
  /* initial approximation */
  a=1.F;
  /* process ITNUM Newtonian iterations with the mantisse as
     an argument */
  for(i=ITNUM;i>0;i--) {
    b=x/a; a+=b; a*=0.5F;
  }
  /* divide the exponent by 2 and combine the result.
     Function ldexp() is opposite to frexp. */
  a=ldexp(a,expo/2);
  return(a);
}
*)
    ZR0:=ZR;
    x:=ZRToReal(ZR0);
// запись, подобная двум вышеприведённым строчкам чревата порчей данных в ZR (если использовать в программе формат представления данных с плавающей запятой)

    if x<=0. then begin Result:=DefaultZR; Exit; end;
    Mathfrexp(x,x,expo);
    if (expo and 1)=1 // логическая поразрядная операция
    then  // expo - нечётное
    begin x:=x*2; Dec(expo); end;
    a:=1;    // стартовое приближение будущего решения
// 4 итерации метода Ньютона
    for i:=1 to 4 do
    begin
       b:=x/a; a:=a+b; a:=a*0.5;
    end;
    a:=Mathldexp(a, expo div 2);
    Result:=RealToZR(a);
{
  Исследование сходимости итерационного процесса вычисления квадратного корня.
Число итераций - четыре (4 steps)

sqrt(2) -
 141421356237469Z-14   (потеря значности - 4 знака)
1.4142135623730950488016887242097  - калькулятор Windows
1.41421356237(468...). статья Xavier Gordon (метод ньютона - 4 итерации)
sqrt(3)
 1732050807568877Z-15  (правильный результат с учётом округления)
1,7320508075688772935274463415059  - калькулятор Windows
sqrt(5)
 223606797749979Z-14   (правильный результат с учётом округления)
2,2360679774997896964091736687313  - калькулятор Windows
sqrt(6)
 2449489742783179Z-15  (потеря значности - 1 знак)
2,4494897427831780981972840747059  - калькулятор Windows
sqrt(7)
 2645751311064693Z-15  (потеря значности - 3 знака)
2,6457513110645905905016157536393  - калькулятор Windows
sqrt(8)
 282842712474938Z-14   (потеря значности - 4 знака)
2,8284271247461900976033774484194  - калькулятор Windows
sqrt(9)
 300000000000018Z-14   (потеря значности - 3 знака)
3  - калькулятор Windows
sqrt(10)
 3162277660168387Z-15  (потеря значности - 2 знака)
3,1622776601683793319988935444327  - калькулятор Windows
sqrt(11)
 33166247903554Z-13    (правильный результат с учётом округления)
3,3166247903553998491149327366707
sqrt(12)
 3464101615137754Z-15  (правильный результат с отсечением)
3,4641016151377545870548926830117  - калькулятор Windows

Выводы:
1) Погрешность имеет плавающий характер для различных аргументов функции
при одинаковом стартовом приближении квадратного корня из аргумента.
2) Погрешность может охватить до 25% знаков от ожидаемой длины точного решения.
}
  end;
1:begin   // ---------------------Double (метод Ньютона)
// переведённый на Delphi алгоритм Никитина (без использование разрядно-зависимых внешних функций)
(*
/* variant without math lib usage. The domain is shrunk to [1,16].
   Repeated divisions by 16 are used. */
float Sqroot1(float x) {
  int sp=0,i,inv=0;
  float a,b;
  if(x<=0.F) return(0.F);
  /* argument less than 1 : invert it */
  if(x<1.F) {x=1.F/x;inv=1;}
  /* process series of division by 16 until argument is <16 */
  while(x>16.F) {sp++;x/=16.F;}
  /* initial approximation */
  a=2.F;
  /* Newtonian algorithm */
  for(i=ITNUM;i>0;i--) {
    b=x/a; a+=b; a*=0.5F;
  }
  /* multiply result by 4 : as much times as divisions by 16 took place */
  while(sp>0) {sp--;a*=4.F;}
  /* invert result for inverted argument */
  if(inv) a=1.F/a;
  return(a);
}
*)
    sp:=0;
    inv:=False;
    
    ZR0:=ZR;
    x:=ZRToReal(ZR0);
// запись, подобная двум вышеприведённым строчкам чревата порчей данных в ZR (если использовать в программе формат представления данных с плавающей запятой)

    if x<=0 then begin Result:=DefaultZR; Exit; end;
    if x<1 then begin x:=1/x; inv:=True; end;
// сокращение области определения первого приближённого значения
    while x>16 do begin Inc(sp); x:=x/16; end;
// Дополнение (Бочаров Н.В.):
//    while x>256 do begin Inc(sp); x:=x/256; end;
//    while x>1024 do begin Inc(sp); x:=x/1024; end;
//    while x>65536 do begin Inc(sp); x:=x/65536; end;
// порядок области ограничения приближённого решения должен быть не меньше
// половины порядка аргумента функции, иначе может возникнуть случай, что решение можно будет ждать до бесконечности

// задание первого приближённого значения
    a:=2;
// 4-5 итераций метода Ньютона
    for i:=1 to 5 do     //
    begin
       b:=x/a; a:=a+b; a:=a*0.5;
    end;
//    while sp>0 do begin Dec(sp); a:=a*256; end;
//    while sp>0 do begin Dec(sp); a:=a*32; end;
//    while sp>0 do begin Dec(sp); a:=a*16; end;
    while sp>0 do begin Dec(sp); a:=a*4; end;
    if inv then a:=1/a;
    Result:=RealToZR(a);
{
Прежняя таблица с результатами по новому алгоритму
sqrt(2) -
 141421356237469Z-14   (потеря значности - 4 знака)
 141421356237469Z-14   (ПО НОВОМУ АЛГОРИТМУ - 4 итерации)
 1414213562373095Z-15  (ПО НОВОМУ АЛГОРИТМУ - 5 итераций)
1.4142135623730950488016887242097  - калькулятор Windows
1.41421356237(468...). статья Xavier Gordon (метод ньютона - 4 итерации)
sqrt(3)
 1732050807568877Z-15  (правильный результат с учётом округления)
 1732050807568877Z-15  (ПО НОВОМУ АЛГОРИТМУ - 4 итерации)
 1732050807568877Z-15  (ПО НОВОМУ АЛГОРИТМУ - 5 итераций)
1,7320508075688772935274463415059  - калькулятор Windows
sqrt(5)
 223606797749979Z-14   (правильный результат с учётом округления)
 223606797749979Z-14   (ПО НОВОМУ АЛГОРИТМУ - 4 итерации)
 223606797749979Z-14   (ПО НОВОМУ АЛГОРИТМУ - 5 итераций)
2,2360679774997896964091736687313  - калькулятор Windows
sqrt(6)
 2449489742783179Z-15  (потеря значности - 1 знак)
 2449489742783179Z-15  (ПО НОВОМУ АЛГОРИТМУ - 4 итерации)
 2449489742783178Z-15  (ПО НОВОМУ АЛГОРИТМУ - 5 итераций)
2,4494897427831780981972840747059  - калькулятор Windows
sqrt(7)
 2645751311064693Z-15  (потеря значности - 3 знака)
 2645751311064693Z-15  (ПО НОВОМУ АЛГОРИТМУ - 4 итерации)
 2645751311064591Z-15  (ПО НОВОМУ АЛГОРИТМУ - 5 итераций)
2,6457513110645905905016157536393  - калькулятор Windows
sqrt(8)
 282842712474938Z-14   (потеря значности - 4 знака)
 282842712474938Z-14   (ПО НОВОМУ АЛГОРИТМУ - 4 итерации)
 282842712474619Z-14   (ПО НОВОМУ АЛГОРИТМУ - 5 итераций)
2,8284271247461900976033774484194  - калькулятор Windows
sqrt(9)
 300000000000018Z-14   (потеря значности - 3 знака)
 3000000000039322Z-15  (ПО НОВОМУ АЛГОРИТМУ - 4 итерации)
 3                     (ПО НОВОМУ АЛГОРИТМУ - 5 итераций)
 3  - калькулятор Windows
sqrt(10)
 3162277660168387Z-15  (потеря значности - 2 знака)
 3162277660444136Z-15  (ПО НОВОМУ АЛГОРИТМУ - 4 итерации)
 3162277660168379Z-15  (ПО НОВОМУ АЛГОРИТМУ - 5 итераций)
3,1622776601683793319988935444327  - калькулятор Windows
sqrt(11)
 33166247903554Z-13    (правильный результат с учётом округления)
 3316624791682619Z-15  (ПО НОВОМУ АЛГОРИТМУ - 4 итерации)
 33166247903554Z-13    (ПО НОВОМУ АЛГОРИТМУ - 5 итераций)
3,3166247903553998491149327366707
sqrt(12)
 3464101615137754Z-15  (правильный результат с отсечением)
 3464101620029455Z-15  (ПО НОВОМУ АЛГОРИТМУ - 4 итерации)
 3464101615137754Z-15  (ПО НОВОМУ АЛГОРИТМУ - 5 итераций)
3,4641016151377545870548926830117  - калькулятор Windows

Выводы:
1) Погрешность может охватить до 50% знаков от ожидаемой длины точного решения.
2) Увеличение числа итераций на единицу, прижимает погрешность к последнему знаку

}
  end;
2:begin  // ---------------------ZReal  (метод Ньютона - квадратичная сходимость)
// Пусть f(x) = x^2 - ZR, где ZR - аргумент функции
// Тогда, задав x(0), будем вычислять x(n+1) = xn - f(xn)/f'(xn),  пока x(n+1)-x(n)>epsilon
// epsilon определяется по "последнему" знаку второго приближения решения функции.
// Предполагается, что первый знак для второго приближения всегда будет окончательным.
// В нижеприведённом алгоритме при любом значении аргумента удалось довести
// кол-во итераций до 12 (для вычисления 1000 знаков).
// Однако можно было бы исключить ещё одну итерацию, если оптимизировать алгоритм определения epsilon
{
Ориентировочная таблица сходимости решения функции квадратного корня (Из статьи Xavier Gordon)
-----------------------------------
номер        |     количество
приближения  |     верных знаков
-----------------------------------
 1                 0
 2                 2
 3                 5
 4                 11
 5                 24            
 6                 48            
 7                 97
 8                 195
 9                 391
 10                783
-----------------------------------
}
//
// sqrt(12345678912345678912345678912345)= 35136418304012830773056698844306Z-16 - результат работы функции (0 sec)
// sqrt(12345678912345678912345678912345)=3513641830401283,0773056698844306 - калькулятор Windows
//
// повышение точности вычисления квадратного корня
  if MaxZNCount=0 then MaxZNCount:=1;
  if InfZNCount<MaxZNCount then InfZNCount:=MaxZNCount;
    BakMaxZNCount:=MaxZNCount;
    MaxZNCount:=MaxZNCount+3; // одного запасного знака на арифметические операции не хватает. Оптимально 3 знака
//
    sp:=0;
    inv:=False;
//
    if ComparisonZR(ZR, OneZR)<1 then       // работаем с числами больше 1
    begin ZR0:=OneDivZR(ZR); inv:=True; end
    else ZR0:=ZR;
// сокращение области определения первого приближённого значения
// во-первых, узнаём степень подкоренного числа из показателя степени его старшей разрядной ециницы
    SQRPower:=HighDeciZR(ZR0,bool).E; // bool в этом алгоритме нам не нужна
// во-вторых, поиск коэффициентов ZR16 (- коэффициент сжатия области) и KoeffZR (- коэффициент для решения функции)
    if SQRPower<2 then
    begin                                // "небольшое число" - [1;100)
      ZR16:=IntToZR(16);
      KoeffZR:=IntToZR(4);
    end
    else                                 // ловим разрядную сетку числа
// показатель степени приближённого решения функции имеет критическое влияние
// на скорость сходимости итерационного метода
// поэтому ловим верхний разряд аргумента функции (по которому будем сокращать область назначения приближённого решения)
    begin
      if (SQRPower and 1)=1 then        // нечётный показатель степени
      begin
        SQRPower:=(SQRPower-3);
        if SQRPower=0 then
        begin
          ZR16:=IntToZR(961);
          KoeffZR:=IntToZR(31);
        end
        else
        begin
          ZR16:=IntToZR(961);
          ZR16.E:=SQRPower;
          SQRPower:=SQRPower  div 2 ;
          KoeffZR:=IntToZR(31);
          KoeffZR.E:=SQRPower;
        end;
      end
      else                               // чётный показатель степени
      begin
        ZR16:=OneZR;
        ZR16.E:=SQRPower;
        SQRPower:=SQRPower  div 2 ;
        KoeffZR:=OneZR;
        KoeffZR.E:=SQRPower;
      end;
    end;
// в-третьих, сжатие области поиска корня
    eqv:=ComparisonZR(ZR0, ZR16);
    while eqv>0 do
    begin Inc(sp); ZR0:=DivZR(ZR0,ZR16); eqv:=ComparisonZR(ZR0, ZR16); end;
    if eqv=0 then // уже известно точное решение
    begin
      ZR1:=OneZR;
      Inc(sp);
      goto 33;
    end;
// всё, область поиска приближённого корня сокращена
//
// задание первого приближённого значения
    ZR1:=TwoZR; // основание
    ZR1.E:=HighDeciZR(ZR0,bool).E  div 2; // показатель степени

    ZR3:=ZR1; // запоминаем первое приближение для анализа сходимости приближённого метода
{
    eps_guess:=OneZR;
    eps_guess.E:=MaxZNCount*(-1);  // требуемая точность вычисления  (гарантированная, но замедляет функцию)
// для
// while ComparisonZR(AbsZR(DivZR(SubZR(ZR1,ZR3),MultZR(ZR1,TwoZR))), eps_guess)>0 - правильно сформулированное условие
}

    ZR05:=RealToZR(0.5);   // некоторая константа
// первая итерация метода Ньютона
    ZR2:=DivZR(ZR0,ZR1);
    ZR1:=SumZR(ZR1,ZR2);
    ZR1:=MultZR(ZR1,ZR05);
//    ZR2:=DivZR(ZR0,ZR1); ZR1:=SumZR(ZR1,ZR2); ZR1:=DivZR(ZR1,TwoZR);
    eps_guess:=HighDeciZR(ZR1,bool)  ;
    eps_guess.E:=eps_guess.E-MaxZNCount; // требуемая точность вычисления (гарантированная и оптимизированная - ускоряет функцию)
// для
// while ComparisonZR(AbsZR(SubZR(ZR1,ZR3)), eps_guess)>0 - в общем случае не совсем правильно сформулированное условия, но в виду оптимизации, такого условия должно быть достаточно для обеспечения требуемой точности вычислений
    i:=1;
//    while ComparisonZR(AbsZR(DivZR(SubZR(ZR1,ZR3),MultZR(ZR1,TwoZR))), eps_guess)>0 do  // это условие замедляет время выполнения функции примерно в два раза
    while ComparisonZR(AbsZR(SubZR(ZR1,ZR3)), eps_guess)>0 do  // Пока не замечено, чтобы терялась точность вычислений
// последующие итерации метода Ньютона
    begin
      Inc(i);   // подсчёт кол-ва итераций - видно только в отладчике
      ZR3:=ZR1;
      ZR2:=DivZR(ZR0,ZR1); ZR1:=SumZR(ZR1,ZR2); ZR1:=MultZR(ZR1,ZR05);  // время вычисления 1000 знаков - 1.1 сек
//      ZR2:=DivZR(ZR0,ZR1); ZR1:=SumZR(ZR1,ZR2); ZR1:=DivZR(ZR1,TwoZR);  // время вычисления 1000 знаков - 1.2 сек
// Операция деления медленнее операции произведения более, чем на 9%
    end;
33: while sp>0 do begin Dec(sp); ZR1:=MultZR(ZR1,KoeffZR); end;
    if inv then ZR1:=OneDivZR(ZR1);
    Result:=ZR1;

    MaxZNCount:=BakMaxZNCount;
  end;
3:begin  // ---------------------ZReal   (метод ГАЛЛЕЯ - кубическая сходимость)
// Пусть f(x) = x^2 - ZR, где ZR - аргумент функции. Тогда, задав x(0)
// будем вычислять x(n+1) = xn - f(x(n)) / f'(x(n)) / (1-  f(x(n))*f''(x(n)) / (2*f'(x(n))^2) )
// пока x(n+1)-x(n)>epsilon
// epsilon определяется по "последнему" знаку второго приближения решения функции.
// Предполагается, что первый знак для второго приближения всегда будет окончательным.
{
Ориентировочная таблица сходимости решения функции (Из статьи Xavier Gordon)
-----------------------------------
номер        |     количество
приближения  |     верных знаков
-----------------------------------
 1                  1
 2                  6
 3                  20
 4                  61
 5                  185
 6                  557
 7                  1673
 8                  5022
 9                  15067
 10                 45204
-----------------------------------
}
// повышение точности вычисления квадратного корня
  if MaxZNCount=0 then MaxZNCount:=1;
  if InfZNCount<MaxZNCount then InfZNCount:=MaxZNCount;
    BakMaxZNCount:=MaxZNCount;
    MaxZNCount:=MaxZNCount+3; // одного запасного знака на арифметические операции не хватает. Оптимально 3 знака
//
    sp:=0;
    inv:=False;
//
    if ComparisonZR(ZR, OneZR)<1 then       // работаем с числами больше 1
    begin ZR0:=OneDivZR(ZR); inv:=True; end
    else ZR0:=ZR;
// сокращение области определения первого приближённого значения
// во-первых, узнаём степень подкоренного числа из показателя степени его старшей разрядной ециницы
    SQRPower:=HighDeciZR(ZR0,bool).E; // bool в этом алгоритме нам не нужна
// во-вторых, поиск коэффициентов ZR16 (- коэффициент сжатия области) и KoeffZR (- коэффициент для решения функции)
    if SQRPower<2 then
    begin                                // "небольшое число" - [1;100)
      ZR16:=IntToZR(16);
      KoeffZR:=IntToZR(4);
    end
    else                                 // ловим разрядную сетку числа
// показатель степени приближённого решения функции имеет критическое влияние
// на скорость сходимости итерационного метода
// поэтому ловим любой верхний разряд аргумента функции (по которому будем сокращать область назначения приближённого решения)
    begin
      if (SQRPower and 1)=1 then        // нечётный показатель степени
      begin
        SQRPower:=(SQRPower-3);
        if SQRPower=0 then
        begin
          ZR16:=IntToZR(961);
          KoeffZR:=IntToZR(31);
        end
        else
        begin
          ZR16:=IntToZR(961);
          ZR16.E:=SQRPower;
          SQRPower:=SQRPower  div 2 ;
          KoeffZR:=IntToZR(31);
          KoeffZR.E:=SQRPower;
        end;
      end
      else                               // чётный показатель степени
      begin
        ZR16:=OneZR;
        ZR16.E:=SQRPower;
        SQRPower:=SQRPower  div 2 ;
        KoeffZR:=OneZR;
        KoeffZR.E:=SQRPower;
      end;
    end;
// в-третьих, сжатие области поиска корня
    eqv:=ComparisonZR(ZR0, ZR16);
    while eqv>0 do
    begin Inc(sp); ZR0:=DivZR(ZR0,ZR16); eqv:=ComparisonZR(ZR0, ZR16); end;
    if eqv=0 then // уже известно точное решение
    begin
      ZR1:=OneZR;
      Inc(sp);
      goto 34;
    end;
// всё, область поиска приближённого корня сокращена
//
// задание первого приближённого значения
    ZR1:=OneZR; // основание     TwoZR
    ZR1.E:=HighDeciZR(ZR0,bool).E  div 2; // показатель степени

    ZR05:=ZR1;   //  SQRZR(ZR1) = ZR1 потому что ZR1 = OneZR

    case 1 of

0: begin // формула вычисление корня из двух
// x*(x^2+6)/(3*x^2+2) // формула вычисления корня из двух © Xavier Gordon
// первая итерация метода ГАЛЛЕЯ   (ZR0- аргумент)
//
    ZR4:=ZR1; // запоминаем первое приближение для анализа сходимости итерационного метода
    ZR7:=STRToZR('3');
    ZR6:=STRToZR('6');
    ZR2:=SumZR(ZR05,ZR6);
    ZR3:=MultZR(ZR05,ZR7);
    ZR3:=SumZR(ZR3,TwoZR);
    ZR1:=MultZR(ZR1,DivZR(ZR2,ZR3));

    eps_guess:=HighDeciZR(ZR1,bool)  ;
    eps_guess.E:=eps_guess.E-MaxZNCount+2; // вычисления будем проводить с точностью до двух последних знаков

    i:=1;

    while ComparisonZR(AbsZR(SubZR(ZR4,ZR1)), eps_guess)>0 do
// последующие итерации метода ГАЛЛЕЯ
    begin
      Inc(i);   // подсчёт кол-ва итераций - видно только в отладчике
      ZR4:=ZR1; // запоминаем очередное приближение для анализа сходимости итерационного метода
      ZR05:=SQRZR(ZR1);
// x*(x^2+6)/(3*x^2+2) // формула вычисления корня из двух  © Xavier Gordon
      ZR2:=SumZR(ZR05,ZR6);
      ZR3:=MultZR(ZR05,ZR7);
      ZR3:=SumZR(ZR3,TwoZR);
      ZR1:=MultZR(ZR1,DivZR(ZR2,ZR3));     // время вычисления 1000 знаков - 1,8 сек
    end;

   end;
1: begin // первая формула вычисление корня из любого аргумента
// воспользуемся формулой: x * (1 + 2*(ZR0-x^2)/(3*x^2+ZR0))
// первая итерация метода ГАЛЛЕЯ   (ZR0- аргумент)
//
    ZR7:=STRToZR('3');      //
    ZR2:=SubZR(ZR0,ZR05);
    ZR3:=MultZR(ZR7,ZR05); // SumZR(ZR05,SumZR(ZR05,ZR05)) = 3*x^2;
    ZR3:=SumZR(ZR3,ZR0);
    ZR3:=DivZR(ZR2,ZR3);
    ZR3:=MultZR(TwoZR,ZR3); // ;  SumZR(ZR3,ZR3)
    ZR3:=SumZR(OneZR,ZR3);
    ZR1:=MultZR(ZR1,ZR3);

    ZR05:=SQRZR(ZR1);   //  x^2
    ZR2:=SubZR(ZR0,ZR05); // (ZR0-x^2)

    eps_guess:=HighDeciZR(ZR1,bool)  ;
    eps_guess.E:=eps_guess.E-MaxZNCount+2; // вычисления будем проводить с точностью до двух последних знаков

    i:=1;

    while ComparisonZR(AbsZR(ZR2), eps_guess)>0 do
// последующие итерации метода ГАЛЛЕЯ
    begin
      Inc(i);   // подсчёт кол-ва итераций - видно только в отладчике
// воспользуемся формулой: x * (1 + 2*(ZR0-x^2)/(3*x^2+ZR0))
    ZR3:=MultZR(ZR7,ZR05); //  SumZR(ZR05,SumZR(ZR05,ZR05))= 3*x^2;
    ZR3:=SumZR(ZR3,ZR0);
    ZR3:=DivZR(ZR2,ZR3);
    ZR3:=MultZR(TwoZR,ZR3); // ;    SumZR(ZR3,ZR3)
    ZR3:=SumZR(OneZR,ZR3);
    ZR1:=MultZR(ZR3,ZR1);     // время вычисления 1000 знаков -  1,6-2.0 сек 7-8 итераций
// 226,5 сек  10000 знаков методом Галлея  (9 итераций)
// 135,5 сек  10000 знаков методом Ньютона (16 итераций)
// на 10000 знаков метод Галлея всё равно проигрывает методу Ньютона в тех же пропорциях, что и на малой значности чисел.
// Это происходит из-за того, что при на треть меньшем количестве итераций количество арифметических операций в методе Галлея в два раза больше (перед оптимизацией).
      ZR05:=SQRZR(ZR1);
      ZR2:=SubZR(ZR0,ZR05);
// Замена некоторых произведений на суммы не даёт никакого выигрыша
    end;

   end;
2: begin // вторая формула вычисление корня из любого аргумента
// (x*(x^2+3*ZR0)/(3*x^2+ZR0))  // формула вычисления корня из любого аргумента   -
    ZR4:=ZR1; // запоминаем первое приближение для анализа сходимости итерационного метода
//    ZR7:=STRToZR('3');
    ZR6:=SumZR(ZR0,SumZR(ZR0,ZR0)); // MultZR(ZR7,ZR0) = 3*ZR0;
    ZR2:=SumZR(ZR05,ZR6);
    ZR3:=SumZR(ZR05,SumZR(ZR05,ZR05)); // MultZR(ZR05,ZR7)= 3*x^2
    ZR3:=SumZR(ZR3,ZR0);
    ZR1:=MultZR(ZR1,DivZR(ZR2,ZR3));

    eps_guess:=HighDeciZR(ZR1,bool)  ;
    eps_guess.E:=eps_guess.E-MaxZNCount+2; // вычисления будем проводить с точностью до двух последних знаков

    i:=1;

    while ComparisonZR(AbsZR(SubZR(ZR4,ZR1)), eps_guess)>0 do
// последующие итерации метода ГАЛЛЕЯ
    begin
      Inc(i);   // подсчёт кол-ва итераций - видно только в отладчике
      ZR4:=ZR1; // запоминаем очередное приближение для анализа сходимости итерационного метода
      ZR05:=SQRZR(ZR1);
// (x*(x^2+3*ZR0)/(3*x^2+ZR0))  // формула вычисления корня из любого аргумента   - 1000 знаков - 8  итераций  (одна лишняя из текущего алгоритма) - 1,7 сек
      ZR2:=SumZR(ZR05,ZR6);
      ZR3:=SumZR(ZR05,SumZR(ZR05,ZR05)); // MultZR(ZR05,ZR7)= 3*x^2
      ZR3:=SumZR(ZR3,ZR0);
      ZR1:=MultZR(ZR1,DivZR(ZR2,ZR3));
//
    end;

   end;
     end; // case метода Галлея

34: while sp>0 do begin Dec(sp); ZR1:=MultZR(ZR1,KoeffZR); end;
    if inv then ZR1:=OneDivZR(ZR1);
    Result:=ZR1;

    MaxZNCount:=BakMaxZNCount;
// время вычисления корня из любого аргумента варьируется от 1.5 до 3.0 секунд,
// а не постоянно, как в методе Ньютона .
// видимо метод ГАЛЛЕЯ более чувствителен к начальному приближению.
// Эта тема пока не исследовалась
  end;
4..8:begin
// ---------------------Double  (квадратный корень из 2: алгоритмы из статьи "Квадратный корень из 2" с ALGOLIST.MANUAL.RU © Xavier Gordon)
{
метод Ньютона - 12 итераций 1.1 сек  (три операции на одной итерации: из них одно умножения и одно деление)
1414213562373095048801688724209698078569671875376948073176679737990732478462107038850387534327641572735013846230912297024924836055850737212644121497099935831413222665927505592755799950501152782060571470109559971605970274534596862014728517418640889198609552329230484308714321450839762603627995251407989687253396546331808829640620615258352395054745750287759961729835575220337531857011354374603408498847160386899970699004815030544027790316454247823068492936918621580578463111596668713013015618568987237235288509264861249497715421833420428568606014682472077143585487415565706967765372022648544701585880162075847492265722600208558446652145839889394437092659180031138824646815708263010059485870400318648034219489727829064104507263688131373985525611732204024509122770022694112757362728049573810896750401836986836845072579936472906076299694138047565482372899718032680247442062926912485905218100445984215059112024944134172853147810580360337107730918286931471017111168391658172688941975871658215212822951848847Z-999
метод Галлея - 9 итераций 1.8 сек   (шесть операций на одной итерации: из них три умножения и одно деление - формулы закомментированы в предыдущем пункте функции) (но, что интересно, для вычисления 1500 знаков требуется 8 итераций - время вычисления 3.5 сек)
1414213562373095048801688724209698078569671875376948073176679737990732478462107038850387534327641572735013846230912297024924836055850737212644121497099935831413222665927505592755799950501152782060571470109559971605970274534596862014728517418640889198609552329230484308714321450839762603627995251407989687253396546331808829640620615258352395054745750287759961729835575220337531857011354374603408498847160386899970699004815030544027790316454247823068492936918621580578463111596668713013015618568987237235288509264861249497715421833420428568606014682472077143585487415565706967765372022648544701585880162075847492265722600208558446652145839889394437092659180031138824646815708263010059485870400318648034219489727829064104507263688131373985525611732204024509122770022694112757362728049573810896750401836986836845072579936472906076299694138047565482372899718032680247442062926912485905218100445984215059112024944134172853147810580360337107730918286931471017111168391658172688941975871658215212822951848847Z-999

// (Математика » Быстрые вычисления » Квадратный корень из 2 - ALGOLIST.MANUAL.RU)
// построение алгоритмов для вычисления корней более высоких порядков сходимости
// бессмысленно, в виду существенного увеличения количества операций в них,
// что существенно отражается на времени вычислений
}
    Result:=StrToZR('1,4142135623730950488016887242097');
  end;
9:begin   // смешанный метод Ньютона и ГАЛЛЕЯ
// сначала, с помощью нескольких итераций метода  Ньютона ищем приближённое решение,
// а потом методом ГАЛЛЕЯ доопределяем решение по всем оставшимся разрядам.
// Замечание.
// В функции FracRootZR предлагается посчитать приближённое решение 
// методом Ньютона на малой разрядности аргумента. Здесь этого не реализовано.
// Может быть тогда смешанный метод существенно выделится, по сравнению с чистым методом Ньютона.

// повышение точности вычисления квадратного корня
  if MaxZNCount=0 then MaxZNCount:=1;
  if InfZNCount<MaxZNCount then InfZNCount:=MaxZNCount;
    BakMaxZNCount:=MaxZNCount;
    MaxZNCount:=MaxZNCount+3; // одного запасного знака на арифметические операции не хватает. Оптимально 3 знака
//
    sp:=0;
    inv:=False;
//
    if ComparisonZR(ZR, OneZR)<1 then       // работаем с числами больше 1
    begin ZR0:=OneDivZR(ZR); inv:=True; end
    else ZR0:=ZR;
// сокращение области определения первого приближённого значения
// во-первых, узнаём степень подкоренного числа из показателя степени его старшей разрядной ециницы
    SQRPower:=HighDeciZR(ZR0,bool).E; // bool в этом алгоритме нам не нужна
// во-вторых, поиск коэффициентов ZR16 (- коэффициент сжатия области) и KoeffZR (- коэффициент для решения функции)
    if SQRPower<2 then
    begin                                // "небольшое число" - [1;100)
      ZR16:=IntToZR(16);
      KoeffZR:=IntToZR(4);
    end
    else                                 // ловим разрядную сетку числа
// показатель степени приближённого решения функции имеет критическое влияние
// на скорость сходимости итерационного метода
// поэтому ловим любой верхний разряд аргумента функции (по которому будем сокращать область назначения приближённого решения)
    begin
      if (SQRPower and 1)=1 then        // нечётный показатель степени
      begin
        SQRPower:=(SQRPower-3);
        if SQRPower=0 then
        begin
          ZR16:=IntToZR(961);
          KoeffZR:=IntToZR(31);
        end
        else
        begin
          ZR16:=IntToZR(961);
          ZR16.E:=SQRPower;
          SQRPower:=SQRPower  div 2 ;
          KoeffZR:=IntToZR(31);
          KoeffZR.E:=SQRPower;
        end;
      end
      else                               // чётный показатель степени
      begin
        ZR16:=OneZR;
        ZR16.E:=SQRPower;
        SQRPower:=SQRPower  div 2 ;
        KoeffZR:=OneZR;
        KoeffZR.E:=SQRPower;
      end;
    end;
// в-третьих, сжатие области поиска корня
    eqv:=ComparisonZR(ZR0, ZR16);
    while eqv>0 do
    begin Inc(sp); ZR0:=DivZR(ZR0,ZR16); eqv:=ComparisonZR(ZR0, ZR16); end;
    if eqv=0 then // уже известно точное решение
    begin
      ZR1:=OneZR;
      Inc(sp);
      goto 35;
    end;
// всё, область поиска приближённого корня сокращена
//
//
// задание первого приближённого значения для метода Ньютона
    ZR1:=TwoZR; // основание
    ZR1.E:=HighDeciZR(ZR0,bool).E  div 2; // показатель степени

// подготавливаемся к одной итерации по методу Галлея
    eps_guess:=HighDeciZR(ZR1,bool)  ;
    if MaxZNCount>999 then
    begin
      bip:=False; // Зачаду решаем смешанным методом
      eps_guess.E:=eps_guess.E- (MaxZNCount div 3) +2; // вычисления будем проводить с точностью до двух последних знаков
    end
    else
    begin
      bip:=True; // Зачаду решаем только методом Ньютона
      eps_guess.E:=eps_guess.E-MaxZNCount+2; // вычисления будем проводить с точностью до двух последних знаков
    end;

    ZR3:=ZR1; // запоминаем первое приближение для анализа сходимости приближённого метода
    ZR05:=RealToZR(0.5);   // некоторая константа
    ZR2:=DivZR(ZR0,ZR1); ZR1:=SumZR(ZR1,ZR2); ZR1:=MultZR(ZR1,ZR05);  // первая итерация методом Ньютона
    i:=1;
// первые итерации поиска решения проводим по методу Ньютона
// задача взять первые знаки решения, которые методом Ньютона находятся быстрее, чем методом Галлея
    while ComparisonZR(AbsZR(SubZR(ZR1,ZR3)), eps_guess)>0 do
    begin
      Inc(i);   // подсчёт кол-ва итераций - видно только в отладчике
      ZR3:=ZR1; // запоминаем первое приближение для анализа сходимости приближённого метода
      ZR2:=DivZR(ZR0,ZR1);
      ZR1:=SumZR(ZR1,ZR2);
      ZR1:=MultZR(ZR1,ZR05);
    end;

    if bip then   goto 35; // для большинства вычислительных задач точности полученной методом Ньютона  должно быть достаточно
// Теперь переходим к методу Галлея
// смысл: Утроением точности решения уменьшить количество итераций
// посмотрим, эффект от одной итерации методом  Галлея

// в качестве приближённого решения берём решение, полученное методом Ньютона
// первая итерация метода ГАЛЛЕЯ   (ZR0- аргумент)
// воспользуемся формулой: x * (1 + 2*(ZR0-x^2)/(3*x^2+ZR0))
//
    ZR05:=SQRZR(ZR1);   //  x^2
    ZR7:=STRToZR('3');      //
    ZR2:=SubZR(ZR0,ZR05);
    ZR3:=MultZR(ZR7,ZR05); // SumZR(ZR05,SumZR(ZR05,ZR05)) = 3*x^2;
    ZR3:=SumZR(ZR3,ZR0);
    ZR3:=DivZR(ZR2,ZR3);
    ZR3:=MultZR(TwoZR,ZR3); // ;  SumZR(ZR3,ZR3)
    ZR3:=SumZR(OneZR,ZR3);
    ZR1:=MultZR(ZR1,ZR3);

    ZR05:=SQRZR(ZR1);   //  x^2
    ZR2:=SubZR(ZR0,ZR05); // (ZR0-x^2)

// уточняем точность вычисления по приближённому решению, полученному методом Ньютона
    eps_guess:=HighDeciZR(ZR1,bool)  ;
    eps_guess.E:=eps_guess.E-MaxZNCount+2; // вычисления будем проводить с точностью до двух последних знаков

    i:=1;

    while ComparisonZR(AbsZR(ZR2), eps_guess)>0 do
// последующие итерации метода ГАЛЛЕЯ
    begin
      Inc(i);   // подсчёт кол-ва итераций - видно только в отладчике
// воспользуемся формулой: x * (1 + 2*(ZR0-x^2)/(3*x^2+ZR0))
      ZR3:=MultZR(ZR7,ZR05); //  SumZR(ZR05,SumZR(ZR05,ZR05))= 3*x^2;
      ZR3:=SumZR(ZR3,ZR0);
      ZR3:=DivZR(ZR2,ZR3);
      ZR3:=MultZR(TwoZR,ZR3); // ;    SumZR(ZR3,ZR3)
      ZR3:=SumZR(OneZR,ZR3);
      ZR1:=MultZR(ZR3,ZR1);     // искомое решение
      ZR05:=SQRZR(ZR1);
      ZR2:=SubZR(ZR0,ZR05);
// Замена некоторых произведений на суммы не даёт никакого выигрыша
    end;

// всё решение почти готово
35: while sp>0 do begin Dec(sp); ZR1:=MultZR(ZR1,KoeffZR); end;
    if inv then ZR1:=OneDivZR(ZR1);

    MaxZNCount:=BakMaxZNCount;
    Result:=ZR1;
{
 135,5 сек.  10000 знаков методом Ньютона (16 итераций)
 226,5 сек.  10000 знаков методом Галлея  (9 итераций)
 178,0 сек.  10000 знаков Смешанным методом (8+4 итерации)  - нет эффекта  относительно  чистого метода Ньютона
 150,0 сек.  10000 знаков Смешанным методом (X+1 итерация)  - ускорения так и не обнаруживается
Вывод: метод Галлея в практическом плане не даёт никаких преимуществ.
}
  end;

10:begin  // ---------------------ZReal   (Простое итерационное вычисление квадратного корня)
{
// проседура из библиотеки к бесплатному компилятору Фортрана "F compiler" http://www.fortran.com/F
program iterative_square_root

real :: value, guess, next_guess
real, parameter :: eps = 1.0e-5

do      ! infinite loop until zero entered

print *, "Enter a number, zero to stop:"
read *, value

if (value <= 0.0) then
  stop
end if

guess = value/2.0

  do
    next_guess = guess - (guess**2 - value)/(2*guess)
    print "(f14.8)", next_guess
    if (abs(guess - next_guess) > eps) then
      guess = next_guess
    else
      exit
    end if
  end do

  print *, "The square root of ", value, &
           " is approximately ", next_guess

end do
end program iterative_square_root
}
    eqv:=ComparisonZR(ZR, DefaultZR);
    if eqv<=0 then begin
    Result:=DefaultZR; Exit;
    end;
    guess := DivZR(ZR,TwoZR);
    eps_guess := LowDeciZR(guess);
//     next_guess =       guess -           (guess**2 - value)/         (2*guess)
      next_guess := SubZR(guess,DivZR( SubZR(SqrZR(guess),ZR) , MultZR(guess,TwoZR)));
    i:=1;  // подсчёт кол-ва итераций - видно только в отладчике
    while (ComparisonZR(AbsZR(SubZR(guess,next_guess)),eps_guess)>0) do
    begin
      guess := next_guess;
//     next_guess =       guess -           (guess**2 - value)/         (2*guess)
      next_guess := SubZR(guess,DivZR( SubZR(SqrZR(guess),ZR) , MultZR(guess,TwoZR)));
      Inc(i);
    end;
    Result:=next_guess;
{
sqrt(165536)=
Простой итерационный метод
32 знака - 14 итераций - 0,01 сек
160 знаков - 17 итераций - 0,09 сек
1000 знаков - 19 итераций - 3,25 сек
Простой итерационный метод  - 3,25 сек (19 итераций)
 4068611556784451744228472060724898045657268954233885824545434486985891631436967407419295157857582249867897673962557148671224684377703651544248304296707164823343064550651757309681254412953886664718501716791059715763045570030187045905767108222160115211498658823699362397774574266688927771597134484959596591224339874307687405584046657707491092967441812325283414415576582393573515089845551212641284159179315665110307699625255480177665182248170180274662249244449834043112484516853750183239459390196287234989153508553158845764936442251427060715529285771476414472152060127146274094703335235052682477573997554127453580105724939009886331335470176557960254573265067014296449208333503049578396055342252069985164147413443262528685391313065084316084553674805794404617608425412928398151792387341258025712601671151540538816487769151422826183631240332452068223162744197621823832405447346834681420331228268322488738823327468006443304265953543010416141530267767701449932278949127304024522632917006650989358904820917824Z-997
Метод Ньютона - 1,2 сек  (12 итераций)
 4068611556784451744228472060724898045657268954233885824545434486985891631436967407419295157857582249867897673962557148671224684377703651544248304296707164823343064550651757309681254412953886664718501716791059715763045570030187045905767108222160115211498658823699362397774574266688927771597134484959596591224339874307687405584046657707491092967441812325283414415576582393573515089845551212641284159179315665110307699625255480177665182248170180274662249244449834043112484516853750183239459390196287234989153508553158845764936442251427060715529285771476414472152060127146274094703335235052682477573997554127453580105724939009886331335470176557960254573265067014296449208333503049578396055342252069985164147413443262528685391313065084316084553674805794404617608425412928398151792387341258025712601671151540538816487769151422826183631240332452068223162744197621823832405447346834681420331228268322488738823327468006443304265953543010416141530267767701449932278949127304024522632917006650989358904820917824Z-997
406,86115567844517442284720607249 - калькулятор Windows

Простой итерационный метод
sqrt(2) - 1000 знаков - 2.1 sec
1414213562373095048801688724209698078569671875376948073176679737990732478462107038850387534327641572735013846230912297024924836055850737212644121497099935831413222665927505592755799950501152782060571470109559971605970274534596862014728517418640889198609552329230484308714321450839762603627995251407989687253396546331808829640620615258352395054745750287759961729835575220337531857011354374603408498847160386899970699004815030544027790316454247823068492936918621580578463111596668713013015618568987237235288509264861249497715421833420428568606014682472077143585487415565706967765372022648544701585880162075847492265722600208558446652145839889394437092659180031138824646815708263010059485870400318648034219489727829064104507263688131373985525611732204024509122770022694112757362728049573810896750401836986836845072579936472906076299694138047565482372899718032680247442062926912485905218100445984215059112024944134172853147810580360337107730918286931471017111168391658172688941975871658215212822951848847Z-999
sqrt(3) - 1000 знаков - 1.9 sec
1732050807568877293527446341505872366942805253810380628055806979451933016908800037081146186757248575675626141415406703029969945094998952478811655512094373648528093231902305582067974820101084674923265015312343266903322886650672254668921837971227047131660367861588019049986537379859389467650347506576050756618348129606100947602187190325083145829523959832997789824508288714463832917347224163984587855397667958063818353666110843173780894378316102088305524901670023520711144288695990956365797087168498072899493296484283020786408603988738697537582317317831395992983007838702877053913369563312103707264019249106768231199288375641141422016742752102372994270831059898459475987664288897796147837958390228854852903576033852808064381972344661059689722872865264153822664698420021195484155278441181286534507035191650016689294415480846071277143999762926834629577438361895110127148638746976545982451788550975379013880664961911962222957110555242923723192197738262561631468842032853716682938649611917049738836395495938Z-999
}
  end;
    end; // case
end;


// младшая единица числа  (единица первого разряда "масштабируемого" действительного числа)
function LowDeciZR(const ZR: ZReal): ZReal;
begin
  Result.R:=decimal;
  Result.E:=ZR.E;
  if ZR.U='I' then Result.U:='+'
  else if ZR.U='i' then Result.U:='-'
    else Result.U:=ZR.U;
  SetLength(Result.I, 1);  // создаём одномерный массив
  Result.I[0]:=1;
end;


// старшая единица числа  (единица последнего разряда "масштабируемого" действительного числа)
function HighDeciZR(const ZR: ZReal;  out IsNearInf: Boolean): ZReal;
// (если экспонента старшего разряда числа больше High(Int64), то IsNearInf=True,
// а результат представляет собой единицу с максимальной степенью экспоненты,
// в данном модуле это число High(Int64). Знак числа в результате сохраняется.)
var
  l:Integer;
begin
  Result.R:=decimal;

  if IsInfinite(ZR) then
  begin
    if ZR.U='I' then Result.U:='+'
    else if ZR.U='i' then Result.U:='-'
      else Result.U:=ZR.U;
    Result.E:=High(Int64);
    SetLength(Result.I, 1);  // создаём одномерный массив
    Result.I[0]:=1;
    IsNearInf:=True;
    Exit;
  end;

  Result.U:=ZR.U;

  l:=Length(ZR.I);
  if ZR.E>0 then
  begin
    if (High(Int64)-ZR.E)<l then
    begin  Result.E:=High(Int64);  IsNearInf:=True; end
    else begin Result.E:=ZR.E-1+l; IsNearInf:=False; end;
    SetLength(Result.I, 1);  // создаём одномерный массив
    Result.I[0]:=1;
    Exit;
  end;

  Result.E:=ZR.E+l-1;
  IsNearInf:=False;
  SetLength(Result.I, 1);  // создаём одномерный массив
  Result.I[0]:=1;
end;


// АркСинус
function ArcsinZR(const ZR: ZReal ): ZReal;
var
  BakMaxZNCount:Integer;
  metod:Byte;
  i,j:Integer;
  eqv:ShortInt;
  ZR0, ZR1, ZR2, ZR3, ZR5: ZReal;
  Mlt1,Mlt2,Mlt3,Mlt11,Mlt22: ZReal;
  bool:Boolean;
  eps_guess: ZReal;
  ic:Integer;
begin
   metod:=0; //---! ! !--- Выберите метод приближённого вычисления АркСинуса
{
   0: АркСинус через аркТангенс  (оптимально)
   1: АркСинус через разложение в ряд  (не обнаружено преимуществ)
}
//  ZR0:=ZR;
  eqv:=ComparisonZR(AbsZR(ZR),OneZR);
  if eqv>0 then
  begin
    Messages('Функция ArcsinZR:'#13' Недопустимое значение аргумента.');
    defaultZZReal(8,Result);  // создание нулевого "масштабируемого" числа
    Exit;
  end;
  if eqv=0 then
  begin
    if GetUnaryZR(ZR)<0 then
    Result:=InvertUnaryZR(PiDiv2_ZR)
    else
    Result:=PiDiv2_ZR;
    Exit;
  end;

    case metod of
0:begin   //---------------- АркСинус через аркТангенс
// arcsin(x)=arctan(x/sqrt(1-x2))
    Result:=ArcTanZR(DivZR(ZR,SqrtZR(SubZR(OneZR,SqrZR(ZR)))));
  end;
1:begin   //---------------- АркСинус через разложение в ряд
// повышение точности вычисления АркСинуса
    if MaxZNCount=0 then MaxZNCount:=1;
    if InfZNCount<MaxZNCount then InfZNCount:=MaxZNCount;
    BakMaxZNCount:=MaxZNCount;
    MaxZNCount:=MaxZNCount+3; // по аналогии с функцией Арктангенса

    Result:=ZR;  // первый член ряда
    ZR0:=SqrZR(ZR);
    Mlt1:=OneZR;
    Mlt2:=TwoZR;
    Mlt3:=IntToZR(3);
    ZR1:=Mlt1;
    ZR2:=MultZR(Mlt2,Mlt3);
    ZR3:=MultZR(ZR,ZR0);
    ZR5:=DivZR(MultZR(ZR1,ZR3),ZR2);
    Result:=SumZR(Result,ZR5); // первые два члена ряда
    eps_guess:=HighDeciZR(Result,bool)  ;
    eps_guess.E:=eps_guess.E-MaxZNCount+2; // вычисления будем проводить с точностью до двух последних знаков
    Mlt11:=Mlt1;
    Mlt22:=Mlt2;
    ic:=2;
    while ComparisonZR(AbsZR(ZR5),eps_guess)>0 do
    begin
      Mlt11:=SumZR(Mlt11,TwoZR);
      Mlt1:=MultZR(Mlt1,Mlt11);
      Mlt22:=SumZR(Mlt22,TwoZR);
      Mlt2:=MultZR(Mlt2,Mlt22);
      Mlt3:=SumZR(Mlt3,TwoZR);
      ZR1:=Mlt1;
      ZR2:=MultZR(Mlt2,Mlt3);
      ZR3:=MultZR(ZR3,ZR0);
      ZR5:=DivZR(MultZR(ZR1,ZR3),ZR2);
      Result:=SumZR(Result,ZR5); // сумма разложения
      Inc(ic);
// довольно большое количество арифметических операций для каждого члена разложения
// по сравнению с разложением для Арктангенса
    end;
    MaxZNCount:=BakMaxZNCount;
{
При аргументе 0,001 без всякой оптимизации имеем 168 членов ряда и время вычисления 4,0 сек против 7,7 сек через арктангенс.
              0,01                               251                                8,3            8,0
              0,1                                500                               31,0           10,9
              0,2                                будет расти                       будет расти     8,9
              0,2                                будет расти                       будет расти     8,9
              0,3                                будет расти                       будет расти     7,7
              0,4                                будет расти                       будет расти     8,2
              0,5                                будет расти                       будет расти     1,7
              0,6                                будет расти                       будет расти     9,9
              0,7                                будет расти                       будет расти     8,4
              0,9                                будет расти                       будет расти     9,5
              0,9999999                          будет расти                       будет расти     8,2
Как видно, для АркСинуса потребуются произвести оптимизации, подобные оптимизациям, применённым для АркТангенса
При этом для сокращения области определения функции придётся воспользоваться
формулой вида - Arcsin(x)-Arcsin(y)=Arcsin(x*sqrt(1-y^2)-y*sqrt(1-x^2)) , для положительных x и y.
Из последней формулы видно, что на накладные расходы приходится вычисление
функции квадратного корня, которая более, чем на порядок дольше, чем операция
деления, которая используется в накладных расходах у функции вычисления арктангенса.
Так что, не видно преимуществ в проведении оптимизации для алгоритма разложения Арксинуса в ряд.
}
  end;
    end; // case
end;


// АркКосинус
function ArccosZR(const ZR: ZReal ): ZReal;
//   АркКосинус вычисляется только через АркСинус
var
//  BakMaxZNCount:Integer;
  i,j:Integer;
  eqv:ShortInt;
  ZR0, ZR1, ZR2, ZR3: ZReal;
begin
  eqv:=ComparisonZR(AbsZR(ZR),OneZR);
  if eqv>0 then
  begin
    Messages('Функция ArccosZR:'#13'Недопустимое значение аргумента.');
    defaultZZReal(8,Result);  // создание нулевого "масштабируемого" числа
    Exit;
  end;
  if eqv=0 then
  begin
    if GetUnaryZR(ZR)<0 then
    Result:=Pi_ZR
    else
    Result:=DefaultZR;
    Exit;
  end;

//Непосредственное вычисление АркКосинуса через АркСинус
// arccos(x)=pi/2-arcsin(x)
    Result:=SubZR(PiDiv2_ZR,ArcsinZR(ZR));

end;


// градусы в радианы
function DegToRadZR(const ZR: ZReal): ZReal;
// Radians := Degrees * PI / 180
begin
  MaxZNCount:=MaxZNCount+3;
Result:=DivZR(MultZR(ZR,Pi_ZR),StrToZR('180'));
  MaxZNCount:=MaxZNCount-3;
end;


// радианы в градусы
function RadToDegZR(const ZR: ZReal): ZReal;
// Degrees := Radians * 180 / PI
begin
  MaxZNCount:=MaxZNCount+3;
Result:=DivZR(MultZR(ZR,StrToZR('180')),Pi_ZR);
  MaxZNCount:=MaxZNCount-3;
end;


// гипотенуза: Sqrt(ZR1*ZR1 + ZR2*ZR2)
function HypotZR(const ZR1, ZR2: ZReal): ZReal;
var
  bool:Boolean;
begin
  if ComparisonZR(ZR1,DefaultZR)=0 then begin Result:=AbsZR(ZR2); Exit; end;
  if ComparisonZR(ZR2,DefaultZR)=0 then begin Result:=AbsZR(ZR1); Exit; end;

try
  if (HighDeciZR(ZR1,bool).E*2-MaxZNCount)>(HighDeciZR(ZR2,bool).E*2) then
  begin Result:=AbsZR(ZR1); Exit; end;
  if (HighDeciZR(ZR2,bool).E*2-MaxZNCount)>(HighDeciZR(ZR1,bool).E*2) then
  begin Result:=AbsZR(ZR2); Exit; end;
except end;

  MaxZNCount:=MaxZNCount+3;
  Result:=SqrtZR(SumZR(SQRZR(ZR1),SQRZR(ZR2)));
  MaxZNCount:=MaxZNCount-3;
end;


// катет: Sqrt(ZRhyp*ZRhyp - ZRcat*ZRcat)
function CathetZR(const ZRhyp, ZRcat: ZReal): ZReal;
var
  bool:Boolean;
begin
  if ComparisonZR(AbsZR(ZRhyp), AbsZR(ZRcat))<0 then
  begin
    Messages('Функция CathetZR:'#13'Недопустимое соотношение аргументов.'#13'Гипотенуза меньше катета.');
    defaultZZReal(8,Result);  // создание нулевого "масштабируемого" числа
    Exit;
  end;

  if ComparisonZR(ZRhyp,DefaultZR)=0 then begin Result:=AbsZR(ZRcat); Exit; end;
  if ComparisonZR(ZRcat,DefaultZR)=0 then begin Result:=AbsZR(ZRhyp); Exit; end;

try
  if (HighDeciZR(ZRhyp,bool).E*2-MaxZNCount)>(HighDeciZR(ZRcat,bool).E*2) then
  begin Result:=AbsZR(ZRhyp); Exit; end;
except end;

  MaxZNCount:=MaxZNCount+3;
  Result:=SqrtZR(SubZR(SQRZR(ZRhyp),SQRZR(ZRcat)));
  MaxZNCount:=MaxZNCount-3;
end;


//  больше  заданного числа
function MoreThanZR(const WhatZR: ZReal; const ThanZR: ZReal): Boolean;
begin
  Result := ComparisonZR(WhatZR, ThanZR) > 0 ;
end;

// меньше  заданного числа
function LessThanZR(const WhatZR: ZReal; const ThanZR: ZReal): Boolean;
begin
  Result := ComparisonZR(WhatZR, ThanZR) < 0 ;
end;

// равно заданному числу
function EqvToZR(const WhatZR: ZReal; const ToZR: ZReal): Boolean;
begin
  Result := ComparisonZR(WhatZR, ToZR) = 0 ;
end;


// сумма нескольких ПОЛОЖИТЕЛЬНЫХ чисел ZReal (компактная форма записи)
function SumArrZR(const Arr: array of ZReal): ZReal;
// Copyright © 2005 Nikolai Victorovich Botcharov
var
  i,n,k,n_min,n_max: Integer;
  BaseArr: TDynArrZR;
  ArrBak1: TDynArrZR;
//  ArrBak2: TDynArrZR;
  IndMax2, IndMin2: Integer;
  Ind: ShortInt;
begin
  Result:=DefaultZR;
  n:=Length(Arr);

  if n=0 then Exit else
  begin
    SetLength(BaseArr,n);
    for i:=0 to High(Arr) do BaseArr[i]:=Arr[i]; // формирование копии массива мультиразрядных чисел
  end;

  if n>2 then
  begin
// производим предварительную сортировку элементов по возрастанию в целях
// устранения потери влияния на результат элементов массива с малыми значениями.
// Внимание! На обработку случая с отрицательными числами входящего массива или
// с разными унарными знаками у элементов массива нижеследующий алгоритм не предусмотрен.
// Для этого потребуется переработка функции MaxMinfromArrZR(MinMaxfromArrZR)
// для массивов с разными унарными знаками, и учёт всех случаев вытекающих из новой функции.
    Ind:=MaxMinfromArrZR(BaseArr, IndMax2, IndMin2);
{
Здесь Ind может принимать значения:
-1 - убывающий числовой массив
 0 - массив одинаковых элементов
 1 - возрастающий числовой массив
 2 - "нелинейный" числовой массив
}
    if Ind = -1 then
    begin
      for i:=n-1 downto 0 do
      begin
        Result:=SumZR(Result,BaseArr[i]); // суммирование с конца
      end;
    end
    else if Ind = 0 then
         begin
           Result:=MultZR(BaseArr[0],IntToZR(n));
         end
         else if Ind = 1 then
              begin
// можем перейти к непосредственному суммированию
                for i:=0 to n-1 do
                begin
                  Result:=SumZR(Result,BaseArr[i]); // суммирование с начала
                end;
              end
              else if Ind = 2 then
                   begin
// предварительная пересортировка массива
//                     ArrBak2:=Copy(BaseArr); // ради этой операции формировался массив BaseArr, правда, после редакции функции мы избавились и от этой операции
                     SetLength(ArrBak1,n);
// достаём максимум и минимум из исходного массива
                     n_min:=0;
                     n_max:=n-1;
                     ArrBak1[n_min]:=BaseArr[IndMin2];
                     ArrBak1[n_max]:=BaseArr[IndMax2];
// сжимаем исходный массив
                     if IndMin2>IndMax2 then  // удаляем, начиная с последнего элемента
                     begin
                       DelArrElem(BaseArr,IndMin2);
                       DelArrElem(BaseArr,IndMax2);
                     end
                     else
                     begin
                       DelArrElem(BaseArr,IndMax2);
                       DelArrElem(BaseArr,IndMin2);
                     end;
                     k:=Length(BaseArr);
// заходим в цикл
                     while k>1 do
                     begin
                       Inc(n_min);
                       Dec(n_max);
                       if Ind=1 then Ind:=MinMaxfromArrZR(BaseArr, IndMin2, IndMax2) // ищем новые минимум и максимум в возрастающем числовом массиве
                       else Ind:=MaxMinfromArrZR(BaseArr, IndMax2, IndMin2); // ищем новые максимум и минимум во всех других случаях
                       if Ind=0 then Inc(IndMax2); // избегаем индексации одного и того же элемента
                       ArrBak1[n_min]:=BaseArr[IndMin2];
                       ArrBak1[n_max]:=BaseArr[IndMax2];
                       if IndMin2>IndMax2 then  // удаляем, начиная с последнего найденного элемента
                       begin
                         DelArrElem(BaseArr,IndMin2);
                         DelArrElem(BaseArr,IndMax2);
                       end
                       else
                       begin
                         DelArrElem(BaseArr,IndMax2);
                         DelArrElem(BaseArr,IndMin2);
                       end;
                       k:=Length(BaseArr);
                     end;

                     if k>0 then // достаём последний элемент из сокращаемого массива  ArrBak2=BaseArr
                     begin
                       Inc(n_min);
                       ArrBak1[n_min]:=BaseArr[0];
                       DelArrElem(BaseArr,0);
                     end;
// переходим к непосредственному суммированию
                     for i:=0 to n-1 do
                     begin
                       Result:=SumZR(Result,ArrBak1[i]); // суммирование с начала
                     end;
                   end;

  end  // if n>2
  else if n=1 then Result:=BaseArr[0]
  else if n=2 then Result:=SumZR(BaseArr[0],BaseArr[1]); // иначе ноль, см. первый оператор в функции (при этом мы уже не должны сюда попасть)
end;


// произведение нескольких чисел ZReal (компактная форма записи для перемножения нескольких чисел)
function MultArrZR(const Arr: array of ZReal): ZReal;
var
  i,n: Integer;
  BakMaxZNCount:Integer;
begin
  n:=Length(Arr);
  if n=0 then begin Result:=DefaultZR; Exit; end
  else if n=1 then begin Result:=Arr[0]; Exit; end
       else
       begin

// повышение точности вычисления функции
         if MaxZNCount=0 then MaxZNCount:=1;
         if InfZNCount<MaxZNCount then InfZNCount:=MaxZNCount;
         BakMaxZNCount:=MaxZNCount;
         MaxZNCount:=MaxZNCount+3; // для сохранения точности решения для 100000 членов произведения необходимо три запасных знака в числе (см. анализ функции вычисления факториала)

         Result:=OneZR;
         for i:=0 to n-1 do
         begin
           Result:=MultZR(Arr[i],Result);
         end;

         MaxZNCount:=BakMaxZNCount;
       end;
end;


// возведение числа в натуральную дробную степень
function FracRootZR(const ZR: ZReal; const Num, Den: Int64): ZReal;
// Copyright © 2005 Nikolai Victorovich Botcharov
// корень Den-степени из числа в степени Num (Integer NUMerator & DENominator of fraction)
// где Num - любое, а Den>1  (!)
// Если число Den нечетно, то можем взять корень из отрицательного числа !
// Здесь Квадратные корни берутся на 50% медленнее, чем функцией SqrtZR
Label 33,34;   // для пропуска итерационного метода нахождения решения, если приближённое значение даёт точное решение  //
var
  metod:Byte;
  Un:ShortInt;
  BakMaxZNCount:Integer;
  BakMaxZNCountOpt: Integer;
  expo,i:Integer;
  sp: Integer;
  inv: Boolean;
  eqv:ShortInt;
  ZR0, ZR1, ZR2, ZR3, ZR05, ZR4, ZR6, ZR7, ZR8: ZReal;   //
  den1:Int64;
  den1ZR: ZReal;
  den2:Int64;
  den0ZR: ZReal;
  KoeffZR, ZR16: ZReal;
  Exp:Int64;
  SQRPower: Int64;
  bool: Boolean;
  eps_guess: ZReal;
begin
  If Den<2 then
  begin
    Messages('Функция FracRootZR:'#13'Недопустимое значение знаменателя степенной дроби:'+
             #13'Den='+IntToStr(Den));
    defaultZZReal(8,Result);  // создание нулевого "масштабируемого" числа
    Exit;
  end;

  Result:=IntPowZR(ZR,Abs(Num));   // возводим аргумент функции в положительную степень

// крайние случаи:
  Un:=ComparisonZR(Result,DefaultZR);
// Аргумент в степени равен нулю
  if Un=0 then
  begin
    if Num<0 then
    begin
      Messages('Функция FracRootZR:'#13'Недопустимое значение аргумента функции.');
      defaultZZReal(8,Result);  // создание нулевого "масштабируемого" числа
    end
    else if Num=0 then Result:=OneZR;
    Exit;
  end;
// Аргумент в степени отрицателен
  if Un<0 then
  begin
      if (Den and 1)=1 then    // нечётное число Den
      begin
// Аргумент в степени равен минус единице
        if ComparisonZR(Result,minusOneZR)=0 then Exit
// Аргумент в степени не минус единица
        else  Result:=AbsZR(Result);
      end
      else
      begin
        Messages('Функция FracRootZR:'#13'Недопустимое значение аргумента функции.');
        defaultZZReal(8,Result);  // создание нулевого "масштабируемого" числа
        Exit;
      end;
  end
  else
  begin
// Аргумент в степени равен плюс единице
      if ComparisonZR(Result,OneZR)=0 then Exit;
  end;
// с крайними случаями закончили

// берём корень Den-степени

  metod:=1; //---! ! !--- Выберите метод приближённого вычисления корня (работаем только с положительным подкоренным аргументом)
{
   0:  метод Ньютона
   1:  метод ГАЛЛЕЯ    (рекомендуется, потому что часто работает быстрее метода Ньютона)
}
    case metod of
0:begin // -------------------------------  метод Ньютона
// Пусть f(x) = x^2 - ZR, где ZR - аргумент функции
// Тогда, задав x(0), будем вычислять x(i+1) = xn - f(x(i))/f'(x(i)),
// пока [x(i+1)-x(i)] > epsilon
//
// повышение точности вычисления корня Den-степени
  if MaxZNCount=0 then MaxZNCount:=1;
  if InfZNCount<MaxZNCount then InfZNCount:=MaxZNCount;
    BakMaxZNCount:=MaxZNCount;
    MaxZNCount:=MaxZNCount+3; // одного запасного знака на арифметические операции не хватает. Оптимально ? знаков
//
    sp:=0;
    inv:=False;
//
    if ComparisonZR(Result, OneZR)<1 then       // работаем с числами больше 1
    begin ZR0:=OneDivZR(Result); inv:=True; end
    else ZR0:=Result;
// сокращение области определения первого приближённого значения
// во-первых, узнаём степень подкоренного числа из показателя степени его старшей разрядной ециницы
    SQRPower:=HighDeciZR(ZR0,bool).E; // bool в этом алгоритме нам не нужна
// во-вторых, поиск коэффициентов ZR16 (- коэффициент сжатия области) и KoeffZR (- коэффициент для решения функции)
    if SQRPower<Den then
    begin                                // "небольшое число" -  от 1 до 10^Den
      KoeffZR:=IntToZR(5);
      ZR16:=IntPowZR(KoeffZR,Den);
    end
    else                                 // ловим разрядную сетку числа
// показатель степени приближённого решения функции имеет критическое влияние
// на скорость сходимости итерационного метода
// поэтому ловим верхний разряд аргумента функции (по которому будем сокращать область назначения приближённого решения)
    begin
// ловить чётный или нечётный показатель степени на разрядной сетке, как для
// функции вычисления квадратного корня, не имеет  смысла, потому что мы
// всё-равно не сможем подобрать константу ZR16 и KoeffZR для области сжатия на
// разрядной сетке при произвольной целочисленной степени Den
// Поэтому будем рассматривать константы только кратные десяти
        ZR16:=OneZR;
        SQRPower:=SQRPower  div Den ; // нам требуется округление к меньшему числу
        KoeffZR:=OneZR;
        KoeffZR.E:=SQRPower;
        ZR16.E:=SQRPower*Den;
    end;
// в-третьих, сжатие области поиска корня
    eqv:=ComparisonZR(ZR0, ZR16);
    while eqv>0 do
    begin Inc(sp); ZR0:=DivZR(ZR0,ZR16); eqv:=ComparisonZR(ZR0, ZR16); end;
    if eqv=0 then // уже известно точное решение
    begin
      ZR1:=OneZR;
      Inc(sp);
      goto 33;
    end;
// всё, область поиска приближённого корня сокращена
//


// Начало оптимизации. - Opt - Opt - Opt - Opt - Opt - Opt - Opt - Opt - Opt -
   BakMaxZNCountOpt:=MaxZNCount;
   MaxZNCount:=13;
// При поиске приближённого решения проводим вычисления методом Ньютона на малой значности
    ZR1:=TwoZR; //   начальное приближение для оптимизационного алгоритма
    ZR3:=ZR1; // запоминаем первое приближение для анализа сходимости приближённого метода
    ZR05:=OneDivZR(IntToZr(Den));   // некоторая константа
    den1:=den-1;                    // некоторая константа
    den1ZR:=IntToZR(den1);
// первая итерация метода Ньютона по формуле
// 1/n * ( (n-1)*x + Арг / x^(n-1) ), где x - приближённое решение с предыдущего итерационного шага (или начальное приближение)
    ZR2:=DivZR(ZR0,IntPowZR(ZR1,den1)); ZR1:=SumZR(MultZR(ZR1,den1ZR),ZR2); ZR1:=MultZR(ZR1,ZR05);
    eps_guess:=HighDeciZR(ZR1,bool)  ;
    eps_guess.E:=eps_guess.E-MaxZNCount+2; // желаемая точность вычисления
    i:=1;
    while ComparisonZR(AbsZR(SubZR(ZR1,ZR3)), eps_guess)>0 do
// последующие итерации метода Ньютона
    begin
      Inc(i);   // подсчёт кол-ва итераций - видно только в отладчике
      ZR3:=ZR1;
      ZR2:=IntPowZR(ZR1,den1) ; // самая медленная операция
      ZR2:=DivZR(ZR0,ZR2);
      ZR1:=SumZR(MultZR(ZR1,den1ZR),ZR2);
      ZR1:=MultZR(ZR1,ZR05);
    end;
// Всё, начальное приближение найдено, теперь можно осуществлять поиск приближённого
// решения на полной значности
   MaxZNCount:=BakMaxZNCountOpt;
// Конец оптимизации.  - Opt - Opt - Opt - Opt - Opt - Opt - Opt - Opt - Opt -


//
// задание первого приближённого значения
// (удалили эту строчку после вставки оптимизационного блока)   ZR1:=TwoZR; //     RealToZR(4.64)  StrToZR('4641588834Z-9')  KoeffZR    OneZR

    ZR3:=ZR1; // запоминаем первое приближение для анализа сходимости приближённого метода

    ZR05:=OneDivZR(IntToZr(Den));   // некоторая константа
    den1:=den-1;                    // некоторая константа
    den1ZR:=IntToZR(den1);

// первая итерация метода Ньютона по формуле
// 1/n * ( (n-1)*x + Арг / x^(n-1) ), где x - приближённое решение с предыдущего итерационного шага (или начальное приближение)
    ZR2:=DivZR(ZR0,IntPowZR(ZR1,den1)); ZR1:=SumZR(MultZR(ZR1,den1ZR),ZR2); ZR1:=MultZR(ZR1,ZR05);

    eps_guess:=HighDeciZR(ZR1,bool)  ;
    eps_guess.E:=eps_guess.E-MaxZNCount+2; // желаемая точность вычисления
    i:=1;
    while ComparisonZR(AbsZR(SubZR(ZR1,ZR3)), eps_guess)>0 do  //
// последующие итерации метода Ньютона
    begin
      Inc(i);   // подсчёт кол-ва итераций - видно только в отладчике
      ZR3:=ZR1;
      ZR2:=IntPowZR(ZR1,den1) ; // самая медленная операция
      ZR2:=DivZR(ZR0,ZR2);
      ZR1:=SumZR(MultZR(ZR1,den1ZR),ZR2);
      ZR1:=MultZR(ZR1,ZR05);
    end;
// конец итерационного процесса поиска корня степени Den методом Ньютона

33: while sp>0 do begin Dec(sp); ZR1:=MultZR(ZR1,KoeffZR); end;
    if inv then ZR1:=OneDivZR(ZR1);
    Result:=ZR1;

    MaxZNCount:=BakMaxZNCount;
{
корень квадратный из двух 1000 знаков 13 итераций 1.3 сек
корень кубический из двух 1000 знаков 13 итераций 3.6 сек
корень 15 степени из двух 19 знаков 0,02 сек
корень 15 степени из двух 20 знаков цикл зависает  (поправили алгоритм, и пошли дальше)
корень 15 степени из 9999999999  32 знака 280 итераций 0,4 сек
корень 15 степени из 9999999999  8 знаков 275 итераций 0,09 сек

Итог:
Очень долгая операция. Здесь очень большое значение имеет первоначальное
приближение функции. В приведённых выше результатах использовалось начальное
приближение, равное Двум.
Решение проблемы может быть следующим: начальное приближение ищем на короткой
значности, а уже потом полное решение ищем на полной значности.

Проверяем работу функции при очень хорошем приближении начального решения
Возьмём корень 15 степени из числа 9999999999 с начальным приближением в три
точных знака - 4.64.
кол-во    время         число
знаков    вычисления    итераций
1000         5.7          10
 900         4.7          10
 800         3.7          10           (при начальном приближении только в один знак время вычисления увеличивается почти в два раза до 6,6 сек, а кол-во итераций до 17)
 700         2.9          10
 600         1.9           9
 500         1.3           9
 400         0.9           9
 300         0.45          8
 200         0.2           8
 100         0.04          7
  32         0.0           5
как видно из примера, время поиска приближённого решения квадратично падает
с увеличением необходимого числа знаков решения. Причём большее кол-во времени
приходится на операцию возведения числа в целочисленную степень.
Итак, со временем определения точного решения при хорошем начальном приближении
мы разобрались. Теперь реализуем способ нахождения хорошего начального приближения.

Как уже говорилось выше, хорошее приближение будем искать на низкой значности решения
тем же методом Ньютона. Замечено, что, например, на очень малой значности
предварительных вычислений (до 5 знаков) можно прийти  вообще к неправильному решению.
Почему это так, вопрос не изучался. Поэтому вне зависимости от потребностей задачи
первое приближение мы будем искать на 10(+3) знаках. Вычисления проходят не очень
быстро (~0,1 сек ; 137 итераций), однако приближение на первых 5 знаках должно
быть гарантированным, тогда повторный проход вычисления будет зависеть исключительно
от требуемой длины конечной точности решения функции.
Далее см. блок "оптимизации".

Результаты оптимизации
_________________________________
кол-во    время выч.   время выч.
знаков    до оптим.    после опт.
1000         5.7          4.6
 900         4.7          3.8
 800         3.7          2.6
 700         2.9          2.0
 600         1.9          1.5
 500         1.3          1.1
 400         0.9          0.6
 300         0.45         0.4
 200         0.2          0.2
 100         0.04         0.09
  32         0.0          0.06     (0,06 минимальное время работы функции после оптимизации)

Обнаружено, что время поиска решения для любого значения аргумента может
увеличиваться до 9,0 сек. (при точности вычислений в 1000 знаков)
Здесь также обнаружено, что по сравнению с вычислениями двойной точности Тип ZReal
всегда даёт точное решение с учётом правил округления. Ошибки в операциях двойной
точности возникают в последнем знаке при степени аргумента функции больше 500
по модулю.
}
  end;
1:begin  // - метод ГАЛЛЕЯ (с оптимизационным блоком, реализующем метод Ньютона)
// Пусть f(x) = x^2 - ZR, где ZR - аргумент функции. Тогда, задав x(0)
// будем вычислять x(i+1) = xn - f(x(i)) / f'(x(i)) / (1-  f(x(i))*f''(x(i)) / (2*f'(x(i))^2) )
// пока значение дроби больше некоторой величины epsilon
//
// повышение точности вычисления корня Den-степени
  if MaxZNCount=0 then MaxZNCount:=1;
  if InfZNCount<MaxZNCount then InfZNCount:=MaxZNCount;
    BakMaxZNCount:=MaxZNCount;
    MaxZNCount:=MaxZNCount+3; // одного запасного знака на арифметические операции не хватает. Оптимально ? знаков
//
    sp:=0;
    inv:=False;
//
    if ComparisonZR(Result, OneZR)<1 then       // работаем с числами больше 1
    begin ZR0:=OneDivZR(Result); inv:=True; end
    else ZR0:=Result;
// сокращение области определения первого приближённого значения
// во-первых, узнаём степень подкоренного числа из показателя степени его старшей разрядной ециницы
    SQRPower:=HighDeciZR(ZR0,bool).E; // bool в этом алгоритме нам не нужна
// во-вторых, поиск коэффициентов ZR16 (- коэффициент сжатия области) и KoeffZR (- коэффициент для решения функции)
    if SQRPower<Den then
    begin                                // "небольшое число" -  от 1 до 10^Den
      KoeffZR:=IntToZR(5);
      ZR16:=IntPowZR(KoeffZR,Den);
    end
    else                                 // ловим разрядную сетку числа
// показатель степени приближённого решения функции имеет критическое влияние
// на скорость сходимости итерационного метода
// поэтому ловим верхний разряд аргумента функции (по которому будем сокращать область назначения приближённого решения)
    begin
// ловить чётный или нечётный показатель степени на разрядной сетке, как для
// функции вычисления квадратного корня, не имеет  смысла, потому что мы
// всё-равно не сможем подобрать константу ZR16 и KoeffZR для области сжатия на
// разрядной сетке при произвольной целочисленной степени Den
// Поэтому будем рассматривать константы только кратные десяти
        ZR16:=OneZR;
        SQRPower:=SQRPower  div Den ; // нам требуется округление к меньшему числу
        KoeffZR:=OneZR;
        KoeffZR.E:=SQRPower;
        ZR16.E:=SQRPower*Den;
    end;
// в-третьих, сжатие области поиска корня
    eqv:=ComparisonZR(ZR0, ZR16);
    while eqv>0 do
    begin Inc(sp); ZR0:=DivZR(ZR0,ZR16); eqv:=ComparisonZR(ZR0, ZR16); end;
    if eqv=0 then // уже известно точное решение
    begin
      ZR1:=OneZR;
      Inc(sp);
      goto 34;
    end;
// всё, область поиска приближённого корня сокращена
//


// Начало оптимизации, как в методе Ньютона. - Opt - Opt - Opt - Opt - Opt -
   BakMaxZNCountOpt:=MaxZNCount;
   MaxZNCount:=16; // ранее использовалось 13 знаков
// При поиске приближённого решения проводим вычисления методом Ньютона на малой значности
    ZR1:=TwoZR; //   начальное приближение для оптимизационного алгоритма
    ZR3:=ZR1; // запоминаем первое приближение для анализа сходимости приближённого метода
    ZR05:=OneDivZR(IntToZr(Den));   // некоторая константа
    den1:=den-1;                    // некоторая константа
    den1ZR:=IntToZR(den1);
// первая итерация метода Ньютона по формуле
// 1/n * ( (n-1)*x + Арг / x^(n-1) ), где x - приближённое решение с предыдущего итерационного шага (или начальное приближение)
    ZR2:=DivZR(ZR0,IntPowZR(ZR1,den1)); ZR1:=SumZR(MultZR(ZR1,den1ZR),ZR2); ZR1:=MultZR(ZR1,ZR05);
    eps_guess:=HighDeciZR(ZR1,bool)  ;
    eps_guess.E:=eps_guess.E-MaxZNCount+2; // желаемая точность вычисления
    i:=1;
    while ComparisonZR(AbsZR(SubZR(ZR1,ZR3)), eps_guess)>0 do
// последующие итерации метода Ньютона
    begin
      Inc(i);   // подсчёт кол-ва итераций - видно только в отладчике
      ZR3:=ZR1;
      ZR2:=IntPowZR(ZR1,den1) ; // самая медленная операция
      ZR2:=DivZR(ZR0,ZR2);
      ZR1:=SumZR(MultZR(ZR1,den1ZR),ZR2);
      ZR1:=MultZR(ZR1,ZR05);
    end;
// Всё, начальное приближение найдено, теперь можно осуществлять поиск приближённого
// решения на полной значности
   MaxZNCount:=BakMaxZNCountOpt;
// Конец оптимизации.  - Opt - Opt - Opt - Opt - Opt - Opt - Opt - Opt - Opt -


//
// задание первого приближённого значения
// (удалили эту строчку после вставки оптимизационного блока)   ZR1:=TwoZR; //     RealToZR(4.64)  StrToZR('4641588834Z-9')  KoeffZR    OneZR

//    ZR3:=ZR1; // запоминаем первое приближение для анализа сходимости приближённого метода
// желаемая точность вычисления
    eps_guess:=HighDeciZR(ZR1,bool)  ;
    eps_guess.E:=eps_guess.E-MaxZNCount+2;

// некоторые константы
    ZR05:=StrToZR('0.5');  // 0.5
    den0ZR:=IntToZR(den);  // n
//    den1:=den-1;           // n-1
    den1ZR:=IntToZR(den-1); // n-1
    den2:=den-2;           // n-2

// первая итерация метода Галлея по формуле
// x - ( x^(n-1)*(x^n-Арг) ) /  ( n*[x^(n-1)]^2 - 0,5*(n-1)*x^(n-2)*(x^n-Арг) ),
// где x - приближённое решение с предыдущего итерационного шага (или начальное приближение)
    ZR2:=IntPowZR(ZR1,den2);// x^(n-2)
    ZR7:=MultZR(ZR1,ZR2);   // x^(n-1)
    ZR8:=MultZR(ZR1,ZR7);   // x^n
    ZR6:=SubZR(ZR8,ZR0);    // x^n - Арг
    ZR4:=MultZR(ZR7,ZR6);   // ( x^(n-1)*(x^n-Арг) )
    ZR3:=MultZR(MultZR(MultZR(ZR05,den1ZR),ZR2),ZR6);                // 0,5*(n-1)*x^(n-2)*(x^n-Арг)
    ZR3:=SubZR(MultZR(den0ZR,SQRZR(ZR7)),ZR3);  //    ( n*[x^(n-1)]^2 - 0,5*(n-1)*x^(n-2)*(x^n-Арг) )
    ZR3:=DivZR(ZR4,ZR3);   // ( x^(n-1)*(x^n-Арг) ) / ( n*[x^(n-1)]^2 - 0,5*(n-1)*x^(n-2)*(x^n-Арг) )
    ZR1:=SubZR(ZR1,ZR3);   // x - .../...
    i:=1;
    while ComparisonZR(AbsZR(ZR3), eps_guess)>0 do  //
// последующие итерации метода Галлея
    begin
      Inc(i);   // подсчёт кол-ва итераций - видно только в отладчике
//      ZR3:=ZR1;
      ZR2:=IntPowZR(ZR1,den2);// x^(n-2)
      ZR7:=MultZR(ZR1,ZR2);   // x^(n-1)
      ZR8:=MultZR(ZR1,ZR7);   // x^n
      ZR6:=SubZR(ZR8,ZR0);    // x^n - Арг
      ZR4:=MultZR(ZR7,ZR6);   // ( x^(n-1)*(x^n-Арг) )
      ZR3:=MultZR(MultZR(MultZR(ZR05,den1ZR),ZR2),ZR6);                // 0,5*(n-1)*x^(n-2)*(x^n-Арг)
      ZR3:=SubZR(MultZR(den0ZR,SQRZR(ZR7)),ZR3);  //    ( n*[x^(n-1)]^2 - 0,5*(n-1)*x^(n-2)*(x^n-Арг) )
      ZR3:=DivZR(ZR4,ZR3);   // ( x^(n-1)*(x^n-Арг) ) / ( n*[x^(n-1)]^2 - 0,5*(n-1)*x^(n-2)*(x^n-Арг) )
      ZR1:=SubZR(ZR1,ZR3);   // x - .../...
    end;
// конец итерационного процесса поиска корня степени Den методом Ньютона

34: while sp>0 do begin Dec(sp); ZR1:=MultZR(ZR1,KoeffZR); end;
    if inv then ZR1:=OneDivZR(ZR1);
    Result:=ZR1;

    MaxZNCount:=BakMaxZNCount;
{
Результаты метода Галлея по сравнению с результатами метода Ньютона
Возьмём корень 15 степени из числа 9999999999 с начальным приближением найденным методом Ньютона на малой разрядности
_________________________________
кол-во    время выч.   время выч.   время выч.
знаков    до оптим.    после опт.   мет. Галлея
1000         5.7          4.6        3.7
 900         4.7          3.8        3.0
 800         3.7          2.6        2.4
 700         2.9          2.0        1.9
 600         1.9          1.5        1.4
 500         1.3          1.1        1.0
 400         0.9          0.6        0.7
 300         0.45         0.4        0.3
 200         0.2          0.2        0.2
 100         0.04         0.09       0.09
  32         0.0          0.06       0.06
Есть заметное улучшение времени вычисления в данном примере. Для произвольных
значений аргумента функции время вычисления колеблется от 3.3 до 7.8   (на высокой значности решения)
Метод Галлея всегда хоть немного, но выигрывает у метода Ньютона.
Выигрыш составляет от долей процента, до 20%.
Удаётся ещё уменьшить время вычисления на большой значности решения, если
значение точности вычислений (MaxZNCount) в оптимизационном блоке, решаемом методом Ньютона,
увеличить до 16 знаков. Получаем дополнительное ускорение до 10% в самых продолжительных
по времени вычиления случаях. Дальнейшее увеличение точности вычислений
в оптимизационном блоке увеличивает общее время работы функции.
}
  end;
    end; // case

// обращаем результат, если степень отрицательная
  if Num<0 then Result:=OneDivZR(Result);
// возвращаем знак результату
  if Un<0 then Result:=InvertUnaryZR(Result);
end;


// Факториал
function FactorZR(const NF: Int64): ZReal;
// При значении аргумента свыше 1 000 000 точность работы функции не проверялась
// из-за её медлительности, а факториал предлагается находить по формуле Стирлинга точность которой 25 знаков.
// Оптимизация не коснулась ускорения выполнения функции
var
  i: Int64;
  BakMaxZNCount: Integer;
  NZR: ZReal;
begin
  if NF<0 then
  begin
    Messages('Функция FactorZR:'#13'Недопустимое значение аргумента функции.');
    defaultZZReal(8,Result);  // создание нулевого "масштабируемого" числа
    Exit;
  end;

  Case NF of
0..1:begin Result:=OneZR; Exit; end;
2:begin Result:=TwoZR; Exit; end;
  end; // case NF

// повышение точности вычисления факториала
  if MaxZNCount=0 then MaxZNCount:=1;
  if InfZNCount<MaxZNCount then InfZNCount:=MaxZNCount;
    BakMaxZNCount:=MaxZNCount;

// Оптимизация
   if NF<100001 then MaxZNCount:=MaxZNCount+3 // 3 знака для   100 000!
   else MaxZNCount:=MaxZNCount+4;             // 4 знака для 1 000 000!

  if NF<1000001 then
  begin
// точное вычисление Факториала
    Result:=IntToZR(NF);
    i:= NF-1 ;
    WHILE i>1 do begin Result:=MultZR(Result,IntToZR(i)); Dec(i); end;
{
100000!
эта функция считает 40.0 сек  для 1000 знаков точности
                     3.0 сек  для 32 знаков точности (погрешность задевает до трёх знаков)
                     3.5 сек  для 32+3 знаков точности (погрешность исчезает)
калькулятор Windows - 80 сек
____________________________
1 000 000!
4 знака точности   23.0 сек (за счёт оптимизации получаем точное! значение с учётом округления)
16 знаков точности 28.0 сек (за счёт оптимизации получаем точное! значение с учётом округления)
32 знака точности  39.0 сек (за счёт оптимизации получаем точное! значение с учётом округления)
____________________________
Каждое дальнейшее увеличение длины значения аргумента на один разряд относительно
числа 1 000 000 будет повышать время работы функции на порядок.
}

  end
  else  //  if NF < 1000001
  begin
// ----------   -  приближённое вычисление Факториала при больших N по формуле Стирлинга
// n! ~= (n/e)^n * Sqrt(2*Pi*n) * ( 1 + 1/(12*n) + 1/(288*n^2) - 139/51840n^3 + ...(?) )
// Похоже, продолжение функции надо выводить самому
        MaxZNCount:=MaxZNCount+2;
    NZR:=IntToZR(NF);
    Result:=SubZR(SumZR(SumZR(OneZR,OneDivZR(MultZR(NZR,IntToZR(12)))),
                        OneDivZR(MultZR(SqrZR(NZR),IntToZR(288)))),
                  DivZR(IntToZR(139),MultZR(IntPowZR(NZR,3),IntToZR(51840))));
    Result:=MultZR(Result,SqrtZR(MultZR(MultZR(TwoZR,NZR),Pi_ZR)));
    Result:=MultZR(IntPowZR(DivZR(NZR,e_ZR),NF),Result);
{
Результаты по точности формулы Стирлинга для различных аргументов
Пример: 1 000! =?
Вычисления проводились с любой точностью больше 32 знаков
совпадение с действительным числом - первые 15 знаков

Пример: 10 000! =?
Вычисления проводились с любой точностью больше 32 знаков
совпадение с действительным числом - первые 20 знаков

Пример: 100 000! =?
Вычисления проводились с любой точностью больше 32 знаков
совпадение с действительным числом - первые 24 знака

Пример: 1 000 000! =?
Вычисления проводились с любой точностью больше 32 знаков
совпадение с действительным числом - первые 27 знаков
}
  end;

  MaxZNCount:=BakMaxZNCount;

end;


// Константа e  (Число из 1000 знаков)
function e_ZR: ZReal;
// Copyright © 2005 Nikolai Victorovich Botcharov
var
  BakMaxZNCount:Integer;
  i,k,l:Integer;
  metod:Byte;
  eps_guess: ZReal;
  bool:Boolean;
  ZR3: ZReal;
  nZR: ZReal;
  iZR: ZReal;
  mZR: ZReal;
  kZR: TDynArrZR;
  d1, d2, d3: ZReal;
begin

  metod:=0; // выберите метод вычисления числа e
{
  0: строковая константа:   Result:=StrToZR('2,71828182845904523536028747135266249775724709369996');
  1: классический метод: e = 1 + 1/1 + 1/(1*2) + 1/(1*2*3) + 1/(1*2*3*4) + ...
  2: альтернативный алгоритм вычисления функции на основе классического метода
  3: The constant e. © Xavier Gordon, numbers.computation.free.fr (Оптимальный вариант вычисления числа e)
}
    case metod of
0:begin
      Result:=StrToZR(
'27182818284590452353602874713526624977572470936999595749669676277240766303535'+
'47594571382178525166427427466391932003059921817413596629043572900334295260595'+
'63073813232862794349076323382988075319525101901157383418793070215408914993488'+
'41675092447614606680822648001684774118537423454424371075390777449920695517027'+
'61838606261331384583000752044933826560297606737113200709328709127443747047230'+
'69697720931014169283681902551510865746377211125238978442505695369677078544996'+
'99679468644549059879316368892300987931277361782154249992295763514822082698951'+
'93668033182528869398496465105820939239829488793320362509443117301238197068416'+
'14039701983767932068328237646480429531180232878250981945581530175671736133206'+
'98112509961818815930416903515988885193458072738667385894228792284998920868058'+
'25749279610484198444363463244968487560233624827041978623209002160990235304369'+
'94184914631409343173814364054625315209618369088870701676839642437814059271456'+
'35490613031072085103837505101157477041718986106873969655212671546889570350354021234078Z-1009');

// 27182818284590452353602874713526624977572470936999595749669676277240766303535475945713821785251664274274663919320030599218174135966290435729003342952605956307381323286279434907632338298807531952510190115738341879307021540891499348841675092447614606680822648001684774118537423454424371075390777449920695517027618386062613313845830007520449338265602976067371132007093287091274437470472306969772093101416928368190255151086574637721112523897844250569536967707854499699679468644549059879316368892300987931277361782154249992295763514822082698951936680331825288693984964651058209392398294887933203625094431173012381970684161403970198376793206832823764648042953118023287825098194558153017567173613320698112509961818815930416903515988885193458072738667385894228792284998920868058257492796104841984443634632449684875602336248270419786232090021609902353043699418491463140934317381436405462531520961836908887070167683964243781405927145635490613031072085103837505101157477041718986106873969655212671546889570350354021234078Z-1009

  end;

1:begin  // классический метод: e = 1 + 1/1 + 1/(1*2) + 1/(1*2*3) + 1/(1*2*3*4) + ...
// для вычисления 1000 знаков потребуется 450 членов бесконечного разложения
// повышение точности вычисления функции
         if MaxZNCount=0 then MaxZNCount:=1;
         if InfZNCount<MaxZNCount then InfZNCount:=MaxZNCount;
         BakMaxZNCount:=MaxZNCount;
         MaxZNCount:=MaxZNCount+3; // для сохранения точности решения для 100000 членов произведения(деления) необходимо три запасных знака в числе (см. анализ функции вычисления факториала)

         Result:=TwoZR;  // начальное приближение
         ZR3:=StrToZR('0,5');
         eps_guess:=HighDeciZR(ZR3,bool); // bool здесь не используется
         eps_guess.E:=eps_guess.E - MaxZNCount + 2; // желаемая точность вычисления
         i:=2;
         while ComparisonZR(ZR3, eps_guess)>0 do
         begin
           Result:=SumZR(Result,ZR3);
           Inc(i);
           ZR3:=DivZR(ZR3,IntToZR(i));
         end;
         MaxZNCount:=BakMaxZNCount;
{
1010 знаков вычисляются суммой 455 членов ряда за 5.0 секунд
}
  end;

2:begin  // попытка ускоренного вычисления для классического метода
// смысл ускорения в уменьшении числа операций деления до одной с помощью вычисления обратной функции 1/e
// Однако последний метод построен на расходе памяти динамическим массивом TDynArrZR  "масштабируемых" действительных чисел

// локальное повышение точности вычисления функции
         if MaxZNCount=0 then MaxZNCount:=1;
         if InfZNCount<MaxZNCount then InfZNCount:=MaxZNCount;
         BakMaxZNCount:=MaxZNCount;
         MaxZNCount:=MaxZNCount+3; // для сохранения точности решения для 100000 членов произведения необходимо три запасных знака в числе (см. анализ функции вычисления факториала)

         i:=1;
         nZR:=OneZR;
         while HighDeciZR(nZR,bool).E<=BakMaxZNCount do
         begin
           Inc(i);
           iZR:=IntToZR(i);
           nZR:=MultZR(nZR,iZR);  // n!
           if i>2 then
           begin
             l:=i-3;
             SetLength(kZR,l+1);
             kZR[l]:=iZR;
             if (l)>0 then
               for k:=0 to l-1 do  kZR[k]:=MultZR(kZR[k],kZR[l]);
           end; // в этом алгоритме максимальное i всегда должно быть больше 3. Это необходимо, чтобы дальше не осуществлять проверку на пустой массив kZR

         end;

         mZR:=SumArrZR(kZR);
         mZR:=SumZR(mZR,OneZR);
         mZR:=SumZR(mZR,MultZR(nZR,TwoZR));

         Result:=DivZR(mZR,nZR);

         MaxZNCount:=BakMaxZNCount;
{
1010 знаков вычисляются 9.6 секунд
Оптимизации по времени не получилось, потому что уменьшение количества
операций деления привело к появлению невообразимого количества операций умножения.
}
  end;

3:begin  // The constant e.    © Xavier Gordon, numbers.computation.free.fr
// 5. e and permutations.
// Полагая d(i) = (i-1)*(d(i-1)+d(i-2)). где d(1)=0 и  d(2)=1,
// можем вычислить d(i)/i! =1/e
// Для i=7 имеем только 4 знака точности.
// Если не использовать операции деления внутри цикла, то придётся исследовать сходимость метода обычным перебором

// повышение точности вычисления функции
         if MaxZNCount=0 then MaxZNCount:=1;
         if InfZNCount<MaxZNCount then InfZNCount:=MaxZNCount;
         BakMaxZNCount:=MaxZNCount;
         MaxZNCount:=MaxZNCount+3; // для сохранения точности решения для 100000 членов произведения необходимо три запасных знака в числе (см. анализ функции вычисления факториала)

// Начало оптимизационного блока
// Строим здесь факториал nZR и определяем по нему количество членов ряда
// для обеспечения необходимой точности вычисления функции
    nZR:=OneZR;
    i:=2;
    WHILE HighDeciZR(nZR,bool).E < MaxZNCount do
    begin
      nZR:=MultZR(nZR,IntToZR(i));
      Inc(i);
    end;
    Dec(i);
    Dec(i);
// Конец оптимизационного блока

    d1:=DefaultZR;
    d2:=OneZR;

    for i:=2 to i do   //    for i:=3 to 70 do    - исправление после добавки оптимизационного блока
    begin
      d3:=MultZR(SumZR(d1,d2),IntToZR(i));   // d3:=MultZR(SumZR(d1,d2),IntToZR(i-1));  - исправление после добавки оптимизационного блока
      d1:=d2;
      d2:=d3;
    end;
    Result:=DivZR(nZR,d3);  // DivZR(FactorZR(70),d3)  - исправление после добавки оптимизационного блока

         MaxZNCount:=BakMaxZNCount;
{
вычисления до оптимизации
1010 знаков вычисляются суммой 455 членов ряда за 0.2 секунды
10000 знаков вычисляются суммой 3300 членов ряда за 21.0 секунду

точность  Треб. кол-во
решения   членов ряда
  100          70
 1000         450
10000        3300
Чтобы автоматически обеспечить требуемую точность вычислений, можно
вставить алгоритм вычисления факториала внутрь этой процедуры.
Факториал необходимо считать в цикле i до тех пор, пока не выполнится условие:
HighDeciZR(FactorZR(i),bool).E > MaxZNCount

Итог оптимизации:
 1000 знаков вычисляются 0.2 сек    (!)
10000 знаков вычисляются 19.0 сек
}
  end;
    end; // case metod
end;


// возведение числа e в действительную степень
function ePowZR(const ZR: ZReal): ZReal;
// Copyright © 2005 Nikolai Victorovich Botcharov
// Здесь использовано ограничение для ZR: |ZR| < High(Int64) div 100 (максимальное абсолюное значение степени, на которое можно возвести число e)
var
  BakMaxZNCount:Integer;
  BakMaxZNCountOpt:Integer;
  i,l:Integer;
  metod:Byte;
  eps_guess: ZReal;
  bool:Boolean;
  ZR3,ZR2,ZR1,ZR4: ZReal;
  NumZR, DenZR: ZReal;
  appr: Boolean;
  bool1, bool2: Boolean;
  expdiff: Int64;
  accur: Cardinal;
  iZR: Int64;
  iReal: ZReal;
  locRoundZN: Byte;
  ZR0: ZReal;
  k: Integer;
begin
// особые случаи
  if EqvToZR(ZR,DefaultZR) then begin Result:=OneZR; Exit; end;
  if EqvToZR(ZR,OneZR) then begin Result:=e_ZR; Exit; end;
  if EqvToZR(ZR,minusOneZR) then begin Result:=OneDivZR(e_ZR); Exit; end;
//  if EqvToZR(ZR,StrToZR('0,5')) then begin Result:=SqrtZR(ZR); Exit; end;      // если не планируется исследовать функцию, то лучше снять комментарий
//  if EqvToZR(ZR,StrToZR('-0,5')) then begin Result:=OneDivZR(SqrtZR(ZR)); Exit; end; // если не планируется исследовать функцию, то лучше снять комментарий

    if ComparisonZR(AbsZR(ZR),IntToZR(92233720368547758)) > 0 then  // DivZR(IntToZR(High(Int64)),IntToZR(100))
    begin
      Messages('Функция ePowZR:'#13'Недопустимое значение аргумента.'+#13+
               'Оно больше максимально допустимого целого числа'+
               'High(Int64) div 100.');
      defaultZZReal(8,Result);  // создание нулевого "масштабируемого" числа
      Exit;
    end;

  metod:=3; // выберите метод вычисления функции e^x
{
  0: классический метод (не самый лучший способ считать на длинных числах, особенно с аргументом больше единицы)
  1: метод, обращающийся к функции возведения в целую степень
  2: вторая реализация классического метода (...)
  3: оптимизированный алгоритм для классического метода  (Рекомендуется)

Метод "возведения в целую степень" не дал ничего в прикладном плане, но в практическом - позволил
обнаружить отсутствие оптимизационного блока повышения точности расчётов в алгоритме перед вызовом функции IntPowZR,
и показавшего важность алгоритмических операций, связанных с повышением точности вычислений.
}
    case metod of
0:begin   //                                            (1-й алг.)
// классический метод: e^x = 1 + x/1 + x^2/(1*2) + x^3/(1*2*3) + x^4/(1*2*3*4) + ...
// Ранее предусмотрено ограничения на входящий аргумент,
// чтобы не упираться в плюс или минус бесконечность при вычислении очередного члена ряда.
// Для калькулятора Windows это числа плюс и минус 10 000 с хвостиком.

// Здесь есть одна очевидная неприятная вещь, что на числах x>1 функция будет работать
// очень медленно на длинных числах, поскольку сходимость используемого разложения
// до 1000 знаков требует не менее 450 его членов. (см. функцию e_ZR)

         if MaxZNCount=0 then MaxZNCount:=1;
         if InfZNCount<MaxZNCount then InfZNCount:=MaxZNCount;
         BakMaxZNCount:=MaxZNCount;
         MaxZNCount:=MaxZNCount+4;

         Result:=SumZR(ZR,OneZR);  // начальное приближение
         ZR3:=DivZR(SQRZR(ZR),TwoZR);

         eps_guess:=OneZR; //
         eps_guess.E:=eps_guess.E - BakMaxZNCount-1; // желаемая точность вычисления

// к анализу, почему 2-й алг. выполняется на порядок дольше, чем  1-й алг.
//         NumZR:=ZR;                // для холостого счёта
//         DenZR:=OneZR;             // для холостого счёта
//         ZR1:=SumZR(OneZR,NumZR);  // для холостого счёта
//         ZR4:=DenZR;               // для холостого счёта

         i:=2;
         ZR2:=SumZR(Result,ZR3);   // второе приближение
         while ComparisonZR(AbsZR(SubZR(ZR2,Result)),eps_guess)>0 do
         begin
// к анализу, почему 2-й алг. выполняется на порядок дольше, чем  1-й алг.
//           NumZR:=MultZR(NumZR,ZR);         // холостой счёт // ~450 операций 0,04 сек - перемножение "короткого" числа на нарастающее
//           DenZR:=MultZR(DenZR,IntToZR(i)); // холостой счёт // ~450 операций 0,05 сек - перемножение коротких целых чисел
//           ZR1:=MultZR(ZR1,DenZR);          // холостой счёт // ~450 операций 15,5 сек - перемножение нарастающего числа на короткое целое
//           ZR4:=MultZR(NumZR,ZR4);          // холостой счёт // ~450 операций 17,2 сек - перемножение длинных чисел
//           ZR1:=SumZR(ZR1,ZR4);             // холостой счёт // ~450 операций 0,05 сек - сумма длинных чисел    (длинное число - число в 1000 знаков)
           Result:=ZR2;
           Inc(i);
           ZR3:=DivZR(ZR3,IntToZR(i));        // деление длинного числа на короткое целое число
           ZR3:=MultZR(ZR3,ZR);               // перемножение "короткого" числа на длинное
           ZR2:=SumZR(Result,ZR3);   // последующие приближения
         end;

         MaxZNCount:=BakMaxZNCount;
{
время работы функции для 32 знаков точности
e^1000  -  0,6 сек
e^10000 -  4,7 сек
время работы функции для 1000 знаков точности
e^0,99  -  4,6 сек
e^0,(9) - 49,2 сек  (аргумент, длиной 1000 знаков)    48971

проверка сходимости решения для примера: e^10000
8,8068182256629215872614960076446e+4342            - Калькулятор Windows
 880681822566292158726149600764456100352000Z+4301  - 42 знака  ~5,5 сек
 88068182256629215872614960076446Z+4311            - 32 знака  ~4,3 сек

проверка сходимости решения для примера: e^1000
 19700711140170469938888793522433Z+403             - 32 знака  ~0,5 сек
1,9700711140170469938888793522433e+434             - Калькулятор Windows

проверка сходимости решения для примера: e^100
 26881171418161354484126255515800Z+12              - 32 знака  ~0,1 сек
2,68811714181613544841262555158e+43                - Калькулятор Windows

проверка времени решения для примера: e^50000
 52977951644303153251357649986612Z+21683           - 32 знака  ~20,1 сек

проверка сходимости решения для примера: e^0,99145827390123874109235
 26951618922733984607122176609105111545648...Z-999 - 1000 знаков  ~5,0 сек
2,6951618922733984607122176609105                  - Калькулятор Windows
}
  end;

1:begin  // метод возведения в целую степень
// может работать только на коротких числах: Int64,
// т.е. до 18 знаков в основании числа и не меньше нуля в показателе степени.
// Тогда ход решения будет иметь вид:

    ZR3:=ZR;
    ZR3:=RefreshZR(ZR3); // удаление концевых нулей
    l:=Length(IntToStr(High(Int64)));
    if ((HighDeciZR(ZR3,bool).E<l) and (LowDeciZR(ZR3).E>=0)) then  // проверка вхождения мантиссы числа в диапазон мантиссы целого числа
    begin

         if MaxZNCount=0 then MaxZNCount:=1;
         if InfZNCount<MaxZNCount then InfZNCount:=MaxZNCount;
         BakMaxZNCount:=MaxZNCount;
         MaxZNCount:=MaxZNCount+3+Length(ZrToStr(ZR3)); // последний член в оптимизационном модуле снял проблему с неточностью работы функции  IntPowZR !!!!!!!!!!

        Result:=IntPowZR(e_ZR,ZrToInt(ZR3));

         MaxZNCount:=BakMaxZNCount;
{
Здесь обнаружено, что на сто значном числе при его возведении в степень
991458273901238741
получаем решение с 18 неверными последними знаками   (проблемма решена выше, в строке: MaxZNCount:=MaxZNCount+3+  Length(ZrToStr(ZR3));)
}
    end
    else
    begin
      Messages('Функция ePowZR:'#13'Недопустимое значение аргумента функции.');
      defaultZZReal(8,Result);  // создание нулевого "масштабируемого" числа
      Exit;
    end;
  end;

2:begin   // вторая реализация классического метода     (2-й алг.)
// классический метод: e^x = 1 + x/1 + x^2/(1*2) + x^3/(1*2*3) + x^4/(1*2*3*4) + ...
// Цель нижеизложенного алгоритма - попытаться ускорить выполнение операции на длинных числах, убрав из цикла операцию деления

         if MaxZNCount=0 then MaxZNCount:=1;
         if InfZNCount<MaxZNCount then InfZNCount:=MaxZNCount;
         BakMaxZNCount:=MaxZNCount;
         MaxZNCount:=MaxZNCount+4;
         accur:=MaxZNCount - 3  ;

         NumZR:=ZR;
         DenZR:=OneZR;

         ZR2:=SumZR(OneZR,NumZR);
         ZR3:=DenZR;
         i:=1;

         expdiff:=(HighDeciZR(DenZR,bool1).E - HighDeciZR(NumZR,bool2).E);
         appr:= expdiff < accur ;

         while appr do     // пока не будет обеспечена требуемая точность
         begin
           NumZR:=MultZR(NumZR,ZR);
           Inc(i);
           DenZR:=MultZR(DenZR,IntToZR(i));
           ZR2:=SumZR(MultZR(ZR2,DenZR),MultZR(NumZR,ZR3)); // если данное выражение расписать по операциям, то для 450 шагов цикла выигрыш составит приблизительно 0,2 сек
           ZR3:=MultZR(ZR3,DenZR);
// таким образом во втором алгоритме произведена замена операций [одно деление, одно произведение, одна сумма] с тремя переменными
// из первого алгоритма на операции [пять произведений, одна сумма] с четырьмя переменными. Операция деления вынесена за пределы цикла
           expdiff:=(HighDeciZR(DenZR,bool1).E - HighDeciZR(NumZR,bool2).E);
           if bool1 or bool2 then
           begin
            Messages('Функция ePowZR не может быть завершена с необходимой точностью.'+
                     #13'Достигнутая точность функции '+IntToStr(expdiff)+' знака(ов)');
            Break;
           end;
           appr:= expdiff < accur ;
         end;

         Result:=DivZR(ZR2,ZR3);

         MaxZNCount:=BakMaxZNCount;
{
время работы функции
                        классич. м.    классич. м.
                        1-й алг.       2-й алг.
e^0,99  (1000 знаков) -  4,6 сек       48,9 сек
e^0,(9) (1000 знаков) - 49,2 сек      110,0 сек
e^1000  (  32 знака ) -  0,6 сек        1,5 сек
e^10000 (  32 знака ) -  4,7 сек       15,0 сек
}
  end;

3:begin   // оптимизированный алгоритм для классического метода
// классический метод: e^x = 1 + x/1 + x^2/(1*2) + x^3/(1*2*3) + x^4/(1*2*3*4) + ...
// если x>1, то x:=Int64(x)+fraction(x) e^x = e^Int64(x) * e^fraction(x)

      if MaxZNCount=0 then MaxZNCount:=1;
      if InfZNCount<MaxZNCount then InfZNCount:=MaxZNCount;

    iZR:=0;
    if ComparisonZR(AbsZR(ZR),OneZR)>=0  then // из числа можно достать целую часть
    begin
      locRoundZN:=RoundZN;
      RoundZN:=0; // назначаем обрезание числа
// далее нам усложнила жизнь переменная RealTypeShow
      if RealTypeShow then
      begin
        RealTypeShow:=False; // защищаемся от порчи данных в переменной ZR
        ZR0:=ZR;
        iZR := ZRToInt(ZR0); // изымаем целую часть из числа показателя степени (это число используется только в оптимизированном алгоритме для классического метода вычисления функции e^x)
        RealTypeShow:=True;
      end
      else
      begin
// иначе порча данных не предполагается
        ZR0:=ZR;
        iZR := ZRToInt(ZR0); // изымаем целую часть из числа показателя степени (это число используется только в оптимизированном алгоритме для классического метода вычисления функции e^x)
      end;
      RoundZN:=locRoundZN; // возвращаем правило округления чисел
      ZR0 := SubZR(ZR,IntToZR(iZR))  ; // дробная часть показателя степени
    end
    else ZR0 := ZR ;

// Возводим число e в целую степень

      BakMaxZNCount:=MaxZNCount;
      MaxZNCount:=MaxZNCount+3+Length(IntToStr(iZR));

// Первый множитель будущего решения
      if Abs(iZR)>0 then
        ZR1:=IntPowZR(e_ZR,iZR)
      else
        ZR1:=OneZR;

      MaxZNCount:=BakMaxZNCount;

      MaxZNCount:=MaxZNCount+4;
      If ComparisonZR(ZR0,DefaultZR)<>0 then
      begin

// повторное изъятие целого показателя степени
        k:=Length(ZR0.i);
         if k<100 then
         begin
          iZR:=100;
          iReal:=StrToZR('0,01');
         end
         else if k<500 then
              begin
                iZR:=1000000;     // 6
                iReal:=StrToZR('0,000001');   // 6
              end
              else // if k>499 then
                   begin
                     iZR:=10000000000;     // 10
                     iReal:=StrToZR('0,0000000001');   // 10
                   end;

         if ComparisonZR(AbsZR(ZR0),iReal)>0
         then
         begin
           MaxZNCount:=MaxZNCount+Length(IntToStr(iZR))+2;
           ZR0:=MultZR(ZR0,iReal);
         end
         else
         iZR:=0; // по этой переменной будем определять повторное изъятие целого показатеся степени

// переходим к возведению числа е в действительную степень
         accur:=MaxZNCount - 2  ;
         BakMaxZNCountOpt:=MaxZNCount; // BakMaxZNCountOpt не путать с  BakMaxZNCount

         Result:=SumZR(OneZR,ZR0);  // начальное приближение
         ZR3:=DivZR(SQRZR(ZR0),TwoZR);
         Result:=SumZR(Result,ZR3);   // второе приближение
         i:=2;

         expdiff:=(HighDeciZR(Result,bool1).E - HighDeciZR(ZR3,bool2).E);
         appr:= expdiff < accur ;

         while appr do     // пока не будет обеспечена требуемая точность
         begin
           Inc(i);
           if expdiff>0 then MaxZNCount:=MaxZNCount-expdiff; // перед основными арифметическими операциями итерационного процесса уменьшаем разрядность
// эта оптимизация по сокращению разрядности вычислений ускоряет работу цикла в два раза
           ZR3:=DivZR(ZR3,IntToZR(i));
           ZR3:=MultZR(ZR3,ZR0);
           MaxZNCount:=BakMaxZNCountOpt; // перед суммированием возвращаем разрядность
           Result:=SumZR(Result,ZR3);   // последующие приближения
           expdiff:=HighDeciZR(Result,bool1).E - HighDeciZR(ZR3,bool2).E;
{
           if bool1 or bool2 then  // сюда мы теперь не попадём
           begin
            Messages('Функция ePowZR не может быть завершена с необходимой точностью.'+
                     #13'Достигнутая точность функции '+IntToStr(expdiff)+' знака(ов)');
            Break;
           end;
}
           appr:= expdiff < accur ;
         end;

// предпоследнее восстановление решение
        if iZR<>0 then
        begin
          Result:=IntPowZR(Result,iZR)
        end;
      end
      else
      Result:=OneZR;

      Result:=MultZR(ZR1,Result); // окончательное решение после всех оптимизационных шагов

      MaxZNCount:=BakMaxZNCount;
{
время работы функции без потери точности
                        классич. м.    классич. м.
                        1-й алг.       Оптим. алг.
e^0,99  (1000 знаков) -  4,6 сек        2,0 сек
e^0,(9) (1000 знаков) - 49,2 сек        7,9 сек  (качественное ускорение работы функции на длинных числах)
e^1000  (  32 знака ) -  0,6 сек        0,0 сек  1,2 (1000 знаков)
e^10000 (  32 знака ) -  4,7 сек        0,0 сек  1,5 (1000 знаков)

где e=2,718281828459045235360287471352

Итог: Результат оптимизации - ускорение более, чем в пять раз
}
  end;
    end; // case metod
end;


// натуральный Логарифм
function LnZR(const ZR: ZReal): ZReal;
// Copyright © 2005 Nikolai Victorovich Botcharov
// Получилась самая медленная из всех функций, основанных на итерационном приближении
var
  BakMaxZNCount:Cardinal;
  BakMaxZNCountOpt:Cardinal;

  accur:Cardinal;
  appr:Boolean;
  bool1,bool2:Boolean;

  metod:Byte;

  i:Integer;
  expdiff: Int64;
  ZR0,ZR1,ZR2,ZR3,ZR4,ZR5: ZReal; //
  inc2short:Integer;
  inc3short:Integer;
  inc10short:Int64; // переменая работает со степенным показателем числа  (!)
  bool:Boolean;
  lzri:Integer;

const lzriBif=799;

begin
  if ComparisonZR(ZR,DefaultZR)<=0 then
  begin
    Messages('Функция LnZR:'#13'Недопустимое значение аргумента функции.');
    defaultZZReal(8,Result);  // создание нулевого "масштабируемого" числа
    Exit;
  end;
  if ComparisonZR(ZR,OneZR)=0 then
  begin
    Result:=DefaultZR;
    Exit;
  end;

  metod:=5; // выберите метод вычисления натурального Логарифма
{
  0: ln(x) = 2 * [ (x-1)/(x+1) + (x-1)^3/(3 * (x+1)^3) + ... ] при x>0
  1: ln(x) = (x-1)/x + (x-1)^2/(2 * x^2) + ...  при x>1/2
  2: ln(1-x) = - [ x + x^2/2 + x^3/3 + ... ]  при   -1 <= x < 1
  3: ln(1+x) =     x - x^2/2 + x^3/3 - ...    при   -1 < x <= 1
  4: ln(10)
  5: Универсальный алгоритм вычисления натурального логарифма
}
    case metod of
0:begin   // ln(x) = 2 * [ (x-1)/(x+1) + (x-1)^3/(3 * (x+1)^3) + ... ] при x>0

// подготовка к локальному повышению точности вычислений
      if MaxZNCount=0 then MaxZNCount:=1;
      if InfZNCount<MaxZNCount then InfZNCount:=MaxZNCount;
      BakMaxZNCount:=MaxZNCount;
// локальное повышение точности вычислений
      MaxZNCount:=MaxZNCount+3;
      BakMaxZNCountOpt:=MaxZNCount;
// точность приближённого решения
        accur:= MaxZNCount - 2  ;

        expdiff:=0;
        appr:= expdiff < accur ;
      ZR1:=SubZR(ZR,OneZR);
      ZR2:=SumZR(ZR,OneZR);
      ZR3:=SqrZR(ZR1);
      ZR4:=SqrZR(ZR2);
      Result:=DivZR(ZR1,ZR2);
      i:=0;
      while appr do
      begin
        Inc(i);
        MaxZNCount:=MaxZNCount-expdiff;
        ZR1:=MultZR(ZR1,ZR3);
        ZR2:=MultZR(ZR2,ZR4);
        ZR5:=DivZR(ZR1,ZR2);
        ZR5:=DivZR(ZR5,IntToZR(2*i+1));
        MaxZNCount:=BakMaxZNCountOpt;
        Result:=SumZR(Result,ZR5);
           expdiff:=HighDeciZR(Result,bool1).E - HighDeciZR(ZR5,bool2).E;
           appr:= expdiff < accur ;
      end;

      Result:=MultZR(Result,TwoZR);

      MaxZNCount:=BakMaxZNCount;
{
1000 знаков
Аргумент    время (сек)
0,1111111     209,0
1,1             8,1
2,1            34,0
чрезмерно медленная функция
}
  end;

1:begin   //  ln(x) = (x-1)/x + (x-1)^2/(2 * x^2) + ...  при x>1/2
      if ComparisonZR(ZR,StrToZR('0.5'))<=0 then
      begin
        Result:=DefaultZR;
        Messages('Функция LnZR:'#13'Значение аргумента меньше 0,5.');
        Exit;
      end;

// подготовка к локальному повышению точности вычислений
      if MaxZNCount=0 then MaxZNCount:=1;
      if InfZNCount<MaxZNCount then InfZNCount:=MaxZNCount;
      BakMaxZNCount:=MaxZNCount;
// локальное повышение точности вычислений
      MaxZNCount:=MaxZNCount+3;
      BakMaxZNCountOpt:=MaxZNCount;
// точность приближённого решения
        accur:= MaxZNCount - 2  ;

        expdiff:=0;
        appr:= expdiff < accur ;
      ZR1:=SubZR(ZR,OneZR);
      ZR2:=DivZR(ZR1,ZR);
      Result:=ZR2;
      i:=1;
      while appr do
      begin
        Inc(i);
           MaxZNCount:=MaxZNCount-expdiff; // Здесь без уменьшения разрядности алгоритм работает медленнее
        ZR2:=MultZR(ZR2,ZR1);
        ZR2:=DivZR(ZR2,ZR);
        ZR3:=DivZR(ZR2,IntToZR(i));
           MaxZNCount:=BakMaxZNCountOpt;
        Result:=SumZR(Result,ZR3);
           expdiff:=HighDeciZR(Result,bool1).E - HighDeciZR(ZR3,bool2).E;
           appr:= expdiff < accur ;
      end;

      MaxZNCount:=BakMaxZNCount;
{
этот алгоритм работает в два и более раз медленнее предыдущего алгоритма
}
  end;

2:begin   //  ln(1-x) = - [ x + x^2/2 + x^3/3 + ... ]  при   -1 <= x < 1
      if ComparisonZR(ZR,TwoZR)>0 then
      begin
        Result:=DefaultZR;
        Messages('Функция LnZR:'#13'Значение аргумента больше двух.');
        Exit;
      end;

// подготовка к локальному повышению точности вычислений
      if MaxZNCount=0 then MaxZNCount:=1;
      if InfZNCount<MaxZNCount then InfZNCount:=MaxZNCount;
      BakMaxZNCount:=MaxZNCount;
// локальное повышение точности вычислений
      MaxZNCount:=MaxZNCount+3;
      BakMaxZNCountOpt:=MaxZNCount;
// точность приближённого решения
        accur:= MaxZNCount - 2  ;

        expdiff:=0;
        appr:= expdiff < accur ;
      ZR0:=SubZR(OneZR,ZR); // начальное x
      ZR1:=ZR0;             // первый член разложения

      Result:=ZR1;
      i:=1;
      while appr do
      begin
        Inc(i);
           MaxZNCount:=MaxZNCount-expdiff; // Эта оптимизация по уменьшению разрядности ускоряет работу алгоритма
        ZR1:=MultZR(ZR1,ZR0);              // начальное число x в целой степени
        ZR2:=DivZR(ZR1,IntToZR(i));        // очередной член разложения
           MaxZNCount:=BakMaxZNCountOpt;
        Result:=SumZR(Result,ZR2);
           expdiff:=HighDeciZR(Result,bool1).E - HighDeciZR(ZR2,bool2).E;
           appr:= expdiff < accur ;
      end;

      MaxZNCount:=BakMaxZNCount;

      Result:=InvertUnaryZR(Result);
{
При аргументе в области единицы заметно ускорение вычисления натурального логарифма
относительного первого алгоритма, однако в других случаях по временному показателю
алгоритм остаётся ещё не пригодным для широкого его применения
}
  end;

3:begin   // ln(1+x) =     x - x^2/2 + x^3/3 - ...    при   -1 < x <= 1
      if ComparisonZR(ZR,TwoZR)>0 then
      begin
        Result:=DefaultZR;
        Messages('Функция LnZR:'#13'Значение аргумента больше двух.');
        Exit;
      end;

// подготовка к локальному повышению точности вычислений
      if MaxZNCount=0 then MaxZNCount:=1;
      if InfZNCount<MaxZNCount then InfZNCount:=MaxZNCount;
      BakMaxZNCount:=MaxZNCount;
// локальное повышение точности вычислений
      MaxZNCount:=MaxZNCount+3;
      BakMaxZNCountOpt:=MaxZNCount;
// точность приближённого решения
        accur:= MaxZNCount - 2  ;

        expdiff:=0;
        appr:= expdiff < accur ;
      ZR0:=SubZR(ZR,OneZR); // начальное x
      ZR1:=ZR0;             // первый член разложения

      Result:=ZR1;
      i:=1;
      while appr do
      begin
        Inc(i);
           MaxZNCount:=MaxZNCount-expdiff;   // Эта оптимизация по уменьшению разрядности ускоряет работу алгоритма
        ZR1:=MultZR(InvertUnaryZR(ZR1),ZR0); // начальное число x в целой степени
        ZR2:=DivZR(ZR1,IntToZR(i));          // очередной член разложения
           MaxZNCount:=BakMaxZNCountOpt;
        Result:=SumZR(Result,ZR2);
           expdiff:=HighDeciZR(Result,bool1).E - HighDeciZR(ZR2,bool2).E;
           appr:= expdiff < accur ;
      end;

      MaxZNCount:=BakMaxZNCount;
{
Алгоритм работает столько же времени, сколько и предыдущий алгоритм
}
  end;

4:begin   // ln(10)
// используя свойство логарифма: log(x1*x2) = log(x1) + log(x2) ,
// и зная значение натурального логарифма двух,
// максимально приблизим аргумент к единице. Остальное - дело техники.
// Примечание. Для вычисления натурального логарифма 10 потребуется 3 операции
// последовательного деления на два.
      ZR0:=TenZR;

// подготовка к локальному повышению точности вычислений
      if MaxZNCount=0 then MaxZNCount:=1;
      if InfZNCount<MaxZNCount then InfZNCount:=MaxZNCount;
      BakMaxZNCount:=MaxZNCount;
// локальное повышение точности вычислений
      MaxZNCount:=MaxZNCount+3;
      BakMaxZNCountOpt:=MaxZNCount;
// точность приближённого решения
        accur:= MaxZNCount - 2 ;

        expdiff:=0;
        appr:= expdiff < accur ;

// максимально приближаем значение аргумента (равного десяти) к единице
      inc2short:=0;
      for i:=1 to 3 do         // потом здесь будет стоять другое условие, организующее цикл и характеризующее приближение аргумента к единице
      begin
        Inc(inc2short);        // счётчик числа сокращений аргумента на два
        ZR0:=DivZR(ZR0,TwoZR);
      end;

// переходим к итерационному процессу вычисления натурального логарифма
      ZR0:=SubZR(ZR0,OneZR); // начальное x к вычислению логарифма итерационным процессом
      ZR1:=ZR0;             // первый член разложения

      Result:=ZR1;
      i:=1;
      while appr do
      begin
        Inc(i);
           MaxZNCount:=MaxZNCount-expdiff;   // Эта оптимизация по уменьшению разрядности ускоряет работу алгоритма
        ZR1:=MultZR(InvertUnaryZR(ZR1),ZR0); // начальное число x в целой степени
        ZR2:=DivZR(ZR1,IntToZR(i));          // очередной член разложения
           MaxZNCount:=BakMaxZNCountOpt;
        Result:=SumZR(Result,ZR2);
           expdiff:=HighDeciZR(Result,bool1).E - HighDeciZR(ZR2,bool2).E;
           appr:= expdiff < accur ;
      end;

// восстанавливаем историю сокращения аргумента
      Result:=SumZR(Result,MultZR(LnE2_ZR,IntToZR(inc2short)));

      MaxZNCount:=BakMaxZNCount;
{
время вычисления 1000 знаков ln(10) 54,0 сек. Результат размещён в константе LnE10_ZR
}
  end;

5:begin   // Универсальный алгоритм вычисления натурального логарифма
// используя свойство логарифма: log(x1*x2) = log(x1) + log(x2) ,
// и зная значения натурального логарифма двух, натурального логарифма трёх и  натурального логарифма десяти,
// максимально приблизим аргумент к единице. Остальное - дело техники.

// В этой процедуре нет смысла перерасчитывать ln(2), ln(3), ln(10)
      if ComparisonZR(ZR,TwoZR)=0 then begin Result:=LnE2_ZR; Exit; end;
      if ComparisonZR(ZR,ThreeZR)=0 then begin Result:=LnE3_ZR; Exit; end;
      if ComparisonZR(ZR,TenZR)=0 then begin Result:=LnE10_ZR; Exit; end;

// подготовка к локальному повышению точности вычислений
      if MaxZNCount=0 then MaxZNCount:=1;
      if InfZNCount<MaxZNCount then InfZNCount:=MaxZNCount;
      BakMaxZNCount:=MaxZNCount;
// локальное повышение точности вычислений
      lzri:=length(ZR.I);
      if lzri>lzriBif then MaxZNCount:=MaxZNCount+5
      else MaxZNCount:=MaxZNCount+3;
      BakMaxZNCountOpt:=MaxZNCount;
// точность приближённого решения
        accur:= MaxZNCount - 2 ;

        expdiff:=0;
        appr:= expdiff < accur ;

// приближение значения аргумента к единице
      ZR0:=ZR;
{
      inc2short:=0;
      if HighDeciZR(ZR0,bool).E>0 then
//        while not IsIn9_10(ZR0) do
        while not IsIn999_1000(ZR0) do  // применим более жёсткое условие
//        while not IsIn99999_100000(ZR0) do  // применим ещё более жёсткое условие (на практике оно редко достижимо, если число делить только на одно значение - 2)
        begin
          Inc(inc2short);        // счётчик числа сокращений аргумента на два
          ZR0:=DivZR(ZR0,TwoZR);
        end
      else
//        while not IsIn9_10(ZR0) do
        while not IsIn999_1000(ZR0) do  // применим более жёсткое условие
//        while not IsIn99999_100000(ZR0) do  // применим ещё более жёсткое условие
        begin
          Dec(inc2short);        // счётчик числа умножений аргумента на два
          ZR0:=MultZR(ZR0,TwoZR);
        end;
}
{
}
      inc2short:=0;
      inc3short:=0;

// максимально оптимизированный алгоритм приближения значения аргумента к единице
      if HighDeciZR(ZR0,bool).E>=High(Int64) then //      0     MaxInt

{
        if lzri>lzriBif then  // очень жёсткое условие может оказаться недостижимым в операциях деления

        while not IsIn99999_100000(ZR0) do  // сильно жестко
        begin
          if ((ZR0.I[High(ZR0.I)] in [2,4,8]) and (ZR0.I[High(ZR0.I)-1]<5)) or
             ((ZR0.I[High(ZR0.I)] in [1,3,7]) and (ZR0.I[High(ZR0.I)-1]>4)) then
          begin
            Inc(inc2short);        // счётчик числа сокращений аргумента на два
            ZR0:=DivZR(ZR0,TwoZR);
          end
          else //
          begin
            Inc(inc3short);        // счётчик числа сокращений аргумента на три
            ZR0:=DivZR(ZR0,ThreeZR);
          end;
        end

        else
}
        while not IsIn999_1000(ZR0) do  // несильно жестко
        begin
          if ((ZR0.I[High(ZR0.I)] in [2,4,8]) and (ZR0.I[High(ZR0.I)-1]<5)) or
             ((ZR0.I[High(ZR0.I)] in [1,3,7]) and (ZR0.I[High(ZR0.I)-1]>4)) then
          begin
            Inc(inc2short);        // счётчик числа сокращений аргумента на два
            ZR0:=DivZR(ZR0,TwoZR);
          end
          else //
          begin
            Inc(inc3short);        // счётчик числа сокращений аргумента на три
            ZR0:=DivZR(ZR0,ThreeZR);
          end;
        end

      else

        if lzri>lzriBif then

        while not IsIn99999_100000(ZR0) do  // сильно жестко
        begin
          if ((ZR0.I[High(ZR0.I)] in [2,4,8]) and (ZR0.I[High(ZR0.I)-1]<5)) or
             ((ZR0.I[High(ZR0.I)] in [1,3,7]) and (ZR0.I[High(ZR0.I)-1]>4)) then
          begin
            Dec(inc2short);        // счётчик числа умножений аргумента на два
            ZR0:=MultZR(ZR0,TwoZR);
          end
          else //
          begin
            Dec(inc3short);        // счётчик числа умножений аргумента на три
            ZR0:=MultZR(ZR0,ThreeZR);
          end;
        end

        else

        while not IsIn999_1000(ZR0) do  // несильно жестко
        begin
          if ((ZR0.I[High(ZR0.I)] in [2,4,8]) and (ZR0.I[High(ZR0.I)-1]<5)) or
             ((ZR0.I[High(ZR0.I)] in [1,3,7]) and (ZR0.I[High(ZR0.I)-1]>4)) then
          begin
            Dec(inc2short);        // счётчик числа умножений аргумента на два
            ZR0:=MultZR(ZR0,TwoZR);
          end
          else //
          begin
            Dec(inc3short);        // счётчик числа умножений аргумента на три
            ZR0:=MultZR(ZR0,ThreeZR);
          end;
        end;

      inc10short:=HighDeciZR(ZR0,bool).E;  // количество сокращений на 10
      ZR0:=DivZR(ZR0,IntPowZR(TenZR,inc10short));
      if ZR0.I[High(ZR0.I)]=9 then
      begin inc10short:=inc10short+1;  ZR0:=DivZR(ZR0,TenZR); end;

      if ComparisonZR(ZR0,OneZR)<>0 then // если мы ещё не совсем в единице, то
      begin
// переходим к итерационному процессу вычисления натурального логарифма
        ZR0:=SubZR(ZR0,OneZR); // начальное x к вычислению логарифма итерационным процессом
        ZR1:=ZR0;              // первый член разложения

        Result:=ZR1;
        i:=1;
        while appr do
        begin
          Inc(i);
             MaxZNCount:=MaxZNCount-expdiff;   // Эта оптимизация по уменьшению разрядности ускоряет работу алгоритма
          ZR1:=MultZR(InvertUnaryZR(ZR1),ZR0); // начальное число x в целой степени
          ZR2:=DivZR(ZR1,IntToZR(i));          // очередной член разложения
             MaxZNCount:=BakMaxZNCountOpt;
          Result:=SumZR(Result,ZR2);
             expdiff:=HighDeciZR(Result,bool1).E - HighDeciZR(ZR2,bool2).E;
             appr:= expdiff < accur ;
        end;
      end
      else  Result:=DefaultZR;
// восстанавливаем историю сокращения аргумента, имея ввиду, что от перерестановки мест слагаемых сумма не меняется.
      if inc2short<>0 then Result:=SumZR(Result,MultZR(LnE2_ZR,IntToZR(inc2short)));
      if inc3short<>0 then Result:=SumZR(Result,MultZR(LnE3_ZR,IntToZR(inc3short)));
      if inc10short<>0 then Result:=SumZR(Result,MultZR(LnE10_ZR,IntToZR(inc10short)));

      MaxZNCount:=BakMaxZNCount;
{
Проверка быстродействия функции для 1000 знаков (с условием IsIn9_10(ZR0)):
ln(11) - 34 сек
ln(14) - 35,0 сек
ln(2^100) - 20,5 сек

с более жёстким условием - IsIn999_1000(ZR0)
ln(11) - 11,8 сек     40  делений 299 итераций
ln(14) - 11,8 сек     336 делений 255 итераций
ln(2^100) - 0,1 сек   здесь обошлись одними делениями
ln(2^100+1) - 1,2 сек  100  делений 35 итераций
ln(2^100+100000) - 1,5 сек  100  делений 45 итераций

Правда, на коротких числах (до ста знаков), накладные расходы на удовлетворение
более жёстких условий увеличивают общее время вычислений почти в два раза.

Тестирование ещё более жесткого условия - IsIn99999_100000(ZR0)
ln(6) - 14,0 сек  с более жёстким условием
ln(6) - 13,4 сек  с ещё более жёстким условием - выигрыш по времени несущественный,
кроме того, чрезмерно возрасли накладные расходы - появилось много больше, чем 10 тыс операций,
что привело к появлению погрешности в последнем знаке

Исследования показали (результаты опущены), что увеличение значности для повышения
точности промежуточных вычислений не перекрывают выигрыш по времени от
ужесточения условия приближения промежуточного решения к условной единице.
Последнее условие имеет преимущество только на очень длинных числах,
когда в них более 800 знаков.
При всех оптимизациях на длинных числах (1000 знаков) функция всё-равно работает
до 17 секунд. Среднее значение временных затрат на работу функции - 13 секунд.
Если работать с длиной мантиссы числа  не более 100 знаков, то среднее время
работы функции не превышает 0,03 секунды.
}
  end;
    end; // case metod
end;


// Константа - натуральный Логарифм двух
function LnE2_ZR: ZReal;
// Copyright © 2005 Nikolai Victorovich Botcharov
{
натуральный Логарифм Двух Ln(2):
0,69314718055994530941723212145818
  69314718055994530941723212145818Z-32
}
var
  BakMaxZNCount:Cardinal;
  BakMaxZNCountOpt:Cardinal;

  accur:Cardinal;
  appr:Boolean;
  bool1,bool2:Boolean;

  metod:Byte;

  i:Integer;
  expdiff: Int64;
  hdec, hdec1:Int64;
  bool:Boolean;
  ZR,ZR0,ZR1,ZR2,ZR3,ZR4,ZR5,ZR6: ZReal; //
begin

  ZR:=TwoZR;

  metod:=3; // выберите метод вычисления натурального Логарифма
{
  0: log(2)=SUM( 1 / ( n * 2^n ) ) из статьи "Логарифм 2" (c) Xavier Gourdon, размещённой на algolist.manual.ru.
  1: log(2)=SUM( (1/n) * ( 1/(3^n) + 1/(4^n) ) из статьи "Логарифм 2" (c) Xavier Gourdon, размещённой на algolist.manual.ru.
  2: log(2) через гиперболические арктангенсы из статьи "Логарифм 2" (c) Xavier Gourdon, размещённой на algolist.manual.ru.
  3: строковая константа (1000 знаков)
}
    case metod of
0:begin   //    ln(2) = SUM(1/(n*2^n))
      if MaxZNCount=0 then MaxZNCount:=1;
      if InfZNCount<MaxZNCount then InfZNCount:=MaxZNCount;
      BakMaxZNCount:=MaxZNCount;
      MaxZNCount:=MaxZNCount+3;
      BakMaxZNCountOpt:=MaxZNCount;

         accur:=MaxZNCount - 2  ;


      ZR0:=OneDivZR(ZR);
      ZR2:=ZR0;
      Result:=ZR2;
{
      hdec1:=HighDeciZR(ZR0,bool).E  ;
      hdec:=hdec1;
      hdec1:= hdec1 - MaxZNCount + 2;
}
         expdiff:=0;
         appr:= expdiff < accur ;
      i:=1;
{
      while hdec > hdec1 do
}
      while appr do
      begin
        Inc(i);
//        MaxZNCount:=Abs(hdec-hdec1)+2;  // вставка этого условия затормаживает выполнение процедуры, причём затормаживание увеличивается с ростом стартовой разрядности вычислений
//        MaxZNCount:=MaxZNCount-expdiff;;  // что любопытно, затормаживание выполнения функции не зависит от того, каким образом мы подготавливаемся к временному уменьшению разрядности (Что-то тут непонятное творится?)
        ZR2:=MultZR(ZR2,ZR0);        // число в целой степени
        ZR1:=DivZR(ZR2,IntToZR(i));
{
        hdec:=HighDeciZR(ZR1,bool).E  ;
}
//        MaxZNCount:=BakMaxZNCountOpt;
        Result:=SumZR(Result,ZR1);
           expdiff:=HighDeciZR(Result,bool1).E - HighDeciZR(ZR1,bool2).E;
           appr:= expdiff < accur ;
      end;

      MaxZNCount:=BakMaxZNCount;
{
Ln(2)
(при выполнении вычислений без локальной оптимизации по длине разрядности чисел
0,03    32 зн.   103 чл.р.
0,3    100 зн.   328 чл.р.
34,0  1000 зн.  3314 чл.р.
}
  end;

1:begin   // log(2)=SUM( (1/n) * ( 1/(3^n) + 1/(4^n) )
      if MaxZNCount=0 then MaxZNCount:=1;
      if InfZNCount<MaxZNCount then InfZNCount:=MaxZNCount;
      BakMaxZNCount:=MaxZNCount;
      MaxZNCount:=MaxZNCount+3;

      ZR3:=OneDivZR(InttoZR(3));
      ZR4:=OneDivZR(InttoZR(4));
      ZR5:=ZR3;
      ZR6:=ZR4;
      ZR2:=SumZR(ZR3,ZR4);
      ZR1:=ZR2;
      Result:=ZR1;
      expdiff:=HighDeciZR(ZR1,bool).E - MaxZNCount + 2;
      i:=1;
      while HighDeciZR(ZR2,bool).E > expdiff do
      begin
        Inc(i);
//        ZR2:=SumZR(IntPowZR(ZR3,i),IntPowZR(ZR4,i));
        ZR5:=MultZR(ZR5,ZR3);  // замена  IntPowZR(ZR3,i)
        ZR6:=MultZR(ZR6,ZR4);  // замена  IntPowZR(ZR4,i)
        ZR2:=SumZR(ZR5,ZR6) ;
// быстрее заниматься перемножением, чем каждый раз возводить начальный аргумент в степень
        ZR1:=DivZR(ZR2,IntToZR(i));
        Result:=SumZR(Result,ZR1);
      end;

      MaxZNCount:=BakMaxZNCount;
{
Ln(2)
0,1  сек.    32 зн.    70 чл.р.
2,7  сек.   100 зн.   212 чл.р.
.... сек.  1000 зн.     ? чл.р. считает бесконечно долго
или
0,04  сек.    32 зн.   70 чл.р.
0,5   сек.   100 зн.  212 чл.р.
...........1000 зн.  более 1100  чл.р.  считает бесконечно долго
}
  end;

2:begin   // через гиперболические арктангенсы
// по теореме Sebah (1997) log(2)  = 6*arctanh(1/9) + 2*arctanh(3/253)  из статьи "Логарифм 2" (c) Xavier Gourdon, размещённой на algolist.manual.ru.

      MaxZNCount:=MaxZNCount+1;  // обязательно
    ZR1:=IntToZR(9);
    ZR1:=OneDivZR(ZR1);
    ZR1:=AtanhZR(ZR1);    // прежде в функции AtanhZR снимите скобки вида (* *)
    ZR1:=MultZR(IntToZR(6),ZR1);
    ZR2:=IntToZR(3);
    ZR2:=DivZR(ZR2,IntToZR(253));
    ZR2:=AtanhZR(ZR2);   // прежде в функции AtanhZR снимите скобки вида (* *)
    ZR2:=MultZR(IntToZR(2),ZR2);
    Result:=SumZR(ZR1,ZR2);
      MaxZNCount:=MaxZNCount-1;  // не забыть вернуть обратно
{
Ln(2)
// без оптимизации на время вычисления функции AtanhZR
32 зн.    0,01 сек.
100 зн.   0,1  сек.    - на коротких числах заметно ускорение
320 зн.   1,6  сек.
1000 зн. 37,8  сек.    - нет выигрыша во времени для длинных чисел
}
  end;

3:begin   //
      Result:=StrToZR(
'69314718055994530941723212145817656807550013436025525412068000949339362196969'+
'47156058633269964186875420014810205706857336855202357581305570326707516350759'+
'61930727570828371435190307038623891673471123350115364497955239120475172681574'+
'93206515552473413952588295045300709532636664265410423915781495204374043038550'+
'08019441706416715186447128399681717845469570262716310645461502572074024816377'+
'73389638550695260668341137273873722928956493547025762652098859693201965058554'+
'76470330679365443254763274495125040606943814710468994650622016772042452452961'+
'26879465461931651746813926725041038025462596568691441928716082938031727143677'+
'82654877566485085674077648451464439940461422603193096735402574446070308096085'+
'04748663852313818167675143866747664789088143714198549423151997354880375165861'+
'27535291661000710535582498794147295092931138971559982056543928717000721808576'+
'10252368892132449713893203784393530887748259701715591070882368362758984258918'+
'53530243634214367061189236789192372314672321720534016492568727477823445353476481149419Z-1010');

//  69314718055994530941723212145817656807550013436025525412068000949339362196969471560586332699641868754200148102057068573368552023575813055703267075163507596193072757082837143519030703862389167347112335011536449795523912047517268157493206515552473413952588295045300709532636664265410423915781495204374043038550080194417064167151864471283996817178454695702627163106454615025720740248163777338963855069526066834113727387372292895649354702576265209885969320196505855476470330679365443254763274495125040606943814710468994650622016772042452452961268794654619316517468139267250410380254625965686914419287160829380317271436778265487756648508567407764845146443994046142260319309673540257444607030809608504748663852313818167675143866747664789088143714198549423151997354880375165861275352916610007105355824987941472950929311389715599820565439287170007218085761025236889213244971389320378439353088774825970171559107088236836275898425891853530243634214367061189236789192372314672321720534016492568727477823445353476481149419Z-1010
  end;
    end; // case metod
end;


// Арктангенс гиперболический  (ареатангенс)
function AtanhZR(const ZR: ZReal ): ZReal;
var
  BakMaxZNCount:Cardinal;
  BakMaxZNCountOpt:Cardinal;
  accur:Cardinal;
  appr:Boolean;
  bool1,bool2:Boolean;
  i:Integer;
  expdiff: Int64;
  ZR0,ZR1,ZR2,ZR3: ZReal;
begin
  if ComparisonZR(AbsZR(ZR),OneZR)>=0 then
  begin
    Messages('Функция AtanhZR:'#13'Недопустимое значение аргумента функции.');
// в плюс/минус единице есть решение - плюс/минус бесконечность    - здесь не рассматривается
    defaultZZReal(8,Result);  // создание нулевого "масштабируемого" числа
    Exit;
  end;
(*
  if ComparisonZR(AbsZR(ZR),StrToZR('0,2'))<=0 then
  begin

// подготовка к локальному повышению точности вычислений
      if MaxZNCount=0 then MaxZNCount:=1;
      if InfZNCount<MaxZNCount then InfZNCount:=MaxZNCount;
      BakMaxZNCount:=MaxZNCount;
// локальное повышение точности вычислений
      MaxZNCount:=MaxZNCount+3;
      BakMaxZNCountOpt:=MaxZNCount;
// точность приближённого решения
        accur:= MaxZNCount - 2  ;

// arctanh(x) = x + x^3/3 + x^5/5 + ...
// разложение действительно при |x|<1
      Result:=ZR;
        expdiff:=0;
        appr:= expdiff < accur ;
      ZR2:=SqrZR(ZR);
      ZR1:=Result;
      i:=1;
      while appr do
      begin
        Inc(i);
        Inc(i);
        MaxZNCount:=MaxZNCount-expdiff;
        ZR1:=MultZR(ZR1,ZR2);
        ZR3:=DivZR(ZR1,IntToZR(i));
        MaxZNCount:=BakMaxZNCountOpt;
        Result:=SumZR(Result,ZR3);
           expdiff:=HighDeciZR(Result,bool1).E - HighDeciZR(ZR3,bool2).E;
           appr:= expdiff < accur ;
      end;

      MaxZNCount:=BakMaxZNCount;
{
ZR=0,22  0,04 сек.  100 зн. 75 чл.р.
ZR=0,99  6,2 сек.  100 зн. 10959 чл.р.
Можно заметить, что на длинных числах функция может работать "бесконечно" долго
из-за медленной сходимости ряда при аргументе, близком к единице.
Поэтому здесь требуется выполнить оптимизацию алгоритма, основанную на сжатии
области определения функции, как и в функции определения Арктангенса (ArctanZR).
Для этого можно будет воспользоваться соотношениями:
arctanh(x) + arctanh(y) = arctanh((x+y)/(1+x*y))
arctanh(x) - arctanh(y) = arctanh((x-y)/(1-x*y))

Эта работа в планах.

Ещё можно вычислить arctanh(X), как Result:= 0.5 * Ln((1 + X) / (1 - X));

Замечания:
1) Алгоритм вычисления гиперболического арктангенса через разложение необходим
для вычисления константы натурального логарифма двух при значении аргумента
не более 0,2.
2) Поскольку Функция вычисления натурального логарифма на длинных числах очень
медленная операция, то имеет смысл поработать над алгоритмизацией разложения
функции гиперболического арктангенса. Ожидаемое ускорение работы функции 33%.
}
  end
  else  // if Comparison(ZR,StrToZR('0,2'))<=0
  begin  *)
    if MaxZNCount=0 then MaxZNCount:=1;
    if InfZNCount<MaxZNCount then InfZNCount:=MaxZNCount;
    MaxZNCount:=MaxZNCount+1;
//  Result:= 0.5 * Ln((1 + X) / (1 - X))
    Result:=MultZR(LnZR(DivZR(SumZR(OneZR,ZR),SubZR(OneZR,ZR))),StrToZR('0,5'));
    MaxZNCount:=MaxZNCount-1;
(*  end; *)
end;


// Арккотангенс гиперболический  (ареакотангенс)
function AcothZR(const ZR: ZReal ): ZReal;
begin
  if ComparisonZR(AbsZR(ZR),OneZR)<=0 then
  begin
    Messages('Функция AcothZR:'#13'Недопустимое значение аргумента функции.');
// в плюс/минус единице есть решение - плюс/минус бесконечность
    defaultZZReal(8,Result);  // создание нулевого "масштабируемого" числа
    Exit;
  end;
{
1) arccotanh(x) = arctanh(1/x)
2) arccotanh(x) = 1/x + 1/(3*(x^3)) + 1/(5*(x^5)) + ...
Дополнительные соотношениями:
arccotanh(x) + arccotanh(y) = arctanh((1+x*y)/(x+y))
arccotanh(x) - arccotanh(y) = arctanh((1-x*y)/(x-y))
3) arccotanh(x) = 0.5 * Ln((x + 1) / (x - 1))
}
    MaxZNCount:=MaxZNCount+4; // потому что  функция вычисляется за 2 операции (+2 на повышение точности)
    Result := AtanhZR(OneDivZR(ZR));
    MaxZNCount:=MaxZNCount-4;
end;


// Арккосинус гиперболический  (ареакосинус)
function AcoshZR(const ZR: ZReal ): ZReal;
var
  ZR1,ZR2:ZReal;
  BakMaxZNCount:Cardinal;
  eqv:ShortInt;
// функция двузначная и симметричная относительно оси X,
// решение выдаём только в положительной полуплоскости
begin
  eqv:=ComparisonZR(ZR,OneZR);
  if eqv<0 then
  begin
    Messages('Функция AcoshZR:'#13'Недопустимое значение аргумента функции.');
    defaultZZReal(8,Result);  // создание нулевого "масштабируемого" числа
    Exit;
  end
  else  if eqv=0 then
  begin
    Result := DefaultZR;
    Exit;
  end;
;
      if MaxZNCount=0 then MaxZNCount:=1;
      if InfZNCount<MaxZNCount then InfZNCount:=MaxZNCount;
{
//  Result := Ln(X + Sqrt((X * X) - 1)),
  BakMaxZNCount:=MaxZNCount;
  If MaxZNCount<MaxInt then  MaxZNCount:=MaxZNCount*2+2                          // - это очень грубое алгоритмическое решение проблемы повышения точности
  else MaxZNCount:=MaxZNCount+2;
  ZR1:=SqrZR(ZR);
  ZR2:=SubZR(ZR1,OneZR);
  ZR1:=SqrtZR(ZR2);
  MaxZNCount:=BakMaxZNCount+1;
  Result := LnZR(SumZR(ZR,ZR1));
  MaxZNCount:=BakMaxZNCount;
}
// но для сохранения точности и уменьшении времени вычисления функции рекомендуется
// другая формула вида: Result := Ln(X + Sqrt((X - 1) / (X + 1)) * (X + 1));
  MaxZNCount:=MaxZNCount+9; // потому что  функция вычисляется за 7 операций (+2 на повышение точности)
  ZR1:=SumZR(ZR,OneZR);
  ZR2:=SubZR(ZR,OneZR);
  Result := LnZR(SumZR(ZR,MultZR(SqrtZR(DivZR(ZR2,ZR1)),ZR1)));
  MaxZNCount:=MaxZNCount-9;

end;


// Арксинус гиперболический  (ареасинус)
function AsinhZR(const ZR: ZReal ): ZReal;
begin
      if MaxZNCount=0 then MaxZNCount:=1;
      if InfZNCount<MaxZNCount then InfZNCount:=MaxZNCount;

// Внимание! При попытке вычислить функцию при MaxZNCount меньше 4 может произойти
// полная потеря точности. Здесь эта ситуация пока никак не решена.

//  Result := Ln(X + Sqrt((X * X) + 1));
  MaxZNCount:=MaxZNCount+7; // потому что  функция вычисляется за 5 операций (+2 на повышение точности)
  Result := LnZR(SumZR(ZR,SqrtZR(SumZR(SqrZR(ZR),OneZR))));
  MaxZNCount:=MaxZNCount-7;
end;


// Константа - натуральный Логарифм Десяти  (Число из 1000 знаков)
function LnE10_ZR: ZReal;
begin
      Result:=StrToZR(
'23025850929940456840179914546843642076011014886287729760333279009675726096773'+
'52480235997205089598298341967784042286248633409525465082806756666287369098781'+
'68948290720832555468084379989482623319852839350530896537773262884616336622228'+
'76982198867465436674744042432743651550489343149393914796194044002221051017141'+
'74800368808401264708068556774321622835522011480466371565912137345074785694768'+
'34636167921018064450706480002775026849167465505868569356734206705811364292245'+
'54405758925724208241314695689016758940256776311356919292033376587141660230105'+
'70308963457207544037084746994016826928280848118428931484852494864487192780967'+
'62712757753970276686059524967166741834857044225071979650047149510504922147765'+
'67636938662976979522110718264549734772662425709429322582798502585509785265383'+
'20760672631716430950599508780752371033310119785754733154142180842754386359177'+
'81170543098274823850456480190956102992918243182375253577097505395651876975103'+
'74970888692180205189339507238539205144634197265287286965110862571492198849978748873771Z-1009');

// 23025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771Z-1009
end;


// Константа - натуральный Логарифм Трёх  (Число из 1000 знаков)
function LnE3_ZR: ZReal;
begin
      Result:=StrToZR(
'10986122886681096913952452369225257046474905578227494517346943336374942932186'+
'08966873615754813732088787970029065957865742368004225930519821052801870767277'+
'41060316276918338136717937369884436095990374257031679591152114559191775067134'+
'70549401667755802222031702529468975606901065215056428681380363173732985777823'+
'66991654792131818149020030103823630122248652748198225991097452490896458053467'+
'00884596508574844411901885708764749486707961308582941160216612118400140982551'+
'43919487688936798494302255731535329685345295251459213876494685932562794416556'+
'94157827231035516886610211846989043994306313825528573646688282498813682280063'+
'41439107868932514564375102044516275619349739821169415857405353617589009751222'+
'33797736969687754354795135712982177017581242122351405810163272465588937249564'+
'91918524296079668423464706937723725265508203207833392805589285314687309513260'+
'64583091843974968222303257654675333118230196492752575991322178513533902374829'+
'64339502546074245824934666866121881436526565429542767610505477795422933973323401173631Z-1009');

// 10986122886681096913952452369225257046474905578227494517346943336374942932186089668736157548137320887879700290659578657423680042259305198210528018707672774106031627691833813671793736988443609599037425703167959115211455919177506713470549401667755802222031702529468975606901065215056428681380363173732985777823669916547921318181490200301038236301222486527481982259910974524908964580534670088459650857484441190188570876474948670796130858294116021661211840014098255143919487688936798494302255731535329685345295251459213876494685932562794416556941578272310355168866102118469890439943063138255285736466882824988136822800634143910786893251456437510204451627561934973982116941585740535361758900975122233797736969687754354795135712982177017581242122351405810163272465588937249564919185242960796684234647069377237252655082032078333928055892853146873095132606458309184397496822230325765467533311823019649275257599132217851353390237482964339502546074245824934666866121881436526565429542767610505477795422933973323401173631Z-1009
end;


// гиперболический Косинус
function CoshZR(const ZR: ZReal ): ZReal;
var
  ZR1,ZR2:ZReal;
begin
  if ComparisonZR(ZR,DefaultZR)=0 then begin Result:=OneZR; Exit; end;
  MaxZNCount:=MaxZNCount+4;
//    Result := (Exp(X) + Exp(-X)) / 2;
  ZR1:=ePowZR(ZR);
  ZR2:=OneDivZR(ZR1);
  Result := MultZR(SumZR(ZR1,ZR2),StrToZR('0,5'));
  MaxZNCount:=MaxZNCount-4;
{
При больших значениях аргумента Функция даёт точный результат,
а вычисление той же функции в типе данных Double (Cosh) даёт погрешность в три знака.
}
end;


// гиперболический Синус
function SinhZR(const ZR: ZReal ): ZReal;
var
  ZR1,ZR2:ZReal;
begin
  if ComparisonZR(ZR,DefaultZR)=0 then begin Result:=DefaultZR; Exit; end;
  MaxZNCount:=MaxZNCount+4;
//    Result := (Exp(X) - Exp(-X)) / 2;
  ZR1:=ePowZR(ZR);
  ZR2:=OneDivZR(ZR1);
  Result := MultZR(SubZR(ZR1,ZR2),StrToZR('0,5'));
  MaxZNCount:=MaxZNCount-4;
{
При больших значениях аргумента Функция даёт точный результат,
а вычисление той же функции в типе данных Double (Sinh) даёт погрешность в три знака.
}
end;


// гиперболический Тангенс
function TanhZR(const ZR: ZReal ): ZReal;
var
  ZR1,ZR2:ZReal;
  hexp:Int64;
  bool:Boolean;
begin
  if ComparisonZR(ZR,DefaultZR)=0 then begin Result:=DefaultZR; Exit; end;
  hexp:=HighDeciZR(ZR,bool).E;
  if hexp<0 then hexp:=Abs(hexp) else hexp:=5;
  MaxZNCount:=MaxZNCount+hexp; //
//    Result := SinhZR(ZR) / CoshZR(ZR);
  ZR1:=ePowZR(ZR);
  ZR2:=OneDivZR(ZR1);
  MaxZNCount:=MaxZNCount+2; //
  Result := DivZR(SubZR(ZR1,ZR2),SumZR(ZR1,ZR2));
  MaxZNCount:=MaxZNCount-2; //
  MaxZNCount:=MaxZNCount-hexp;
end;


// гиперболический Котангенс
function CothZR(const ZR: ZReal ): ZReal;
var
  ZR1,ZR2:ZReal;
  hexp:Int64;
  bool:Boolean;
begin
//  if ComparisonZR(ZR,DefaultZR)=0 then begin Result:=InfiniteZR('+'); Exit; end;
  hexp:=HighDeciZR(ZR,bool).E;
  if hexp<0 then hexp:=Abs(hexp) else hexp:=5;
  MaxZNCount:=MaxZNCount+hexp;
//  Result := 1 / TanhZR(ZR);
  ZR1:=ePowZR(ZR);
  ZR2:=OneDivZR(ZR1);
  MaxZNCount:=MaxZNCount+2; //
  Result := DivZR(SumZR(ZR1,ZR2),SubZR(ZR1,ZR2));
  MaxZNCount:=MaxZNCount-2; //
  MaxZNCount:=MaxZNCount-hexp;
end;


// возведение числа в действительную степень
function PowerZR(const ZR: ZReal; Power: ZReal): ZReal;
//    Result := e^(Power * Ln(ZR))
var
  eqv:ShortInt;
  bool:Boolean;
  expP:Int64;
  BakMaxZNCount:Cardinal;
begin
  if ComparisonZR(AbsZR(Power),StrToZR('92233720368547758')) > 0 then  // DivZR(IntToZR(High(Int64)),IntToZR(100))
  begin
    Messages('Функция PowerZR:'#13'Недопустимое значение степени.'+#13+
             'Оно больше максимально допустимого числа 92233720368547758.0');
    defaultZZReal(8,Result);  // создание нулевого "масштабируемого" числа
    Exit;
  end;

  TrimRightZR(Power);
  eqv:=ComparisonZR(Power,DefaultZR);
  expP:=HighDeciZR(Power,bool).E;

  if eqv=0 then
    Result := OneZR
  else
    if ComparisonZR(ZR,DefaultZR)=0 then
    begin
      if eqv>0 then Result := DefaultZR else
      begin
        Messages('Функция PowerZR:'+#13+
        'Недопустимое значение степени при нулевом аргументе функции.');
        defaultZZReal(8,Result);  // создание нулевого "масштабируемого" числа
        Exit;
      end;
    end
    else
      if (expP<18) and (LowDeciZR(Power).E>=0) then
        Result := IntPowZR(ZR,ZRToInt(Power))
      else
      begin
        if (ZR.U='-') or (ZR.U='i') then // проверить это условие раньше мы не могли, потому что мы можем взять отрицательную целую степень числа
        begin
          Messages('Функция PowerZR:'#13'Недопустимое значение аргумента.'+#13+
                   'Оно меньше нуля.');
          defaultZZReal(8,Result);  // создание нулевого "масштабируемого" числа
          Exit;
        end;
// не забываем про повышение точности расчётов
          BakMaxZNCount:=MaxZNCount;
          MaxZNCount:=MaxZNCount+4;
        Result := MultZR(Power,LnZR(ZR));
          MaxZNCount:=MaxZNCount+expP;
        Result := ePowZR(Result);
          MaxZNCount:=BakMaxZNCount;
      end;
{
// ориентировочное время работы функции на различной точности вычислений при коротких аргументах (до 32 знаков)
  32 зн.  0,02 сек.
 100 зн.  0,1  сек.
 300 зн.  1,5  сек.
 500 зн.  5    сек.
 700 зн. 10    сек.
 800 зн. 14    сек.
 900 зн. 19    сек.
1000 зн. 25    сек.
}
end;


// Логарифм по основанию 2
function Log2ZR(const ZR: ZReal): ZReal;
// Учитываем, что LogN(X)=ln(X)/ln(N)
begin
    MaxZNCount:=MaxZNCount+1;
  Result:=DivZR(LnZR(ZR),LnE2_ZR);
    MaxZNCount:=MaxZNCount-1;
end;


// Логарифм по основанию 10
function Log10ZR(const ZR: ZReal): ZReal;
// Учитываем, что LogN(X)=ln(X)/ln(N)
begin
    MaxZNCount:=MaxZNCount+1;
  Result:=DivZR(LnZR(ZR),LnE10_ZR);
    MaxZNCount:=MaxZNCount-1;
end;


// Логарифм по основанию N
function LogNZR(const Base, ZR: ZReal): ZReal;
// Учитываем, что LogN(X)=ln(X)/ln(N)
begin
  if ComparisonZR(Base,OneZR)=0 then
  begin
    Messages('Функция LogNZR:'+#13+
    'Недопустимое значение основания логарифма (N=1).');
    defaultZZReal(8,Result);  // создание нулевого "масштабируемого" числа
    Exit;
  end;
    MaxZNCount:=MaxZNCount+1;
  Result:=DivZR(LnZR(ZR),LnZR(Base));
    MaxZNCount:=MaxZNCount-1;
{
1000 зн. 36 сек
}
end;


// Котангенс
function CotanZR(const ZR: ZReal ): ZReal;
// CotanZR = Cos(X) / Sin(X)
var
  sinus,cosin: ZReal;
begin
  if MaxZNCount=0 then MaxZNCount:=1;
  if InfZNCount<MaxZNCount then InfZNCount:=MaxZNCount;

  SinCosZR(ZR, sinus, cosin);
  if EqvToZR(sinus,DefaultZR) then
  begin
      Messages('Функция CotanZR: Деление на ноль');
      defaultZZReal(5,Result);  // создание нулевого масштабируемого числа
      exit;
  end
  else
  Result:=DivZR(cosin,sinus);
end;


// Косинус
function CosZR(const ZR: ZReal ): ZReal;
var
  BakMaxZNCount: Cardinal;
  arg: ZReal;
  InvUn: Boolean;
//  ZR0: ZReal;
begin
  if MaxZNCount=0 then MaxZNCount:=1;
  if InfZNCount<MaxZNCount then InfZNCount:=MaxZNCount;

{
  SinCosZR(ZR, ZR0, Result);
}
    BakMaxZNCount:=MaxZNCount;
    MaxZNCount:=MaxZNCount+3;

// 1) сокращение области аргумента до |Pi|
    arg:=squeezeArea(ZR);

// 2) определяемся со знаком аргумента  (только применительно к синусу, поэтому здесь этот шаг пропускаем)

// 3) сокращение области аргумента до Pi/2
    if ComparisonZR(arg,PiDiv2_ZR)<=0
    then Si_Co(arg, Result, (-1))
    else
    begin
      Si_Co(SubZR(arg,PiDiv2_ZR), Result, 1);
      Result:=InvertUnaryZR(Result); // для косинуса
    end;
{
}

    MaxZNCount:=BakMaxZNCount;
end;


// Синус
function SinZR(const ZR: ZReal ): ZReal;
var
  BakMaxZNCount: Cardinal;
  arg: ZReal;
  InvUn: Boolean;
//  ZR0: ZReal;

begin
  if MaxZNCount=0 then MaxZNCount:=1;
  if InfZNCount<MaxZNCount then InfZNCount:=MaxZNCount;

{
  SinCosZR(ZR, Result, ZR0); // тест
}
    BakMaxZNCount:=MaxZNCount;
    MaxZNCount:=MaxZNCount+3;

// 1) сокращение области аргумента до |Pi|
    arg:=squeezeArea(ZR);

// 2) определяемся со знаком аргумента  (применительно к синусу)
    if LessThanZR(arg,defaultZR) then
    begin
      arg:=InvertUnaryZR(arg);
      InvUn:=True;
    end
    else InvUn:=False;

// 3) сокращение области аргумента до Pi/2
    if ComparisonZR(arg,PiDiv2_ZR)<=0
    then Si_Co(arg, Result, 1)
    else
    begin
      Si_Co(SubZR(arg,PiDiv2_ZR), Result, (-1));
    end;
{
}
    if InvUn then Result:=InvertUnaryZR(Result);

    MaxZNCount:=BakMaxZNCount;
end;


// Синус и Косинус (одновременное вычисление)
procedure SinCosZR(const Theta: ZReal; out Sin, Cos: ZReal);
// Copyright © 2005 Nikolai Victorovich Botcharov
var
  arg: ZReal;
  BakMaxZNCount: Cardinal;
  metod: Byte;
  InvUn: Boolean;

  function Tg(Const A: ZReal): ZReal;
// вычисление тангенса методом цепной дроби  tan(x) = x/(1-x^2/(3-x^2/(5-x^2/(7-x^2/...)))).
// при аргументе [0; Pi/8]
  var
//    BakMaxZNCount01: Cardinal;   // местное повышение точности не влияет на конечный результат
    ZR1, ZR2: ZReal;
    i,n,k: Integer;
  begin
//    BakMaxZNCount01:=MaxZNCount;
//    MaxZNCount:=MaxZNCount+4;

    n:=MaxZNCount div 2;  // для обеспечения сходимости на любом числе знаков при значении аргумента не больше, чем |pi/8|
    ZR2:=SqrZR(A);
    ZR1:=DefaultZR;
    k:=n*2+3;
    MaxZNCount:=0;                 // к оптимизации времени вычисления функции
    for i:=n downto 0 do
    begin
      MaxZNCount:=MaxZNCount+2;    // к оптимизации времени вычисления функции
      if i=0 then ZR1:=DivZR(A,SubZR(OneZR,ZR1))
      else begin k:=k-2; ZR1:=DivZR(ZR2,SubZR(IntToZR(k),ZR1)); end;
    end;
//    MaxZNCount:=BakMaxZNCount01;
    Result:=ZR1;
  end;

  procedure _Sico(Const arg: ZReal; out Sin, Cos: ZReal); // если не указать "out", то результаты обнулятся
// Sin, Cos при аргументе [0; Pi/4]
// где    sin(a)=2*tg(a/2)/(1+tg(a/2)^2); cos(a)=(1-tg(a/2)^2)/(1+tg(a/2)^2).
  var
    ar, arg2,t: ZReal;
//    BakMaxZNCount02: Cardinal;  // местное повышение точности не влияет на конечный результат
  begin
//    BakMaxZNCount02:=MaxZNCount;
//    MaxZNCount:=MaxZNCount+4;
    ar:=arg;
    ar:=MultZR(ar,STrToZR('0.5')); // половинный аргумент
    t:=Tg(ar);                      // тангенс половинного аргумента
    ar:=SqrZR(t);
    arg2:=SumZR(ar,OneZR);
    arg2:=DivZR(OneZR,arg2);

    Sin:=MultZR(t,arg2);
    Sin:=MultZR(Sin,TwoZR);          // решение - синус

    Cos:=SubZR(OneZR,ar);
    Cos:=MultZR(Cos,arg2);           // решение - косинус
//    MaxZNCount:=BakMaxZNCount02;
  end;

  procedure Sico(Const arg: ZReal; out Sin, Cos: ZReal); // если не указать "out", то результаты обнулятся
// Sin, Cos при аргументе [0; Pi/2]
  begin
    if ComparisonZR(arg,PiDiv4_ZR)<=0
    then _Sico(arg, Sin, Cos)
    else _Sico(SubZR(PiDiv2_ZR,arg), Cos, Sin);
  end;

  procedure _Sico1(Const arg: ZReal; out Sin, Cos: ZReal); // если не указать "out", то результаты обнулятся
// Sin, Cos при аргументе [0; Pi/4]
  begin
    Sin:=_SinZR(arg);              // решение - синус
    Cos:=cathetZR(OneZR,Sin);      // решение - косинус
  end;

  procedure Sico1(Const arg: ZReal; out Sin, Cos: ZReal); // если не указать "out", то результаты обнулятся
// Sin, Cos при аргументе [0; Pi/2]
  begin
    if ComparisonZR(arg,PiDiv4_ZR)<=0
    then _Sico1(arg, Sin, Cos)
    else _Sico1(SubZR(PiDiv2_ZR,arg), Cos, Sin);
  end;

begin
  if MaxZNCount=0 then MaxZNCount:=1;
  if InfZNCount<MaxZNCount then InfZNCount:=MaxZNCount;

   metod:=1; //---! ! !--- Выберите метод приближённого вычисления Арктангенса
// 0 - Алгоритм Никитина через Тангенс половинного угла
// 1 - метод разложения функции Sin(X) или Cos(X)  в ряд (более быстрый на высокой точности)
    case metod of

0:begin
// Переведённый на Delphi, дополненный на всю область определения аргумента функции
// и оптимизированный для мультиразрядных вычислений алгоритм Никитина,
// Copyright © Nikitin V.F. 2000
(*
/* Sine and cosine without mathematic library. Optimized for floating
   point single precision.
   Copyright (c) Nikitin V.F. 2000

   Calculate sine and cosine within [0, PI/4]:
   void _Sico(float arg,float *sine,float *cosi);

   Calculate sine and cosine within [0, PI/2]:
   void Sico(float arg,float *sine,float *cosi);

   Calculate sine and cosine within one period [-PI, PI]:
   void Sico1p(float arg,float *sine,float *cosi);

   No argument domain check is performed: insert yourself.
*/

#define M_PI ((float)3.141592653589793)
#define M_PI4 (M_PI*0.25F)
#define M_PI2 (M_PI*0.5F)

/* sine and cosine within 0-PI/4. MFRAC=4 optimized for single precision */
#define MFRAC 4	
void _Sico(float arg, float *sine, float *cosi) {
  int n,n2;
  float arg2,t;
  /* calculate tangent by continuous fraction */
  t=0.; arg*=0.5F; arg2=arg*arg; n=MFRAC-1; n2=(n<<1)+1;
  for(;n>=0;n--) {
    if(n>0) t=arg2/(n2-t);
    else t=arg/(1.F-t);
    n2--; n2--;
  }
  /* sine and cosine */
  arg=t*t; arg2=arg+1.F; arg2=1.F/arg2;
  *sine=t*arg2; *sine+=(*sine);
  *cosi=1.F-arg; *cosi*=arg2;
}

/* argument 0-PI/2 */
void Sico(float arg, float *sine, float *cosi) {
  if(arg<=M_PI4) _Sico(arg,sine,cosi);
  else _Sico(M_PI2-arg,cosi,sine);
}

/* first period: -PI<=arg<=PI */
void Sico1p(float arg, float *sine, float *cosi) {
  int s=0;
  if(arg<0.F) {arg=-arg;s=1;}
  if(arg<=M_PI2) Sico(arg,sine,cosi);
  else {
    Sico(arg-M_PI2,cosi,sine);
    *cosi=-(*cosi);
  }
  if(s) *sine=-(*sine);
}
*)
    BakMaxZNCount:=MaxZNCount;
    MaxZNCount:=MaxZNCount+13; // пока не понятно, почему здесь (иногда) ТРЕБУЕТСЯ очень большое повышение точности
// значение 13 получено экспериментально

// сокращение области аргумента до |Pi|
    arg:=squeezeArea(Theta);  // точность arg зависит от значения экспоненты Theta

// переопределение знака аргумента
    if LessThanZR(arg,defaultZR) then
    begin
      arg:=InvertUnaryZR(arg);
      InvUn:=True;
    end
    else InvUn:=False;

// сокращение области аргумента до [0; Pi/2]
    if ComparisonZR(arg,PiDiv2_ZR)<=0
    then Sico(arg, Sin, Cos)
    else begin Sico(SubZR(arg,PiDiv2_ZR), Cos, Sin); Cos:=InvertUnaryZR(Cos); end;

    if InvUn then Sin:=InvertUnaryZR(Sin);
    MaxZNCount:=BakMaxZNCount;
{
Sin:
100  знаков   0,07 сек
1000 знаков  22,0  сек
}
  end;

1: begin
    BakMaxZNCount:=MaxZNCount;
    MaxZNCount:=MaxZNCount+3; //

// 1) сокращение области аргумента до |Pi|
    arg:=squeezeArea(Theta);
//    MaxZNCount:=MaxZNCount-3; // для ускорения дальнейших вычислений

// 2) определяемся со знаком аргумента
    if LessThanZR(arg,defaultZR) then
    begin
      arg:=InvertUnaryZR(arg);
      InvUn:=True;
    end
    else InvUn:=False;

// 3) сокращение области аргумента до Pi/2
    if ComparisonZR(arg,PiDiv2_ZR)<=0
    then Sico1(arg, Sin, Cos)
    else begin Sico1(SubZR(arg,PiDiv2_ZR), Cos, Sin); Cos:=InvertUnaryZR(Cos); end;

// 4) сокращение области аргумента до Pi/4
//   -> Sico1
// далее вычисляем значение функции через разложение одной из функций в ряд
// и представление другой по формуле вычисления катета (cathetZR)
//   -> _Sico1

    if InvUn then Sin:=InvertUnaryZR(Sin);

    MaxZNCount:=BakMaxZNCount;
   end;
    end; // case
{
Сравнительная таблица времён работы методов  (в миллисекундах)

Аргумент: 1,099994e+912   1,0999942e+14     3,999995     1,5599995
Метод:     1-й    2-й      1-й    2-й      1-й    2-й    1-й    2-й
1000 зн.¦  21491  13439   21891  10765    21491  16013  21290   9373
100  зн.¦    260    250      80     60       70     80     70     50
Как видно, возможность применения оптимизации при вычислении разложений
положительно сказалась на общем времени вычисления функций с высокой точностью

Отдельное вычисление косинуса функцией CosZR
Аргумент: 3,999995
1000 зн.¦  18216
100  зн.¦     80
Отдельное вычисление синуса функцией SinZR
Аргумент: 3,999995
1000 зн.¦  14360
100  зн.¦     55
Как видно разложение для синуса сходится гораздо быстрее
}
end;


// Перевод действительного "масштабируемого" числа в длинное целое
function ZRToLongInt(Const ZR: ZReal; Typ: ShortInt = 0): ZReal;
// Copyright © 2005 Nikolai Victorovich Botcharov
// typ - назначаемое правило округления
// -1 - без округления (обрезание)
// 0 - правило округления по умолчанию (зависит от значения RoundZN)
// 1 - округление в большую сторону
var
  exp:Int64;
  l,shiftar:Integer;
  k:Cardinal;
begin
  if Abs(Typ)>1 then Typ:=0; // исключаем из рассмотрения недопустимые значения для правила округления
  exp:=LowDeciZR(ZR).E;
  if exp>=0 then begin Result:=ZR; Exit; end;     // число уже есть длинное целое
  l:=Length(ZR.I);
  if (exp+l)<0 then begin Result:=DefaultZR; Exit; end // округлённое число есть ноль
  else if(exp+l)=0 then
      begin
        case Typ of
        -1: begin Result:=DefaultZR; Exit; end;
         0: begin
              if RoundZN=0 then  begin Result:=DefaultZR; Exit; end;  // не забываем про особый случай
              if ZR.I[High(ZR.I)]>=RoundZN
              then begin Result:=OneZR; Result.U:=ZR.U; end
              else Result:=DefaultZR;
              Exit;
            end;
         1: begin Result:=OneZR; Result.U:=ZR.U; Exit; end;
        end; // case
      end
      else
      begin
//  Result:=ZR;
        exp:=Abs(exp);  // exp  у нас здесь меньше нуля
        shiftar:=l-exp;
        SetLength(Result.I,shiftar) ;
        Result.U:=ZR.U;
        Result.R:=ZR.R;
        for k:=0 to abs(shiftar)-1 do
        begin Result.I[k]:=ZR.I[k+exp] end; // сдвиг числового массива
        case Typ of
        -1: Exit;  // результирующее число уже готово
         0:begin
              if RoundZN=0 then  Exit;  // не забываем про особый случай
              if ZR.I[exp-1]>=RoundZN
              then if Result.U='-'
                   then Result:=SubZR(Result,OneZR)
                   else Result:=SumZR(Result,OneZR);
              Exit;
           end;
         1:begin
              if Result.U='-'
              then Result:=SubZR(Result,OneZR)
              else Result:=SumZR(Result,OneZR);
              Exit;
           end;
        end; // case
      end;

end;


end.

